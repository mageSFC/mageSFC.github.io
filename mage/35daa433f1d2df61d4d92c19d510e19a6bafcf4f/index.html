<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spring学习笔记总结 | 马哥私房菜</title><meta name="author" content="mage"><meta name="copyright" content="mage"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring   学习 1.什么是spring? 123456789101112131415161718Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。Spring的本质是一个bean工厂(beanFacto">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring学习笔记总结">
<meta property="og:url" content="https://magesfc.github.io/mage/35daa433f1d2df61d4d92c19d510e19a6bafcf4f/">
<meta property="og:site_name" content="马哥私房菜">
<meta property="og:description" content="Spring   学习 1.什么是spring? 123456789101112131415161718Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。Spring的本质是一个bean工厂(beanFacto">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg">
<meta property="article:published_time" content="2022-02-23T09:47:21.000Z">
<meta property="article:modified_time" content="2022-02-23T09:47:21.000Z">
<meta property="article:author" content="mage">
<meta property="article:tag" content="spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg"><link rel="shortcut icon" href="http://www.blackshark.com/favicon.ico"><link rel="canonical" href="https://magesfc.github.io/mage/35daa433f1d2df61d4d92c19d510e19a6bafcf4f/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: mage","link":"链接: ","source":"来源: 马哥私房菜","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring学习笔记总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-23 17:47:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">.card-announcement .social-button{margin:.6rem 0 0 0;text-align:center}.card-announcement .social-button a{display:block;background-color:var(--btn-bg);color:var(--btn-color);text-align:center;line-height:2.4;margin:4px 0}.card-announcement .social-button a:hover{background-color:var(--btn-hover-color)}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">167</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">185</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 精选文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> 🚀 快速开始</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/dc584b87/"><span> 📑 主题页面</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4aa8abbe/"><span> 🛠 主题配置-1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/ceeb73f/"><span> 🛠 主题配置-2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/98d20436/"><span> ❓ 主题问答</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4073eda/"><span> ⚡️ 进阶教程</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/198a4240/"><span> ✨ 更新日志</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://butterfly.js.org/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> 其他示例</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">马哥私房菜</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 精选文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> 🚀 快速开始</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/dc584b87/"><span> 📑 主题页面</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4aa8abbe/"><span> 🛠 主题配置-1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/ceeb73f/"><span> 🛠 主题配置-2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/98d20436/"><span> ❓ 主题问答</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4073eda/"><span> ⚡️ 进阶教程</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/198a4240/"><span> ✨ 更新日志</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://butterfly.js.org/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> 其他示例</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring学习笔记总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-23T09:47:21.000Z" title="发表于 2022-02-23 17:47:21">2022-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-23T09:47:21.000Z" title="更新于 2022-02-23 17:47:21">2022-02-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/spring/">spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring学习笔记总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Spring   学习</p>
<p>1.什么是spring?</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。</span><br><span class="line"></span><br><span class="line">Spring的本质是一个bean工厂(beanFactory)或者说bean容器，它按照我们的要求，生产我们需要的各种各样的bean，提供给</span><br><span class="line">我们使用。只是在生产bean的过程中，需要解决bean之间的依赖问题，才引入了依赖注入(DI)这种技术。也就是说依赖注入是</span><br><span class="line">beanFactory生产bean时为了解决bean之间的依赖的一种技术而已。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那么我们为什么需要Spring框架来给我们提供这个beanFactory的功能呢？原因是一般我们认为是，可以将原来硬编码的依赖，</span><br><span class="line">通过Spring这个beanFactory这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring这个</span><br><span class="line">beanFactory，由它来解决bean之间的依赖问题，达到了松耦合的效果；这个只是原因之一，还有一个更加重要的原因：在没有</span><br><span class="line">spring这个beanFactory之前，我们都是直接通过new来实例化各种对象，现在各种对象bean的生产都是通过beanFactory来</span><br><span class="line">实例化的，这样的话，spring这个beanFactory就可以在实例化bean的过程中，做一些小动作——在实例化bean的各个阶段进行</span><br><span class="line">一些额外的处理，也就是说beanFactory会在bean的生命周期的各个阶段中对bean进行各种管理，并且spring将这些阶段通过</span><br><span class="line">各种接口暴露给我们，让我们可以对bean进行各种处理，我们只要让bean实现对应的接口，那么spring就会在bean的生命周期</span><br><span class="line">调用我们实现的接口来处理该bean。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Spring是一个开源框架，处于MVC模式中的控制层，它能应对需求快速的变化，其主要原因它有一种面向切面编程（AOP）的优势，</span><br><span class="line">其次它提升了系统性能，因为通过依赖倒置机制（IOC），系统中用到的对象不是在系统加载时就全部实例化，</span><br><span class="line">而是在调用到这个类时才会实例化该类的对象，从而提升了系统性能。这两个优秀的性能使得Spring受到许多J2EE公司的青睐，</span><br><span class="line">如阿里里中使用最多的也是Spring相关技术。</span><br><span class="line"></span><br><span class="line">Spring的优点：</span><br><span class="line"></span><br><span class="line">1、降低了组件之间的耦合性，实现了软件各层之间的解耦。</span><br><span class="line"></span><br><span class="line">2、可以使用容易提供的众多服务，如事务管理，消息服务，日志记录等。</span><br><span class="line"></span><br><span class="line">3、容器提供了AOP技术，利用它很容易实现如权限拦截、运行期监控等功能。</span><br><span class="line"></span><br><span class="line">Spring中AOP技术是设计模式中的动态代理模式。只需实现jdk提供的动态代理接口InvocationHandler，</span><br><span class="line">所有被代理对象的方法都由InvocationHandler接管实际的处理任务。面向切面编程中还要理解切入点、切面、通知、织入等概念。</span><br><span class="line"></span><br><span class="line">Spring中IOC则利用了Java强大的反射机制来实现。所谓依赖注入即组件之间的依赖关系由容器在运行期决定。</span><br><span class="line">其中依赖注入的方法有两种，通过构造函数注入，通过set方法进行注入。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.使用Spring框架的好处是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">轻量：Spring 是轻量的，基本的版本大约2MB。</span><br><span class="line">控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</span><br><span class="line">面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</span><br><span class="line">容器：Spring 包含并管理应用中对象的生命周期和配置。</span><br><span class="line">MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</span><br><span class="line">事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</span><br><span class="line">异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.Spring由哪些模块组成?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">以下是Spring 框架的基本模块：</span><br><span class="line"></span><br><span class="line">Core module</span><br><span class="line">Bean module</span><br><span class="line">Context module</span><br><span class="line">Expression Language module</span><br><span class="line">JDBC module</span><br><span class="line">ORM module</span><br><span class="line">OXM module</span><br><span class="line">Java Messaging Service(JMS) module</span><br><span class="line">Transaction module</span><br><span class="line">Web module</span><br><span class="line">Web-Servlet module</span><br><span class="line">Web-Struts module</span><br><span class="line">Web-Portlet module</span><br></pre></td></tr></table></figure>

<p>4.核心容器（应用上下文) 模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是基本的Spring模块，提供spring框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。</span><br><span class="line">Spring 框架建立在此模块之上，它使Spring成为一个容器。</span><br></pre></td></tr></table></figure>

<p>5.BeanFactory – BeanFactory 实现举例。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从正真的应用代码中分离。</span><br><span class="line">最常用的BeanFactory 实现是 XmlBeanFactory 类。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.XMLBeanFactory </p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据XML文件中的定义加载beans。</span><br><span class="line">该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>7.解释AOP模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AOP模块用于发给我们的Spring应用做面向切面的开发， 很多支持由AOP联盟提供，这样就确保了Spring和其他AOP框架的共通性。这个模块将元数据编程引入Spring。</span><br></pre></td></tr></table></figure>

<p>8.解释JDBC抽象和DAO模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</span><br></pre></td></tr></table></figure>

<p>9.解释对象&#x2F;关系映射集成模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate,JDO和 iBATIS SQL Maps。Spring的事务管理同样支持以上所有ORM框架及JDBC。</span><br></pre></td></tr></table></figure>

<p>10.解释WEB 模块。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring的WEB模块是构建在application context 模块基础之上，提供一个适合web应用的上下文。这个模块也包括支持多种面向web的任务，</span><br><span class="line">如透明地处理多个文件上传请求和程序级请求参数的绑定到你的业务对象。它也有对Jakarta Struts的支持。</span><br></pre></td></tr></table></figure>

<p>12.Spring配置文件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</span><br></pre></td></tr></table></figure>

<p>13.什么是Spring IOC 容器？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</span><br></pre></td></tr></table></figure>

<p>14.IOC的优点是什么？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。</span><br><span class="line">最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。</span><br></pre></td></tr></table></figure>

<p>15.ApplicationContext通常的实现是什么?</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</span><br><span class="line">ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</span><br><span class="line">WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</span><br></pre></td></tr></table></figure>

<p>16.BeanFactory 和 ApplicationContext  有什么区别？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Spring 使用 BeanFactory 来实例化、配置和管理 Bean。</span><br><span class="line">如果说BeanFactory是Spring的心脏，那么ApplicationContext就是完整的躯体了.</span><br><span class="line"></span><br><span class="line">ApplicationContext 由 BeanFactory派生而来，提供了更多面向实际应用的功能。</span><br><span class="line">在BeanFactory中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置实现。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ApplicationContext提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的bean发布事件。</span><br><span class="line">另外，在容器或容器内的对象上执行的那些不得不由bean工厂以程序化方式处理的操作，可以在Application contexts中以声明的方式处理。</span><br><span class="line">Application contexts实现了MessageSource接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。</span><br><span class="line"></span><br><span class="line">1.BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的Spring的配置问题。</span><br><span class="line">而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。 </span><br><span class="line">相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</span><br><span class="line"></span><br><span class="line">BeanFacotry延迟加载,如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常；</span><br><span class="line">而ApplicationContext则在初始化自身是检验，这样有利于检查所依赖属性是否注入；所以通常情况下我们选择使用 ApplicationContext。</span><br><span class="line">应用上下文则会在上下文启动后预载入所有的单实例Bean。通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</span><br><span class="line"></span><br><span class="line">2.BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，</span><br><span class="line">但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</span><br><span class="line">（Applicationcontext比 beanFactory 加入了一些更好使用的功能。而且 beanFactory 的许多功能需要通过编程实现</span><br><span class="line">而 Applicationcontext 可以通过配置实现。比如后处理 bean ， Applicationcontext 直接配置在配置文件即可而 </span><br><span class="line">beanFactory 这要在代码中显示的写出来才可以被容器识别。 ）</span><br><span class="line"></span><br><span class="line">3.beanFactory主要是面对与 spring 框架的基础设施，面对 spring 自己。</span><br><span class="line">而 Applicationcontex 主要面对与 spring 使用的开发者。基本都会使用 Applicationcontex 并非 beanFactory 。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>17.一个Spring的应用看起来象什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个定义了一些功能的接口。</span><br><span class="line">这实现包括属性，它的Setter ， getter 方法和函数等。</span><br><span class="line">Spring AOP。</span><br><span class="line">Spring 的XML 配置文件。</span><br><span class="line">使用以上功能的客户端程序。</span><br><span class="line">依赖注入</span><br></pre></td></tr></table></figure>

<p>18.什么是Spring的依赖注入？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。</span><br><span class="line">你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。</span><br></pre></td></tr></table></figure>


<p>19.有哪些不同类型的IOC（依赖注入）方式？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">依赖注入的方式分为 构造函数注入 和 setter方法注入：</span><br><span class="line">构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</span><br><span class="line">    &lt;bean id=&quot;car&quot; class=&quot;com.mamh.spring.demo.beans.Car&quot;&gt;</span><br><span class="line">        &lt;constructor-arg value=&quot;Audi&quot; index=&quot;0&quot;/&gt;      &lt;!-- 通过构造方法设置属性值 --&gt;</span><br><span class="line">        &lt;constructor-arg value=&quot;shanghai&quot; index=&quot;1&quot;/&gt;  &lt;!-- 按照参数顺序来配置 --&gt;</span><br><span class="line">        &lt;constructor-arg value=&quot;123&quot; index=&quot;2&quot;/&gt;    &lt;!-- 对于引用 可以使用ref 替换value--&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</span><br><span class="line">    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">      &lt;property name=&quot;configLocation&quot; value=&quot;classpath:config/mybatis-config.xml&quot; /&gt;</span><br><span class="line">      &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:config/mappers/**/*.xml&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">集合等复杂类型的注入</span><br><span class="line">&lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt;</span><br><span class="line">    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span><br><span class="line">    &lt;property name=&quot;adminEmails&quot;&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeList(java.util.List) call --&gt;</span><br><span class="line">    &lt;property name=&quot;someList&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;a list element followed by a reference&lt;/value&gt;</span><br><span class="line">            &lt;ref bean=&quot;myDataSource&quot; /&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span><br><span class="line">    &lt;property name=&quot;someMap&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;</span><br><span class="line">            &lt;entry key =&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span><br><span class="line">    &lt;property name=&quot;someSet&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;value&gt;just some string&lt;/value&gt;</span><br><span class="line">            &lt;ref bean=&quot;myDataSource&quot; /&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"> 也很简单，list属性就是 &lt;list&gt;里面包含&lt;value&gt;或者&lt;ref&gt;或者&lt;bean&gt;, set也类似。</span><br><span class="line"> map是&lt;map&gt;里面包含&lt;entry&gt;这个也好理解，因为map的实现就是使用内部类Entry来存储key和value.</span><br><span class="line">  Properties是 &lt;props&gt;里面包含&lt;prop&gt;.</span><br><span class="line"></span><br><span class="line">&lt;bean&gt; 除了 id 和 class 属性之外，还有一些可选的属性:</span><br><span class="line">1) scope属性，默认&lt;bean&gt; 的 scope就是 singleton=&quot;true&quot;, </span><br><span class="line">springmvc和struts2的重要区别之一就是spring的controll是单例的，而struts2的action是：scope=&quot;prototype&quot; ，</span><br><span class="line">还有 scope=&quot;request&quot; ， scope=&quot;session&quot;，scope=&quot;globalSession&quot;(仅用于portlet)</span><br><span class="line">2）abstract属性，是否是抽象的bean：</span><br><span class="line">3）depends-on 依赖于某个bean，其必须先初始化：&lt;bean id=&quot;xxx&quot; class=&quot;xxx&quot; depends-on=&quot;refbean&quot; /&gt;</span><br><span class="line">4）lazy-init=&quot;true&quot; 是否延迟初始化，默认为 false</span><br><span class="line">5) dependency-check 是否对bean依赖的其它bean进行检查，默认值为 none，可取值有：none, simple, object, all等</span><br><span class="line">6）factory-method 和 factory-bean用于静态工厂和非静态工厂：</span><br><span class="line">7）init-method, destory-method 指定bean初始化和死亡时调用的方法，常用于 dataSource的连接池的配置</span><br><span class="line">8) lookup-method 方法注入：</span><br><span class="line">9) autowire 是否启用自动装配依赖，默认为 no, 其它取值还有：byName, byType, constructor</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>20.哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你两种依赖方式都可以使用，构造器注入和Setter方法注入。</span><br><span class="line">最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</span><br></pre></td></tr></table></figure>


<p>Spring Beans<br>21.什么是Spring beans?</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。</span><br><span class="line">这些beans通过容器中配置的元数据创建。比如，以XML文件中&lt;bean/&gt; 的形式定义。</span><br><span class="line"></span><br><span class="line">Spring 框架定义的beans都是单件beans。在bean tag中有个属性”singleton”，如果它被赋为TRUE，bean 就是单件，</span><br><span class="line">否则就是一个 prototype bean。默认是TRUE，所以所有在Spring框架中的beans 缺省都是单件。</span><br></pre></td></tr></table></figure>

<p>22.一个 Spring Bean 定义 包含什么？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</span><br></pre></td></tr></table></figure>

<p>23.如何给Spring 容器提供配置元数据?</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">这里有三种重要的方法给Spring 容器提供配置元数据。</span><br><span class="line"></span><br><span class="line">XML配置文件。  就是配置&lt;bean&gt; 这样的节点</span><br><span class="line"></span><br><span class="line">基于注解的配置。</span><br><span class="line">注解的方式就是类上加上 注解，可以使用的有@Component，@Controller，@Repository，@Service</span><br><span class="line">还可以配合&lt;context:component-scan/&gt;一起使用，自动扫描哪些包下面的类。配置 &lt;context:annotation-config/&gt;元素开启注解功能。</span><br><span class="line">@Component：一个泛化的概念，表示一个组件（Bean），可作用在任何层次</span><br><span class="line">@Controller：用于对Controller实现类进行标注，目前该功能与Component相同</span><br><span class="line">@Repository：用于对DAO实现类进行标注</span><br><span class="line">@Service：用于对Service实现类进行标注，目前该功能与Component相同</span><br><span class="line"></span><br><span class="line">基于java的配置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">基于XML的配置主要使用场景：</span><br><span class="line">    第三方类库，如DataSource、JdbcTemplate等；</span><br><span class="line">    命名空间，如aop、context等；</span><br><span class="line">基于注解的配置主要使用场景：</span><br><span class="line">    Bean的实现类是当前项目开发的，可直接在Java类中使用注解配置</span><br><span class="line">基于Java类的配置主要使用场景：</span><br><span class="line">    对于实例化Bean的逻辑比较复杂，则比较适合用基于Java类配置的方式</span><br><span class="line">    </span><br><span class="line">在日常的开发中我们主要是使用XML配置和注解配置方式向结合的开发方式，一般不推荐使用基于Java类的配置方式。</span><br></pre></td></tr></table></figure>


<p>24.你怎样定义类的作用域?</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当定义一个&lt;bean&gt; 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。</span><br><span class="line">如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。</span><br><span class="line">另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性必须设为 singleton。</span><br></pre></td></tr></table></figure>

<p>25.解释Spring支持的几种bean的作用域。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Spring框架支持以下五种bean的作用域：</span><br><span class="line"></span><br><span class="line">singleton : bean在每个Spring ioc 容器中只有一个实例。</span><br><span class="line">prototype：一个bean的定义可以有多个实例。</span><br><span class="line"></span><br><span class="line">request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</span><br><span class="line">session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</span><br><span class="line"></span><br><span class="line">global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</span><br><span class="line"></span><br><span class="line">缺省的Spring bean 的作用域是Singleton.</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>26.Spring框架中的单例bean是线程安全的吗?</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不，Spring框架中的单例bean不是线程安全的。</span><br></pre></td></tr></table></figure>

<p>27.解释Spring框架中bean的生命周期。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">Spring容器 从XML 文件中读取bean的定义，并实例化bean。</span><br><span class="line">Spring根据bean的定义填充所有的属性。</span><br><span class="line">如果bean实现了 BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。</span><br><span class="line">如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。</span><br><span class="line">如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</span><br><span class="line">如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</span><br><span class="line">如果有 BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。</span><br><span class="line">如果bean实现了 DisposableBean，它将调用destroy()方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        实例化BeanFactoryPostProcessor实现类</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">执行 BeanFactoryPostProcessor 的 postProcessBeanFactory方法</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">        实例化 BeanPostProcessor 实现类</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">实例化 InstantiationAwareBeanPostProcessorAdapter 实现类</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">执行 InstantiationAwareBeanPostProcessor  的 postProcessBeforeInstantiation方法</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">            执行bean构造方法</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">执行 InstantiationAwareBeanPostProcessor 的 postProcessPropertyValues 方法</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">            为 bean 注入属性</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">    调用 BeanNameAware 的 setBeanName 方法</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">    调用 BeanFactoryAware 的 setBeanFactory 方法</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">执行 BeanPostProcessor 的 postProcessBeforeInitialization 方法</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">调用 initializingBean 的 afterPropertiesSet 方法</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">    调用bean的 init-method 属性指定的方法</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">执行  BeanPostProcessor 的 postProcessAfterInitialization 方法</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">    容器初始化成功，执行正常调用后，下面销毁容器</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">    调用 DiposibleBean 的 destroy 方法</span><br><span class="line">                    ^</span><br><span class="line">                    |</span><br><span class="line">    调用bean的 destroy-method 属性指定的方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</span><br><span class="line"></span><br><span class="line">1、Bean自身的方法　　：　　这个包括了Bean本身调用的方法和通过配置文件中&lt;bean&gt;的init-method和destroy-method指定的方法</span><br><span class="line"></span><br><span class="line">2、Bean级生命周期接口方法　　：　　这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</span><br><span class="line"></span><br><span class="line">3、容器级生命周期接口方法　　：　　这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</span><br><span class="line"></span><br><span class="line">4、工厂后处理器接口方法　　：　　这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器　　接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</span><br></pre></td></tr></table></figure>


<p>28.哪些是重要的bean生命周期方法？ 你能重载它们吗？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown  它是在容器卸载类的时候被调用。</span><br><span class="line"></span><br><span class="line">bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</span><br></pre></td></tr></table></figure>

<p>29.什么是Spring的内部bean？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean，为了定义inner bean，在Spring 的 基于XML的 配置元数据中，</span><br><span class="line">可以在 &lt;property/&gt;或 &lt;constructor-arg/&gt; 元素内使用&lt;bean/&gt; 元素，内部bean通常是匿名的，它们的Scope一般是prototype。</span><br></pre></td></tr></table></figure>

<p>30.在 Spring中如何注入一个java集合？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Spring提供以下几种集合的配置元素：</span><br><span class="line"></span><br><span class="line">&lt;list&gt;类型用于注入一列值，允许有相同的值。</span><br><span class="line">&lt;set&gt; 类型用于注入一组值，不允许有相同的值。</span><br><span class="line">&lt;map&gt; 类型用于注入一组键值对，键和值都可以为任意类型。</span><br><span class="line">&lt;props&gt;类型用于注入一组键值对，键和值都只能为String类型。</span><br></pre></td></tr></table></figure>


<p>31.什么是bean装配?</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</span><br></pre></td></tr></table></figure>

<p>32.什么是bean的自动装配？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring 容器能够自动装配相互合作的bean，这意味着容器不需要&lt;constructor-arg&gt;和&lt;property&gt;配置，能通过Bean工厂自动处理bean之间的协作。</span><br></pre></td></tr></table></figure>

<p>33.解释不同方式的自动装配 。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入。</span><br><span class="line"></span><br><span class="line">no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。</span><br><span class="line">byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</span><br><span class="line">byType:：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</span><br><span class="line">constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</span><br><span class="line">autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</span><br></pre></td></tr></table></figure>


<p>34.自动装配有哪些局限性 ?</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">自动装配的局限性是：</span><br><span class="line">重写： 你仍需用 &lt;constructor-arg&gt;和 &lt;property&gt; 配置来定义依赖，意味着总要重写自动装配。</span><br><span class="line">基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</span><br><span class="line">模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</span><br></pre></td></tr></table></figure>

<p>35.你可以在Spring中注入一个null 和一个空字符串吗？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以。 &lt;null/&gt;用于处理null值。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Spring注解</p>
<p>36.什么是基于Java的Spring注解配置? 给一些注解的例子.</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</span><br><span class="line">以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</span><br></pre></td></tr></table></figure>

<p>37.什么是基于注解的容器配置?</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。</span><br><span class="line">开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml表述bean的装配关系。</span><br></pre></td></tr></table></figure>

<p>38.怎样开启注解装配？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 &lt;context:annotation-config/&gt;元素。</span><br></pre></td></tr></table></figure>

<p>39.@Required  注解</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。</span><br></pre></td></tr></table></figure>

<p>40.@Autowired 注解</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</span><br></pre></td></tr></table></figure>

<p>41.@Qualifier 注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的bean。</span><br></pre></td></tr></table></figure>

<p>Spring数据访问<br>42.在Spring框架中如何更有效地使用JDBC? </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">使用SpringJDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，</span><br><span class="line">JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫 JdbcTemplate  </span><br><span class="line"></span><br><span class="line">配置一个数据源</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;initialPoolSize&quot; value=&quot;$&#123;jdbc.initPoolSize&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;maxPoolSize&quot; value=&quot;$&#123;jdbc.maxPoolSize&#125;&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">配置一个jdbcTemplate就可以了</span><br><span class="line">    &lt;!--配置spring 的jdbctemplate --&gt;</span><br><span class="line">    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>43.JdbcTemplate</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，</span><br><span class="line">执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>44.Spring对DAO的支持</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring对数据访问对象（DAO）的支持旨在简化它和数据访问技术如JDBC，Hibernate or JDO 结合使用。这使我们可以方便切换持久层。编码时也不用担心会捕获每种技术特有的异常。</span><br></pre></td></tr></table></figure>


<p>45.使用Spring通过什么方式访问Hibernate? </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">在Spring中有两种方式访问Hibernate：</span><br><span class="line">控制反转  Hibernate Template和 Callback。</span><br><span class="line">继承 HibernateDAOSupport提供一个AOP 拦截器。</span><br><span class="line"></span><br><span class="line">配置数据源</span><br><span class="line">    &lt;!-- 配置数据源 --&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;initialPoolSize&quot; value=&quot;$&#123;jdbc.initPoolSize&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;maxPoolSize&quot; value=&quot;$&#123;jdbc.maxPoolSize&#125;&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">配置hibernate的sessionFactory</span><br><span class="line">    &lt;!--配置hibernate的sessionfactory --&gt;</span><br><span class="line">    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--这个配置文件是可以不要的。使用hibernateProperties 来配置属性 --&gt;</span><br><span class="line">        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot;/&gt;</span><br><span class="line">        &lt;!-- 建议保留hibernate.cfg.xml 配置文件--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- --&gt;</span><br><span class="line">        &lt;property name=&quot;hibernateProperties&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/prop&gt;</span><br><span class="line">                &lt;!--&lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLInnoDBDialect&lt;/property&gt;--&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!--是否打印sql语句--&gt;</span><br><span class="line">                &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!--是否对sql语句格式化--&gt;</span><br><span class="line">                &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!--指定自动生成数据库表的策略，有4个值--&gt;</span><br><span class="line">                &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=&quot;mappingLocations&quot; value=&quot;classpath:com/mamh/spring/demo/beans/*.hbm.xml&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">需要事务，在配置个事务管理器</span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>


<p>46.Spring支持的ORM</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Spring支持以下ORM：</span><br><span class="line">Hibernate</span><br><span class="line">iBatis</span><br><span class="line">JPA (Java Persistence API)</span><br><span class="line">TopLink</span><br><span class="line">JDO (Java Data Objects)</span><br><span class="line">OJB</span><br></pre></td></tr></table></figure>

<p>47.如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</span><br><span class="line"></span><br><span class="line">配置the Hibernate SessionFactory。</span><br><span class="line"></span><br><span class="line">继承 HibernateDaoSupport 实现一个DAO。</span><br><span class="line"></span><br><span class="line">在AOP支持的事务中装配。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>48.Spring支持的事务管理类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Spring支持两种类型的事务管理：</span><br><span class="line"></span><br><span class="line">编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</span><br><span class="line"></span><br><span class="line">声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>49.Spring框架的事务管理有哪些优点？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">它为不同的事务API  如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</span><br><span class="line">它为编程式事务管理提供了一套简单的API而不是一些复杂的事务API如</span><br><span class="line">它支持声明式事务管理。</span><br><span class="line">它和Spring各种数据访问抽象层很好得集成。</span><br></pre></td></tr></table></figure>

<p>50.你更倾向用那种事务管理类型？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。</span><br><span class="line">声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。</span><br></pre></td></tr></table></figure>

<p>Spring面向切面编程（AOP）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">什么是AOP</span><br><span class="line">AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</span><br><span class="line"></span><br><span class="line">AOP使用场景</span><br><span class="line">AOP用来封装横切关注点，具体可以在下面的场景中使用:</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Authentication 权限</span><br><span class="line"></span><br><span class="line">Caching 缓存</span><br><span class="line"></span><br><span class="line">Context passing 内容传递</span><br><span class="line"></span><br><span class="line">Error handling 错误处理</span><br><span class="line"></span><br><span class="line">Lazy loading 懒加载</span><br><span class="line"></span><br><span class="line">Debugging 调试</span><br><span class="line"></span><br><span class="line">logging, tracing, profiling and monitoring　记录跟踪　优化　校准</span><br><span class="line"></span><br><span class="line">Performance optimization　性能优化</span><br><span class="line"></span><br><span class="line">Persistence 持久化</span><br><span class="line"></span><br><span class="line">Resource pooling 资源池</span><br><span class="line"></span><br><span class="line">Synchronization 同步</span><br><span class="line"></span><br><span class="line">Transactions 事务</span><br></pre></td></tr></table></figure>

<p>51.解释AOP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">面向切面的编程，或AOP， 是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。</span><br><span class="line"></span><br><span class="line">AOP相关概念</span><br><span class="line">切面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的 Advisor或拦截器实现。</span><br><span class="line"></span><br><span class="line">连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。</span><br><span class="line"></span><br><span class="line">通知（Advice）: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。</span><br><span class="line">通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。</span><br><span class="line">Spring中定义了四个advice: BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice</span><br><span class="line"></span><br><span class="line">切入点（Pointcut）: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：</span><br><span class="line">例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， </span><br><span class="line">MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上</span><br><span class="line"></span><br><span class="line">引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。</span><br><span class="line">例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, </span><br><span class="line">可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口</span><br><span class="line"></span><br><span class="line">目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO</span><br><span class="line"></span><br><span class="line">AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</span><br><span class="line"></span><br><span class="line">织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>52.Aspect 切面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。</span><br><span class="line">比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。</span><br></pre></td></tr></table></figure>

<p>52.在Spring AOP 中，关注点和横切关注的区别是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</span><br><span class="line">横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</span><br></pre></td></tr></table></figure>

<p>54.连接点 Joinpoint</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP的位置。</span><br></pre></td></tr></table></figure>

<p>55.通知</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。</span><br><span class="line"></span><br><span class="line">Spring切面可以应用五种类型的通知：</span><br><span class="line"></span><br><span class="line">before：前置通知，在一个方法执行前被调用。</span><br><span class="line">after: 在方法执行之后调用的通知，无论方法执行是否成功。</span><br><span class="line">after-returning: 仅当方法成功完成后执行的通知。</span><br><span class="line">after-throwing: 在方法抛出异常退出时执行的通知。</span><br><span class="line">around: 在方法执行之前和之后调用的通知。</span><br></pre></td></tr></table></figure>

<p>56.切点 Pointcut</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</span><br></pre></td></tr></table></figure>

<p>57.什么是引入? </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引入允许我们在已存在的类中增加新的方法和属性。</span><br></pre></td></tr></table></figure>

<p>58.什么是目标对象?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知（advised）对象。</span><br></pre></td></tr></table></figure>


<p>59.什么是代理?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。</span><br></pre></td></tr></table></figure>

<p>60.有几种不同类型的自动代理？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BeanNameAutoProxyCreator</span><br><span class="line"></span><br><span class="line">DefaultAdvisorAutoProxyCreator</span><br><span class="line"></span><br><span class="line">Metadata autoproxying</span><br></pre></td></tr></table></figure>


<p>61.什么是织入。什么是织入应用的不同点？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">织入是将切面和到其他应用类型或对象连接或创建一个被通知对象的过程。</span><br><span class="line"></span><br><span class="line">织入可以在编译时，加载时，或运行时完成。</span><br></pre></td></tr></table></figure>


<p>62.解释基于XML Schema方式的切面实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这种情况下，切面由常规类以及基于XML的配置实现。</span><br></pre></td></tr></table></figure>

<p>63.解释基于注解的切面实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</span><br></pre></td></tr></table></figure>

<p>Spring 的MVC<br>64.什么是Spring的MVC框架？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring 配备构建Web 应用的全功能MVC框架。Spring可以很便捷地和其他MVC框架集成，</span><br><span class="line">如Struts，Spring 的MVC框架用控制反转把业务对象和控制逻辑清晰地隔离。</span><br><span class="line">它也允许以声明的方式把请求参数和业务对象绑定。</span><br></pre></td></tr></table></figure>

<p>65.DispatcherServlet</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring的MVC框架是围绕 DispatcherServlet 来设计的，它用来处理所有的HTTP请求和响应。</span><br></pre></td></tr></table></figure>

<p>66.WebApplicationContext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebApplicationContext 继承了ApplicationContext  并增加了一些WEB应用必备的特有功能，</span><br><span class="line">它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。</span><br></pre></td></tr></table></figure>

<p>67.什么是Spring MVC框架的控制器？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。</span><br><span class="line">控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。</span><br><span class="line">Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</span><br></pre></td></tr></table></figure>

<p>68.@Controller 注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该注解表明该类扮演控制器的角色，Spring不需要你继承任何其他控制器基类或引用Servlet API。</span><br></pre></td></tr></table></figure>

<p>69.@RequestMapping 注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该注解是用来映射一个URL到一个类或一个特定的方处理法上。 </span><br></pre></td></tr></table></figure>


<h1 id="Spring-概念"><a href="#Spring-概念" class="headerlink" title="Spring  概念"></a>Spring  概念</h1><p>1.spring是开源的轻量级的框架</p>
<p>2.spring核心主要两部分  </p>
<ul>
<li><p>aop：面向切面编程，扩展功能不是修改源代码实现。  </p>
</li>
<li><p>ioc：控制反转。比如一个类，在类里面有个方法（不是静态方法），调用类里面的方法步骤是：创建类的对象，使用对象来调用这个方法，这里创建类对象需要使用new的方式来创建。<br>把对象的创建交给spring，采用配置文件的方式来创建对象，这个就是控制反转。</p>
</li>
</ul>
<p>3.spring是一站式框架</p>
<ul>
<li>spring在java EE三层结构中，每一层都提供不同的解决技术</li>
<li>web层： spring MVC</li>
<li>service层： spring IOC</li>
<li>dao层： spring jdbcTemplate</li>
</ul>
<p>4.spring版本</p>
<ul>
<li>hibernate用的5.x版本</li>
<li>spring用的4.x版本</li>
</ul>
<h1 id="Spring的IOC操作"><a href="#Spring的IOC操作" class="headerlink" title="Spring的IOC操作"></a>Spring的IOC操作</h1><p>1.把对象的创建交给spring进行管理</p>
<p>2.ioc操作两种方式</p>
<ul>
<li>配置文件的方式</li>
<li>注解的方式</li>
</ul>
<p>3.IOC底层原理</p>
<p>ioc底层原理使用的技术</p>
<ul>
<li>xml配置文件</li>
<li>dom4j解析xml</li>
<li>工厂设计模式</li>
<li>反射</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://magesfc.github.io">mage</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://magesfc.github.io/mage/35daa433f1d2df61d4d92c19d510e19a6bafcf4f/">https://magesfc.github.io/mage/35daa433f1d2df61d4d92c19d510e19a6bafcf4f/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://magesfc.github.io" target="_blank">马哥私房菜</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/spring/">spring</a></div><div class="post_share"><div class="social-share" data-image="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/null" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/mage/d11dfff7d4cd5bb3c69c3fce552b1409c932fe72/"><img class="prev-cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringMVC学习总结</div></div></a></div><div class="next-post pull-right"><a href="/mage/abb5b3c7b70b496b314410760585d1678b857995/"><img class="next-cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">jenkins学习之Jenkins流水线语法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mage</div><div class="author-info__description"> 这里是 马哥 的个人博客 </div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">167</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">185</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mamh2021"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mamh2021" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">Spring  概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E7%9A%84IOC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">Spring的IOC操作</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/mage/38b16f805c0e0bfdce028d95fdd10a0b160e9167/" title="Linux学习之文件系统btrfs文件系统"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux学习之文件系统btrfs文件系统"/></a><div class="content"><a class="title" href="/mage/38b16f805c0e0bfdce028d95fdd10a0b160e9167/" title="Linux学习之文件系统btrfs文件系统">Linux学习之文件系统btrfs文件系统</a><time datetime="2022-12-05T14:37:10.000Z" title="更新于 2022-12-05 22:37:10">2022-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/c480dbde40d58e354795a1a408fdb8bad06fe7cc/" title="Ansible自动化运维工具之role介绍"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ansible自动化运维工具之role介绍"/></a><div class="content"><a class="title" href="/mage/c480dbde40d58e354795a1a408fdb8bad06fe7cc/" title="Ansible自动化运维工具之role介绍">Ansible自动化运维工具之role介绍</a><time datetime="2022-12-01T12:18:31.000Z" title="更新于 2022-12-01 20:18:31">2022-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/6118b9bf91824574204e116d5b138ffbaab72268/" title="Golang学习之struct转json"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang学习之struct转json"/></a><div class="content"><a class="title" href="/mage/6118b9bf91824574204e116d5b138ffbaab72268/" title="Golang学习之struct转json">Golang学习之struct转json</a><time datetime="2022-11-14T06:06:32.000Z" title="更新于 2022-11-14 14:06:32">2022-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/9e24b8712fd7596796aa8992d2b6496d0660585a/" title="jenkins学习之记master的一次报错"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jenkins学习之记master的一次报错"/></a><div class="content"><a class="title" href="/mage/9e24b8712fd7596796aa8992d2b6496d0660585a/" title="jenkins学习之记master的一次报错">jenkins学习之记master的一次报错</a><time datetime="2022-11-11T05:29:56.000Z" title="更新于 2022-11-11 13:29:56">2022-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/3b62171753fddbbf78c36e3f6d7c9ba008365560/" title="Golang学习之mtail"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang学习之mtail"/></a><div class="content"><a class="title" href="/mage/3b62171753fddbbf78c36e3f6d7c9ba008365560/" title="Golang学习之mtail">Golang学习之mtail</a><time datetime="2022-11-11T02:54:18.000Z" title="更新于 2022-11-11 10:54:18">2022-11-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By mage</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>