<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Golang学习之mtail | 马哥私房菜</title><meta name="author" content="mage"><meta name="copyright" content="mage"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="mtail  学习mtail 介绍extract internal monitoring data from application logs for collection in a timeseries database mtail :从应用程序日志中提取指标以导出到时间序列数据库  它是一个google开发的日志提取工具，用途就是:  实时读取应用程序的日志、 再通过自己编写的脚本进行分析、">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang学习之mtail">
<meta property="og:url" content="https://magesfc.github.io/mage/3b62171753fddbbf78c36e3f6d7c9ba008365560/">
<meta property="og:site_name" content="马哥私房菜">
<meta property="og:description" content="mtail  学习mtail 介绍extract internal monitoring data from application logs for collection in a timeseries database mtail :从应用程序日志中提取指标以导出到时间序列数据库  它是一个google开发的日志提取工具，用途就是:  实时读取应用程序的日志、 再通过自己编写的脚本进行分析、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg">
<meta property="article:published_time" content="2022-11-08T07:53:13.000Z">
<meta property="article:modified_time" content="2022-11-11T02:54:18.000Z">
<meta property="article:author" content="mage">
<meta property="article:tag" content="golang">
<meta property="article:tag" content="mtail">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg"><link rel="shortcut icon" href="http://www.blackshark.com/favicon.ico"><link rel="canonical" href="https://magesfc.github.io/mage/3b62171753fddbbf78c36e3f6d7c9ba008365560/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: mage","link":"链接: ","source":"来源: 马哥私房菜","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Golang学习之mtail',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-11 10:54:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">.card-announcement .social-button{margin:.6rem 0 0 0;text-align:center}.card-announcement .social-button a{display:block;background-color:var(--btn-bg);color:var(--btn-color);text-align:center;line-height:2.4;margin:4px 0}.card-announcement .social-button a:hover{background-color:var(--btn-hover-color)}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">187</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 精选文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> 🚀 快速开始</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/dc584b87/"><span> 📑 主题页面</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4aa8abbe/"><span> 🛠 主题配置-1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/ceeb73f/"><span> 🛠 主题配置-2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/98d20436/"><span> ❓ 主题问答</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4073eda/"><span> ⚡️ 进阶教程</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/198a4240/"><span> ✨ 更新日志</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://butterfly.js.org/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> 其他示例</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">马哥私房菜</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 精选文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> 🚀 快速开始</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/dc584b87/"><span> 📑 主题页面</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4aa8abbe/"><span> 🛠 主题配置-1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/ceeb73f/"><span> 🛠 主题配置-2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/98d20436/"><span> ❓ 主题问答</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4073eda/"><span> ⚡️ 进阶教程</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/198a4240/"><span> ✨ 更新日志</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://butterfly.js.org/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> 其他示例</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Golang学习之mtail</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-08T07:53:13.000Z" title="发表于 2022-11-08 15:53:13">2022-11-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-11T02:54:18.000Z" title="更新于 2022-11-11 10:54:18">2022-11-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/golang/">golang</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Golang学习之mtail"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="mtail-学习"><a href="#mtail-学习" class="headerlink" title="mtail  学习"></a>mtail  学习</h1><h1 id="mtail-介绍"><a href="#mtail-介绍" class="headerlink" title="mtail 介绍"></a>mtail 介绍</h1><p>extract internal monitoring data from application logs for collection in a timeseries database</p>
<pre><code>mtail :从应用程序日志中提取指标以导出到时间序列数据库
</code></pre>
<p>它是一个google开发的日志提取工具，用途就是:</p>
<ol>
<li>实时读取应用程序的日志、</li>
<li>再通过自己编写的脚本进行分析、</li>
<li>最终生成时间序列指标</li>
</ol>
<p>mtail使用流式读取日志，通过正则表达式匹配的方式从日志中提取metrics指标，</p>
<p>这种方式可以利用目标机器的算力，不过如果量太大，可能会影响目标机器上的业务程序</p>
<h1 id="运行-mtail"><a href="#运行-mtail" class="headerlink" title="运行 mtail"></a>运行 mtail</h1><pre><code>-progs string
    Name of the directory containing mtail programs

通过 --progs 参数指定一个目录，这个目录里放置一堆的*.mtail文件，

-logs value
    List of log files to monitor, separated by commas.  This flag may be specified multiple times.

每个mtail文件就是描述的正则提取规则，通过 --logs 参数来指定要监控的日志目录，
可以写通配符，--logs 可以写多次

-one_shot
    Compile the programs, then read the contents of the provided logs from start until EOF, print the values of the metrics store in the given format and exit. This is a debugging flag only, not for production use.
-one_shot_format string
    Format to use with -one_shot. This is a debugging flag only, not for production use. Supported formats: json, prometheus. (default &quot;json&quot;)

-one_shot 只显示打印出来一次指标数据，测试的时候非常有用。-one_shot_format 用来指定打印出来的数据的格式，默认是json 格式。 可以指定为prometheus格式的。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ /tmp/___mtail -progs ./conf/input.mtail -logs /var/log/kern.log -one_shot -one_shot_format prometheus  -logtostderr</span><br><span class="line"></span><br><span class="line">I1108 11:01:06.610898   20788 main.go:119] mtail version invalid:-use-make-to-build git revision invalid:-use-make-to-build go version go1.18.6 go arch amd64 go os linux</span><br><span class="line">I1108 11:01:06.610923   20788 main.go:120] Commandline: [&quot;/tmp/___mtail&quot; &quot;-progs&quot; &quot;/home/mamh/work/github/flashcatcloud-categraf/conf/input.mtail&quot; &quot;-logs&quot; &quot;/var/log/kern.log.1&quot; &quot;-one_shot&quot; &quot;-one_shot_format&quot; &quot;prometheus&quot; &quot;-logtostderr&quot;]</span><br><span class="line">I1108 11:01:06.611064   20788 store.go:189] Starting metric store expiry loop every 1h0m0s</span><br><span class="line">I1108 11:01:06.611209   20788 runtime.go:84] unmarking mtail.toml</span><br><span class="line">I1108 11:01:06.611229   20788 logstream.go:61] Parsed url as /var/log/kern.log.1</span><br><span class="line">I1108 11:01:06.611295   20788 filestream.go:278] signalling stop at next EOF</span><br><span class="line">I1108 11:01:06.611312   20788 tail.go:287] Tailing /var/log/kern.log.1</span><br><span class="line">I1108 11:01:06.611388   20788 tail.go:343] No polling loop in oneshot mode.</span><br><span class="line">I1108 11:01:06.611388   20788 tail.go:315] No gc loop in oneshot mode.</span><br><span class="line">I1108 11:01:06.611414   20788 mtail.go:132] Listening on [::]:3903</span><br><span class="line">I1108 11:01:06.621508   20788 runtime.go:288] END OF LINE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>去掉 -one_shot 执行 就会阻塞到那里了，然后就可以浏览器 访问 3903 端口 这个 地址啦。</p>
<h1 id="mtail-命令-源码分析"><a href="#mtail-命令-源码分析" class="headerlink" title="mtail 命令 源码分析"></a>mtail 命令 源码分析</h1><p>前提背景： </p>
<pre><code>0. 为什么要看这个mtail源码呢？ 最开始是 categraf 监控里面加入了这个 mtail插件，然后
我试着执行了一下 但是没有执行出来想要的结果，也就是 用 mtail 文件 加上一个 日志文件 去执行没有出来
想要的结果。 但是呢 我直接同样的文件 用 mtail 命令 就能得出想要的结果了。 所以想分析分析 mtail 里面
的源码都是一步一步怎么执行的。
</code></pre>
<p>通过源码分析 我们想探讨的几个问题：</p>
<pre><code>1. 在哪里 读取 日志文件的？？？  这个答案已经出来了。 参考 下面  Runtime  New 方法 相关的 分析。
2. 在哪里 使用 mtail 文件的 ？？？ 这个知道 是在  Runtime  New 方法 里面去加载了， 同时 这个里面也
                                 加载 日志文件内容。那么 这2个结合去处理 估计也是在这个 Runtime 里面了
</code></pre>
<h2 id="mtail-New-初始化"><a href="#mtail-New-初始化" class="headerlink" title="mtail.New 初始化"></a>mtail.New 初始化</h2><p>首先 是 根据 命令行的一些参数 去 初始 mtail 了。</p>
<p>在 main.go 中 有 mtail.New() 方法调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtail.New(ctx, store, opts...)</span><br></pre></td></tr></table></figure>

<p>需要用到 3个 参数</p>
<pre><code>ctx 是 context.WithCancel(context.Background()) 
store 是 metrics.NewStore() 生成出来的
opts 就是对应命令行上的 选项了，把命令行选项 转换了一下，mtail.Option切片了。
</code></pre>
<p>主要就是 初始化 type Server struct  这个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m := &amp;Server&#123;</span><br><span class="line">    ctx:   ctx,</span><br><span class="line">    store: store,</span><br><span class="line"></span><br><span class="line">    lines: make(chan *logline.LogLine),</span><br><span class="line"></span><br><span class="line">    reg: prometheus.NewRegistry(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 New() 方法后续的 还调用了 其他的 一些个 初始化 方法</p>
<pre><code>if err := m.initExporter(); err != nil &#123;

if err := m.initRuntime(); err != nil &#123;

if err := m.initTailer(); err != nil &#123;

if err := m.initHTTPServer(); err != nil &#123;
</code></pre>
<p>以上 四个 init 方法 里面 又各自 初始化了 其他类型的 结构体了。 主要有下面几个。</p>
<pre><code>type Exporter struct

type Runtime struct // 这里面有 compiler.New() 初始化

type Tailer struct

type Server struct   net http 包下面的， 直接提供 http 服务的。
</code></pre>
<p>当然 这些 结构体 在 调用 New() 方法的里面 也会有 另外的  结构体的 初始化。</p>
<h2 id="Runtime-New-方法。"><a href="#Runtime-New-方法。" class="headerlink" title="Runtime  New 方法。"></a>Runtime  New 方法。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// initRuntime constructs a new runtime and performs the initial load of program files in the program directory.</span><br><span class="line">func (m *Server) initRuntime() (err error) &#123;</span><br><span class="line">	m.r, err = runtime.New(m.lines, &amp;m.wg, m.programPath, m.store, m.rOpts...)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">func New(lines &lt;-chan *logline.LogLine, wg *sync.WaitGroup, programPath string, store *metrics.Store, options ...Option) (*Runtime, error) &#123;</span><br><span class="line">	if store == nil &#123;</span><br><span class="line">		return nil, errors.New(&quot;loader needs a store&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r := &amp;Runtime&#123;</span><br><span class="line">		ms:            store,</span><br><span class="line">		programPath:   programPath,</span><br><span class="line">		handles:       make(map[string]*vmHandle),</span><br><span class="line">		programErrors: make(map[string]error),</span><br><span class="line">		signalQuit:    make(chan struct&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	initDone := make(chan struct&#123;&#125;)</span><br><span class="line">	defer close(initDone)</span><br><span class="line"></span><br><span class="line">	var err error</span><br><span class="line">	if err = r.SetOption(options...); err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if r.c, err = compiler.New(r.cOpts...); err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Defer shutdown handling to avoid a race on r.wg.</span><br><span class="line">	wg.Add(1)</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		go func() &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			&lt;-initDone</span><br><span class="line">			r.wg.Wait()        // 下面启动了2个 goroutine， 这里等待 就是 r.wg 的？？？？</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	// This goroutine is the main consumer/producer loop.</span><br><span class="line">	r.wg.Add(1)</span><br><span class="line">    go func() &#123;</span><br><span class="line">		defer r.wg.Done() // signal to owner we&#x27;re done</span><br><span class="line">		&lt;-initDone</span><br><span class="line">		for line := range lines &#123;</span><br><span class="line">			LineCount.Add(1)</span><br><span class="line">			r.handleMu.RLock()</span><br><span class="line">			for prog := range r.handles &#123;</span><br><span class="line">				r.handles[prog].lines &lt;- line</span><br><span class="line">			&#125;</span><br><span class="line">			r.handleMu.RUnlock()</span><br><span class="line">		&#125;</span><br><span class="line">		glog.Info(&quot;END OF LINE&quot;)</span><br><span class="line">		close(r.signalQuit)</span><br><span class="line">		r.handleMu.Lock()</span><br><span class="line">		for prog := range r.handles &#123;</span><br><span class="line">			close(r.handles[prog].lines)</span><br><span class="line">			delete(r.handles, prog)</span><br><span class="line">		&#125;</span><br><span class="line">		r.handleMu.Unlock()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	if r.programPath == &quot;&quot; &#123;</span><br><span class="line">		glog.Info(&quot;No program path specified, no programs will be loaded.&quot;)</span><br><span class="line">		return r, nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Create one goroutine that handles reload signals.</span><br><span class="line">	r.wg.Add(1)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer r.wg.Done()</span><br><span class="line">		&lt;-initDone</span><br><span class="line">		if r.programPath == &quot;&quot; &#123;</span><br><span class="line">			glog.Info(&quot;no program reload on SIGHUP without programPath&quot;)</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		n := make(chan os.Signal, 1)</span><br><span class="line">		signal.Notify(n, syscall.SIGHUP)</span><br><span class="line">		defer signal.Stop(n)</span><br><span class="line">		for &#123;</span><br><span class="line">			select &#123;</span><br><span class="line">			case &lt;-r.signalQuit:</span><br><span class="line">				return</span><br><span class="line">			case &lt;-n:</span><br><span class="line">				if err := r.LoadAllPrograms(); err != nil &#123;</span><br><span class="line">					glog.Info(err)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	// Guarantee all existing programmes get loaded before we leave.</span><br><span class="line">	if err := r.LoadAllPrograms(); err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return r, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个New 主要就是用来初始化 &amp;Runtime 这个的。</p>
<p>里面用到了 一个小技巧。</p>
<pre><code>initDone := make(chan struct&#123;&#125;)  新建一个 通道
defer close(initDone)  这个会在 New 方法结束时候 去关闭这个通道。
</code></pre>
<p>我们先来 研究 handles 怎么初始化的？，首选一开始 就新建了个空的 map，这个时候 map 里面 还没有 去<br>初始化 vmHandle 对象的。</p>
<p>在 New 方法里面 有 3个地方比较重要， 里面启动了 几个 routine。</p>
<h3 id="这第一个重要点"><a href="#这第一个重要点" class="headerlink" title="这第一个重要点"></a>这第一个重要点</h3><p>启动了一个 routine， 里面for 循环去遍历 这个 lines，这是一个 通道，就是 日志文件的每一行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// This goroutine is the main consumer/producer loop.</span><br><span class="line">r.wg.Add(1)</span><br><span class="line">go func() &#123;</span><br><span class="line">	defer r.wg.Done() // signal to owner we&#x27;re done</span><br><span class="line">	&lt;-initDone</span><br><span class="line">	for line := range lines &#123;  //  for  循环 一个 通道， 会阻塞到这里，一直到通道关闭。通道关闭 是在 tail.go 里面的 New() 方法的 最后有个 close(t.lines)</span><br><span class="line">		LineCount.Add(1)</span><br><span class="line">		r.handleMu.RLock()</span><br><span class="line">		for prog := range r.handles &#123;</span><br><span class="line">			r.handles[prog].lines &lt;- line</span><br><span class="line">		&#125;</span><br><span class="line">		r.handleMu.RUnlock()</span><br><span class="line">	&#125;</span><br><span class="line">	glog.Info(&quot;END OF LINE&quot;)</span><br><span class="line">	close(r.signalQuit)  //  用户 发送 停止 信号 就会 退出上面的 for line := range lines 循环，这里就会 关闭 signalQuit 通道，然后 就会 到 下面 select case &lt;-r.signalQuit: 这里 执行了。。。。。</span><br><span class="line">	r.handleMu.Lock()</span><br><span class="line">	for prog := range r.handles &#123;</span><br><span class="line">		close(r.handles[prog].lines)</span><br><span class="line">		delete(r.handles, prog)</span><br><span class="line">	&#125;</span><br><span class="line">	r.handleMu.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="这第-2-个-重要点-也是-启动了一个-routine，"><a href="#这第-2-个-重要点-也是-启动了一个-routine，" class="headerlink" title="这第 2 个 重要点  也是 启动了一个 routine，"></a>这第 2 个 重要点  也是 启动了一个 routine，</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Create one goroutine that handles reload signals.</span><br><span class="line">r.wg.Add(1)</span><br><span class="line">go func() &#123;</span><br><span class="line">	defer r.wg.Done()</span><br><span class="line">	&lt;-initDone</span><br><span class="line">	if r.programPath == &quot;&quot; &#123;</span><br><span class="line">		glog.Info(&quot;no program reload on SIGHUP without programPath&quot;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	n := make(chan os.Signal, 1)</span><br><span class="line">	signal.Notify(n, syscall.SIGHUP)   // 注册个 sighup 信号的出来，</span><br><span class="line">	defer signal.Stop(n)</span><br><span class="line">	for &#123;</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-r.signalQuit:  // 这个就是 退出的时候执行到这里</span><br><span class="line">			return</span><br><span class="line">		case &lt;-n:  // 这里 等待 接收 用户 发送 的 sighup 信号， 这个 感觉 发送这个型号 就会 重新 执行 LoadAllPrograms() 方法，感觉像是 重新 加载 配置文件的作用？？？？</span><br><span class="line">			if err := r.LoadAllPrograms(); err != nil &#123;</span><br><span class="line">				glog.Info(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h3 id="第三个重要点"><a href="#第三个重要点" class="headerlink" title="第三个重要点"></a>第三个重要点</h3><p>LoadAllPrograms 加载 .mtail 文件的吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Guarantee all existing programmes get loaded before we leave.</span><br><span class="line">if err := r.LoadAllPrograms(); err != nil &#123;</span><br><span class="line">	return nil, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从表明上 看 先 执行 第一个地方， 然后 第二个 地方，最后是 第三个这个地方。</p>
<p>如果真的是 这样 handles 怎么初始化的？ 这个 就会有问题，没有初始化 怎么 能 直接 这么使用呢？ r.handles[prog].lines &lt;- line</p>
<p>所以 这段代码 并不是 表明看到的那个顺序  去执行的。</p>
<p>这2个 goroutine 里面 都有一个 等待 接收 initDone 通过的 动作。 <code>&lt;-initDone</code> 都是一上来就先执行这句。<br>这个是个 只读的 通道，不能往里写入的，也的确没看到哪个地方往里写入。那么调用这个不就会一直阻塞的吗，确实会阻塞到这里，但是当 关闭通道时候<br>这个就会继续往下执行了。。。 这里面正式 用到了这个技巧 导致 上面 3个 点 执行顺序 不一样了。</p>
<h3 id="总结-Runtime-New"><a href="#总结-Runtime-New" class="headerlink" title="总结 Runtime  New"></a>总结 Runtime  New</h3><p>下面 总结一下 这个 执行顺序：</p>
<pre><code>1. 先  `initDone := make(chan struct&#123;&#125;)` 新建通道
2. 注册 并且 立即 执行 第1个 地方的 goroutine
3. 注册 并且 立即 执行 第2个 地方的 goroutine
4. 执行 第三个 地方的代码 LoadAllPrograms(), 这一步里面 会去 初始化 handles 里面的 对象。这个初始化好之后 就能 ` r.handles[prog].lines ` 这样来使用了
5. 此时 New() 方法 结束了。要执行 defer 注册的 方法了，其中 有一个 就是 关闭 close(initDone) 通道的。
6. 通道关闭之后， 第一个 goroutine  会继续 &lt;-initDone 之后代码的执行。
7. 同样的， 第2个 goroutine  也会继续 &lt;-initDone 之后代码的执行。
</code></pre>
<p>mtail 代码 里面 多处 用到 了这样的 技巧。</p>
<p>上面提到的 第一个 goroutine 是 用来接收 从log文件读取的每一行内容的。 从 lines 通道接收。</p>
<p>在哪里 往这个通道放数据呢？ </p>
<p>是在 <code>internal/tailer/logstream/filestream.go</code> 中的 <code>stream()</code> 方法，</p>
<p>这里面有个 for 循环 去不停的读文件。读到文件结尾就会 sleep了。后面文件有新写入会继续读取。</p>
<p>用到了 <code>waker.Wake()</code> 这个。是从这里初始化的 <code>logStreamPollWaker := waker.NewTimed(ctx, *pollInterval)</code></p>
<p>在 for 循环里面 有个 <code>func decodeAndSend</code> 方法， 在里面 有个 <code>func sendLine</code> 就是这个方法 往通道里面发送每一行数据的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func sendLine(ctx context.Context, pathname string, partial *bytes.Buffer, lines chan&lt;- *logline.LogLine) &#123;</span><br><span class="line">	glog.V(2).Infof(&quot;sendline&quot;)</span><br><span class="line">	logLines.Add(pathname, 1)</span><br><span class="line">	lines &lt;- logline.New(ctx, pathname, partial.String())</span><br><span class="line">	partial.Reset()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Runtime-中的-LoadAllPrograms-方法"><a href="#Runtime-中的-LoadAllPrograms-方法" class="headerlink" title="Runtime 中的 LoadAllPrograms 方法"></a>Runtime 中的 LoadAllPrograms 方法</h3><p>调用 顺序 <code>LoadAllPrograms</code> -&gt; <code>LoadProgram </code> -&gt;  <code>CompileAndRun</code>  -&gt; <code>Compile(name, &amp;buf)</code> -&gt; <code>VM 中的 Run()</code></p>
<ol>
<li><p>LoadAllPrograms 里面 循环 -prog 选项 后面的目录，遍历 这个 目录下面的 所有的 mtail 结尾的文件。</p>
<p> 这个里面 还会 对 一些 已经 删除掉的 mtail 文件 进行处理， 会关闭 其对应的 handle.lines 和 从 handles map 中删除。</p>
</li>
<li><p>如果  -prog 选项 跟着的是一个单独的文件 那就 只 遍历 这个一个文件了，</p>
</li>
<li><p>其实 就是 循环 每个 mtail 文件，对其调用 <code>LoadProgram</code> 方法了. 这个方法就接收一个 mtail文件路径作为参数。</p>
</li>
</ol>
<h3 id="Runtime-中的-LoadProgram-方法"><a href="#Runtime-中的-LoadProgram-方法" class="headerlink" title="Runtime 中的 LoadProgram 方法"></a>Runtime 中的 LoadProgram 方法</h3><ol>
<li>判断 是否 点 开头的文件，隐藏文件会忽略的。</li>
<li>判断是否 .mtail 后缀的文件，不是也会忽略的。</li>
<li>打开这个文件，打开失败会直接返回，也会加个错误标记 到 <code>ProgLoadErrors.Add(name, 1)</code>, 这个是用来 计数 加载 mtail 失败次数的。里面都有 锁保护的。</li>
<li>打开文件成功，然后 注册 defer 方法 去要关闭这个文件的。</li>
<li>调用 <code>CompileAndRun</code> 方法， 返回值 会存放到 <code>r.programErrors</code> 字典里面，字典key就是 mtail 文件名，<br> 当然 往这个字典里面 加数据 前后也有锁 保护的。</li>
<li>如果  <code> r.programErrors[name] </code>  不是nil ，并且 <code>r.errorsAbort</code> 设置了，就会返回 这个错误状态了。这是个 error 类型的。</li>
</ol>
<h3 id="Runtime-中的-CompileAndRun-方法"><a href="#Runtime-中的-CompileAndRun-方法" class="headerlink" title="Runtime 中的 CompileAndRun 方法"></a>Runtime 中的 CompileAndRun 方法</h3><p>这个方法 接收 2个参数 ，一个是 mtail 文件名， 一个就是  打开的 mtail 文件 的 <code>io.Reader</code></p>
<ol>
<li><p>计算 mtail 文件内容的 sha256 值， 利用了 TeeReader 来读取，减少内存消耗。</p>
</li>
<li><p>加锁保护，读取map中数据， <code>vh, ok := r.handles[name]</code>  的好 handles 中的 vh，这个是 vmHandle 类型的。</p>
<pre><code> 第一次读取，ok=false，肯定是没有值的，因为我们还没有 初始化呢，
 只是前边吧 handles 这个 map 给新建出来了，还没往里放东西呢。
 
 后续再次读取就能 得到值，如果的到了，就会 进行 比较了`  bytes.Equal(vh.contentHash, contentHash)`
 vh里面存放的 mtail 文件内容的 hash 值 和 前面那一步算出来的 是否一致，一致说明 mtail 文件没有变化呀，直接return了。
 有变化 才会往下执行，往下执行 肯定是 重新 New 出来一个 新的 vmHandle 复制给 字典里面 r.handles[name] 拉。
</code></pre>
</li>
<li><p>执行 <code>obj, errs := r.c.Compile(name, &amp;buf)</code> 把 mtail 文件名传入， mtail 文件 内容传入。返回 <code>*code.Object</code> 类 型,来自 <code>internal/runtime/code/object.go</code> 文件中</p>
</li>
<li><p>如果第三步 执行 有 err， 或者 返回 的 obj 是 nil 就会 记录在 ProgLoadErrors 里面，就会给这个 里面的计数 加一了。 这个在 (“Runtime 中的 LoadProgram 方法”) 第 6 步的 时候也有介绍。</p>
</li>
<li><p>重头出来了，vm的初始化，也就是 vmHandle 中的 vm的 初始化。 调用 vm.New() 方法</p>
</li>
<li><p>接着 重头： vmHandle 的初始化，<code>&amp;vmHandle&#123;contentHash: contentHash, vm: v, lines: lines&#125;</code></p>
</li>
<li><p>调用 <code>go v.Run(lines, &amp;r.wg)</code>， 还是放到一个 goroutine 里面执行的。在这个里面就会出来 lines 通道。就是处理每一行日志文件的内容了。</p>
</li>
</ol>
<h3 id="VM-中的-Run-方法"><a href="#VM-中的-Run-方法" class="headerlink" title="VM 中的 Run 方法"></a>VM 中的 Run 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func (v *VM) Run(lines &lt;-chan *logline.LogLine, wg *sync.WaitGroup) &#123;</span><br><span class="line">	defer wg.Done()</span><br><span class="line">	glog.V(1).Infof(&quot;started VM %q&quot;, v.name)</span><br><span class="line">	ctx := context.TODO()</span><br><span class="line">	for line := range lines &#123;</span><br><span class="line">		v.ProcessLogLine(ctx, line)</span><br><span class="line">	&#125;</span><br><span class="line">	glog.Infof(&quot;VM %q finished&quot;, v.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 run 方法 就是 循环 处理 来自 通道 lines 的每一行数据的，没有新的数据来 回等待那里。</p>
<h3 id="VM-中的-ProcessLogLine-方法"><a href="#VM-中的-ProcessLogLine-方法" class="headerlink" title="VM 中的 ProcessLogLine 方法"></a>VM 中的 ProcessLogLine 方法</h3><p>真正去 处理 每一行日志数据的。每一行 就是一个 字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func (v *VM) ProcessLogLine(ctx context.Context, line *logline.LogLine) &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		LineProcessingDurations.WithLabelValues(v.name).Observe(time.Since(start).Seconds())</span><br><span class="line">	&#125;()</span><br><span class="line">	t := new(thread)</span><br><span class="line">	t.matched = false</span><br><span class="line">	v.t = t</span><br><span class="line">	v.input = line</span><br><span class="line">	t.stack = make([]interface&#123;&#125;, 0)</span><br><span class="line">	t.matches = make(map[int][]string, len(v.re))</span><br><span class="line">	for &#123;</span><br><span class="line">		if t.pc &gt;= len(v.prog) &#123;</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		if v.trace != nil &#123;</span><br><span class="line">			v.trace = append(v.trace, t.pc)</span><br><span class="line">		&#125;</span><br><span class="line">		i := v.prog[t.pc]</span><br><span class="line">		t.pc++</span><br><span class="line"></span><br><span class="line">		v.execute(t, i)</span><br><span class="line"></span><br><span class="line">		if v.terminate &#123;</span><br><span class="line">			// Terminate only stops this invocation on this line of input; reset the terminate flag.</span><br><span class="line">			v.terminate = false</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法里面 就是 对 一行数据 进行 处理的。 主要的就是 <code>v.execute(t, i) </code> t 是一个 thread， i 是 Instr，这个应该是mtail文件编译后得到的。</p>
<h3 id="详细-分析一下-Compile-name-amp-buf-方法"><a href="#详细-分析一下-Compile-name-amp-buf-方法" class="headerlink" title="详细 分析一下 Compile(name, &amp;buf) 方法"></a>详细 分析一下 Compile(name, &amp;buf) 方法</h3><p>这个方法的 返回值 是 在 新建VM实例的时候用到的，需要传入的一个参数， vm.New() 时候用到的。</p>
<p>这个方法 就是 把 mtail 文件内容 解析转换成 对应的 code.Object 类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ast, err = parser.Parse(name, input)  通过 parse 解析， 得到 ast</span><br><span class="line"></span><br><span class="line">name 是 mtail 文件名称，不带路径的</span><br><span class="line">input 就是 mtail 文件整体内容。注释的行 也包含在里面的。</span><br><span class="line"></span><br><span class="line">ast 抽象 语法树</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj, err = codegen.CodeGen(name, ast) 通过 ast 转换为 obj</span><br></pre></td></tr></table></figure>

<p>这个解析 感觉 又 进入了到了 另外一个 复杂的领域了。。。 yacc， lexer 等等。</p>
<p>parser.Parse 方法，里面有调用 newParser() 然后就调用 mtailParse(p) 了。调用这个方法 就不能断点调试了。。。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func Parse(name string, input io.Reader) (ast.Node, error) &#123;</span><br><span class="line">	p := newParser(name, input)</span><br><span class="line">	r := mtailParse(p)</span><br><span class="line">	if r != 0 || p.errors != nil &#123;</span><br><span class="line">		return nil, p.errors</span><br><span class="line">	&#125;</span><br><span class="line">	return p.root, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">counter lines_total</span><br><span class="line">/$/ &#123;</span><br><span class="line">  lines_total++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的一个 mtail 文件 编译后 到的 Object.Program 里面 有7个 Instr。 这是一个切片。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 = &#123;github.com/google/mtail/internal/runtime/code.Instr&#125; </span><br><span class="line">1 = &#123;github.com/google/mtail/internal/runtime/code.Instr&#125; </span><br><span class="line">2 = &#123;github.com/google/mtail/internal/runtime/code.Instr&#125; </span><br><span class="line">3 = &#123;github.com/google/mtail/internal/runtime/code.Instr&#125; </span><br><span class="line">4 = &#123;github.com/google/mtail/internal/runtime/code.Instr&#125; </span><br><span class="line">5 = &#123;github.com/google/mtail/internal/runtime/code.Instr&#125; </span><br><span class="line">6 = &#123;github.com/google/mtail/internal/runtime/code.Instr&#125; </span><br></pre></td></tr></table></figure>
<p>同时 Object.Strings 是 nil</p>
<p>Object.Regexps 是 正则 <code>$</code></p>
<p>Object.Metrics 里面有 1 个</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://magesfc.github.io">mage</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://magesfc.github.io/mage/3b62171753fddbbf78c36e3f6d7c9ba008365560/">https://magesfc.github.io/mage/3b62171753fddbbf78c36e3f6d7c9ba008365560/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://magesfc.github.io" target="_blank">马哥私房菜</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a><a class="post-meta__tags" href="/tags/mtail/">mtail</a></div><div class="post_share"><div class="social-share" data-image="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/null" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/mage/f7b2ae126d593c93046cbf03febb201f10fef861/"><img class="prev-cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Golang学习之类型转换</div></div></a></div><div class="next-post pull-right"><a href="/mage/59738b29b03ec88e9f98548ab2d29fd5592d7c6d/"><img class="next-cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Golang学习之dlv断点调试</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/mage/6118b9bf91824574204e116d5b138ffbaab72268/" title="Golang学习之struct转json"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-14</div><div class="title">Golang学习之struct转json</div></div></a></div><div><a href="/mage/f7b2ae126d593c93046cbf03febb201f10fef861/" title="Golang学习之类型转换"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-08</div><div class="title">Golang学习之类型转换</div></div></a></div><div><a href="/mage/18ccd178a6f3d405a26d5528e6f41f3b38eb6aa9/" title="Golang学习笔记总结"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Golang学习笔记总结</div></div></a></div><div><a href="/mage/59738b29b03ec88e9f98548ab2d29fd5592d7c6d/" title="Golang学习之dlv断点调试"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-08</div><div class="title">Golang学习之dlv断点调试</div></div></a></div><div><a href="/mage/c2d4f359f2ad8b1560a3323b9940d7aee2b7aabc/" title="Golang的58个坑"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-02</div><div class="title">Golang的58个坑</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mage</div><div class="author-info__description"> 这里是 马哥 的个人博客 </div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">187</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mamh2021"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mamh2021" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#mtail-%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">mtail  学习</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mtail-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">mtail 介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C-mtail"><span class="toc-number">3.</span> <span class="toc-text">运行 mtail</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mtail-%E5%91%BD%E4%BB%A4-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">mtail 命令 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mtail-New-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">mtail.New 初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Runtime-New-%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">4.2.</span> <span class="toc-text">Runtime  New 方法。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E7%82%B9"><span class="toc-number">4.2.1.</span> <span class="toc-text">这第一个重要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E7%AC%AC-2-%E4%B8%AA-%E9%87%8D%E8%A6%81%E7%82%B9-%E4%B9%9F%E6%98%AF-%E5%90%AF%E5%8A%A8%E4%BA%86%E4%B8%80%E4%B8%AA-routine%EF%BC%8C"><span class="toc-number">4.2.2.</span> <span class="toc-text">这第 2 个 重要点  也是 启动了一个 routine，</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%82%B9"><span class="toc-number">4.2.3.</span> <span class="toc-text">第三个重要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-Runtime-New"><span class="toc-number">4.2.4.</span> <span class="toc-text">总结 Runtime  New</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime-%E4%B8%AD%E7%9A%84-LoadAllPrograms-%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.5.</span> <span class="toc-text">Runtime 中的 LoadAllPrograms 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime-%E4%B8%AD%E7%9A%84-LoadProgram-%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.6.</span> <span class="toc-text">Runtime 中的 LoadProgram 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime-%E4%B8%AD%E7%9A%84-CompileAndRun-%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.7.</span> <span class="toc-text">Runtime 中的 CompileAndRun 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VM-%E4%B8%AD%E7%9A%84-Run-%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.8.</span> <span class="toc-text">VM 中的 Run 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VM-%E4%B8%AD%E7%9A%84-ProcessLogLine-%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.9.</span> <span class="toc-text">VM 中的 ProcessLogLine 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86-%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8B-Compile-name-amp-buf-%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.10.</span> <span class="toc-text">详细 分析一下 Compile(name, &amp;buf) 方法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/mage/298144bf31bdad623369d39b38ebddb64dde1abd/" title="jenkins学习之Jenkins开发调试于jenkins插件开发调试"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jenkins学习之Jenkins开发调试于jenkins插件开发调试"/></a><div class="content"><a class="title" href="/mage/298144bf31bdad623369d39b38ebddb64dde1abd/" title="jenkins学习之Jenkins开发调试于jenkins插件开发调试">jenkins学习之Jenkins开发调试于jenkins插件开发调试</a><time datetime="2023-03-16T05:47:11.000Z" title="更新于 2023-03-16 13:47:11">2023-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/99fd30947b3d8a14f909e4875dc196943b037448/" title="jenkins插件学习之extended-choice-parameter-plugin"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jenkins插件学习之extended-choice-parameter-plugin"/></a><div class="content"><a class="title" href="/mage/99fd30947b3d8a14f909e4875dc196943b037448/" title="jenkins插件学习之extended-choice-parameter-plugin">jenkins插件学习之extended-choice-parameter-plugin</a><time datetime="2023-03-11T13:56:49.000Z" title="更新于 2023-03-11 21:56:49">2023-03-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/b86949e1fd66e39ee6b396cf422c6660cdcb5ebe/" title="Android下的配置管理之道之gerrit配置js插件"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android下的配置管理之道之gerrit配置js插件"/></a><div class="content"><a class="title" href="/mage/b86949e1fd66e39ee6b396cf422c6660cdcb5ebe/" title="Android下的配置管理之道之gerrit配置js插件">Android下的配置管理之道之gerrit配置js插件</a><time datetime="2023-01-11T09:11:46.000Z" title="更新于 2023-01-11 17:11:46">2023-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/8facee0ca4bc4450ba21eea69a97fe1891c415dc/" title="Linux学习之bash学习之bash_strict_mode"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux学习之bash学习之bash_strict_mode"/></a><div class="content"><a class="title" href="/mage/8facee0ca4bc4450ba21eea69a97fe1891c415dc/" title="Linux学习之bash学习之bash_strict_mode">Linux学习之bash学习之bash_strict_mode</a><time datetime="2022-12-13T11:18:28.000Z" title="更新于 2022-12-13 19:18:28">2022-12-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/38b16f805c0e0bfdce028d95fdd10a0b160e9167/" title="Linux学习之文件系统btrfs文件系统"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux学习之文件系统btrfs文件系统"/></a><div class="content"><a class="title" href="/mage/38b16f805c0e0bfdce028d95fdd10a0b160e9167/" title="Linux学习之文件系统btrfs文件系统">Linux学习之文件系统btrfs文件系统</a><time datetime="2022-12-05T14:37:10.000Z" title="更新于 2022-12-05 22:37:10">2022-12-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By mage</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>