<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux学习之sed学习之cookbook技巧 | 马哥私房菜</title><meta name="author" content="mage"><meta name="copyright" content="mage"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="sed 一行命令 解释 Sed One-Liners Explained,  https:&#x2F;&#x2F;catonmat.net&#x2F;sed-one-liners-explained-part-one 在开始解释之前，我想分享一下改变我对 sed 的看法的关键思想。它是 sed 的四个内存空间——输入流、输出流、模式空间、保持缓冲区。input stream, output stream, pattern sp">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux学习之sed学习之cookbook技巧">
<meta property="og:url" content="https://magesfc.github.io/mage/6a323979d022165779db1cbb3367540e235cec9e/">
<meta property="og:site_name" content="马哥私房菜">
<meta property="og:description" content="sed 一行命令 解释 Sed One-Liners Explained,  https:&#x2F;&#x2F;catonmat.net&#x2F;sed-one-liners-explained-part-one 在开始解释之前，我想分享一下改变我对 sed 的看法的关键思想。它是 sed 的四个内存空间——输入流、输出流、模式空间、保持缓冲区。input stream, output stream, pattern sp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg">
<meta property="article:published_time" content="2022-02-23T09:47:21.000Z">
<meta property="article:modified_time" content="2022-05-10T11:00:59.000Z">
<meta property="article:author" content="mage">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="cookbook">
<meta property="article:tag" content="sed">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg"><link rel="shortcut icon" href="http://www.blackshark.com/favicon.ico"><link rel="canonical" href="https://magesfc.github.io/mage/6a323979d022165779db1cbb3367540e235cec9e/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: mage","link":"链接: ","source":"来源: 马哥私房菜","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux学习之sed学习之cookbook技巧',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-10 19:00:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">.card-announcement .social-button{margin:.6rem 0 0 0;text-align:center}.card-announcement .social-button a{display:block;background-color:var(--btn-bg);color:var(--btn-color);text-align:center;line-height:2.4;margin:4px 0}.card-announcement .social-button a:hover{background-color:var(--btn-hover-color)}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">161</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">180</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 精选文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> 🚀 快速开始</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/dc584b87/"><span> 📑 主题页面</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4aa8abbe/"><span> 🛠 主题配置-1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/ceeb73f/"><span> 🛠 主题配置-2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/98d20436/"><span> ❓ 主题问答</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4073eda/"><span> ⚡️ 进阶教程</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/198a4240/"><span> ✨ 更新日志</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://butterfly.js.org/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> 其他示例</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">马哥私房菜</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 精选文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> 🚀 快速开始</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/dc584b87/"><span> 📑 主题页面</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4aa8abbe/"><span> 🛠 主题配置-1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/ceeb73f/"><span> 🛠 主题配置-2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/98d20436/"><span> ❓ 主题问答</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4073eda/"><span> ⚡️ 进阶教程</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/198a4240/"><span> ✨ 更新日志</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://butterfly.js.org/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> 其他示例</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux学习之sed学习之cookbook技巧</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-23T09:47:21.000Z" title="发表于 2022-02-23 17:47:21">2022-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-10T11:00:59.000Z" title="更新于 2022-05-10 19:00:59">2022-05-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/">linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux学习之sed学习之cookbook技巧"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>sed 一行命令 解释</p>
<p>Sed One-Liners Explained,  <a target="_blank" rel="noopener" href="https://catonmat.net/sed-one-liners-explained-part-one">https://catonmat.net/sed-one-liners-explained-part-one</a></p>
<p>在开始解释之前，我想分享一下改变我对 sed 的看法的关键思想。<br>它是 sed 的四个内存空间——输入流、输出流、模式空间、保持缓冲区。<br>input stream, output stream, pattern space, hold buffer</p>
<p>Sed 对输入流进行操作并产生一个输出流。输入流中的行被放入模式空间（可以修改它们），然后模式空间被发送到输出流。<br>保持缓冲区可用于临时存储。这四个空格完全改变了我对 sed 的看法。通过本文中的示例，您将了解所有有关它们的信息。</p>
<h1 id="Part-1-File-Spacing-Numbering-and-Text-Conversion-and-Substitution"><a href="#Part-1-File-Spacing-Numbering-and-Text-Conversion-and-Substitution" class="headerlink" title="Part 1: File Spacing, Numbering and Text Conversion and Substitution"></a>Part 1: File Spacing, Numbering and Text Conversion and Substitution</h1><h2 id="1-File-spacing"><a href="#1-File-spacing" class="headerlink" title="1. File spacing."></a>1. File spacing.</h2><p>1.Double-space a file.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed G</span><br></pre></td></tr></table></figure>
<p>这个G命令会给每行后面都添加一个新的换行。</p>
<p>This sed one-liner uses the G command. If you grabbed my cheat sheet you’ll see that G appends a newline followed by the contents of hold buffer to pattern space. In this example the hold buffer is empty all the time (only three commands h, H and x modify hold buffer), so we end up simply appending a newline to the pattern space. Once all the commands have been executed (in this case just the G command), sed puts the contents of pattern space to output stream followed by a newline. And there we have it. Every line now is followed by two newlines – one added by the G command and the other by output stream. File has been double spaced.</p>
<p>这个 sed one-liner 使用 G 命令。 如果你抓住了我的备忘单，你会看到 G 在模式空间中添加了一个换行符，后跟保持缓冲区的内容。 在这个例子中，保持缓冲区一直是空的（只有三个命令 h、H 和 x 修改了保持缓冲区），所以我们最终只是简单地将换行符附加到模式空间。 一旦所有的命令都被执行（在这种情况下只是 G 命令），sed 将模式空间的内容放到输出流中，然后是一个换行符。 我们终于得到它了。 现在每一行后面都有两个换行符——一个由 G 命令添加，另一个由输出流添加。 文件是双倍行距的。</p>
<p>2.每行后仅加上一个空行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/^$/d;G&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个是先删除文件中的空行，然后在每行后面都加上新的空行。  &#x2F;^$&#x2F;这个是一个匹配模式，匹配empty lines。</p>
<p>Sed allows to restrict commands only to certain lines. This one-liner operates only on lines that match the regular expression &#x2F;^$&#x2F;. What are those lines? Those are the empty lines. Note that before doing the regular expression match, sed pushes the input line to pattern space. When doing it, sed strips the trailing newline character. The empty lines contain just the newline character, so after they have been put into pattern space, this only character has been removed and pattern space stays empty. Regular expression &#x2F;^$&#x2F; matches an empty pattern space and sed applies d command on it, which deletes the current pattern space, reads in the next line, puts it into the pattern space and aborts the current command, and starts the execution from the beginning. The lines which do not match emptiness get a newline character appended by the G command, just like in one-liner #1.</p>
<p>In general sed allows to restrict operations to certain lines (5th, 27th, etc.), to a range of lines (lines 10-20), to lines matching a pattern (lines containing the word “catonmat”), and to lines between two patterns (lines between “catonmat” and “coders”). You’ll learn about this soon.<br>Sed 允许将命令限制在某些行。这个单行只对匹配正则表达式 &#x2F;^$&#x2F; 的行起作用。哪些行？这些空行。请注意，在进行正则表达式匹配之前，sed 会将输入行推送到模式空间。执行此操作时，sed 会去除尾随的换行符。空行只包含换行符，因此在它们被放入模式空间后，这个唯一的字符已被删除，模式空间保持为空。正则表达式 &#x2F;^$&#x2F; 匹配一个空的模式空间并 sed 对其应用 d 命令，这会删除当前模式空间，读入下一行，将其放入模式空间并中止当前命令，并从开始。与空行不匹配的行得到一个由 G 命令附加的换行符，就像在单行#1 中一样。</p>
<p>一般来说，sed 允许将操作限制在某些行（第 5、27 等）、一系列行（第 10-20 行）、匹配模式的行（包含单词“catonmat”的行），以及之间的行两种模式（“catonmat”和“coders”之间的行）。您很快就会了解这一点。</p>
<p>3.Triple-space a file.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;G;G&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Several sed commands can be combined by separating them with ; symbol. Such commands get executed one after another. This one-liner does twice what the one-liner #1 does – appends two newlines (via two G commands) to output.</p>
<p>4.Undo double-spacing.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;n;d&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>This one-liner assumes that even-numbered lines are always blank. It uses two new commands – n and d. The n command prints out the current pattern space (unless the -n flag has been specified), empties the current pattern space and reads in the next line of input. We assumed that even-numbered lines are always blank. This means that ‘n’ prints the first, third, fifth, …, etc. line and reads in the following line. The line following the printed line is always an empty line. Now the ‘d’ command gets executed. The ‘d’ command deletes the current pattern space, reads in the next line, puts the new line into the pattern space and aborts the current command, and starts the execution from the first sed command. Now the the ‘n’ commands gets executed again, then ‘d’, then ‘n’, etc.</p>
<p>To make it shorter - ‘n’ prints out the current line, and ‘d’ deletes the empty line, thus undoing the double-spacing.</p>
<p>5.Insert a blank line above every line that matches “regex”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/regex/&#123;x;p;x;&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one liner uses the restriction operation together with two new commands - ‘x’ and ‘p’. The ‘x’ command exchanges the hold buffer with the pattern buffer. The ‘p’ command duplicates input – prints out the entire pattern space. This one-liner works the following way: a line is read in pattern space, then the ‘x’ command exchanges it with the empty hold buffer. Next the ‘p’ command prints out emptiness followed by a newline, so we get an empty line printed before the actual line. Then ‘x’ exchanges the hold buffer (which now contains the line) with pattern space again. There are no more commands so sed prints out the pattern space. We have printed a newline followed by the line, or saying it in different words, inserted a blank line above every line.</p>
<p>Also notice the { … }. This is command grouping. It says, execute all the commands in “…” on the line that matches the restriction operation.</p>
<p>6 Insert a blank line below every line that matches “regex”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/regex/G&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one liner combines restriction operation with the ‘G’ command, described in one-liner #1. For every line that matches &#x2F;regex&#x2F;, sed appends a newline to pattern space. All the other lines that do not match &#x2F;regex&#x2F; just get printed out without modification.</p>
<p>7.Insert a blank line above and below every line that matches “regex”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/regex/&#123;x;p;x;G;&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner combines one-liners #5, #6 and #1. Lines matching &#x2F;regex&#x2F; get a newline appended before them and printed (x;p;x from #5). Then they are followed by another newline from the ‘G’ command (one-liner #6 or #1).</p>
<h2 id="2-Numbering"><a href="#2-Numbering" class="headerlink" title="2. Numbering."></a>2. Numbering.</h2><p>8.Number each line of a file (named filename). Left align the number.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed = filename | sed <span class="string">&#x27;N;s/\n/\t/&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>One-liners get trickier and trickier. This one-liner is actually two separate one-liners. The first sed one-liner uses a new command called ‘&#x3D;’. This command operates directly on the output stream and prints the current line number. There is no way to capture the current line number to pattern space. That’s why the second one-liner gets called. The output of first one-liner gets piped to the input of second. The second one-liner uses another new command ‘N’. The ‘N’ command appends a newline and the next line to current pattern space. Then the famous ‘s&#x2F;&#x2F;&#x2F;‘ command gets executed which replaces the newline character just appended with a tab. After these operations the line gets printed out.</p>
<p>To make it clear what ‘&#x3D;’ does, take a look at this example file:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line one</span><br><span class="line">line two</span><br><span class="line">line three</span><br></pre></td></tr></table></figure>
<p>Running the first one-liner ‘sed &#x3D; filename’, produces output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">line one</span><br><span class="line">2</span><br><span class="line">line two</span><br><span class="line">3</span><br><span class="line">line three</span><br></pre></td></tr></table></figure>
<p>Now, the ‘N’ command of the second one-liner joins these lines with a newline character:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1\nline one</span><br><span class="line">2\nline two</span><br><span class="line">3\nline three</span><br></pre></td></tr></table></figure>
<p>The ‘s&#x2F;\n&#x2F;\t&#x2F;‘ replaces the newline chars with tabs, so we end up with:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1     line one</span><br><span class="line">2     line two</span><br><span class="line">3     line three</span><br></pre></td></tr></table></figure>
<p>The example is a little inaccurate as line joining with a newline char happens line after line, not on all lines at once.</p>
<p>9.Number each line of a file (named filename). Right align the number.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sed = filename | sed <span class="string">&#x27;N; s/^/     /; s/ *\(.\&#123;6,\&#125;\)\n/\1  /&#x27;</span></span><br></pre></td></tr></table></figure>

<p>This one-liner is also actually two one-liners. The first one liner numbers the lines, just like #8. The second one-liner uses the ‘N’ command to join the line containing the line number with the actual line. Then it uses two substitute commands to right align the number. The first ‘s’ command ‘s&#x2F;^&#x2F; &#x2F;‘ appends 5 white-spaces to the beginning of line. The second ‘s’ command ‘s&#x2F; *(.{6,})\n&#x2F;\1 &#x2F;‘ captures at least six symbols up to a newline and replaces the capture and newline with the back-reference ‘\1’ and two more whitespace to separate line number from the contents of line.</p>
<p>I think it’s hard to understand the last part of this sed expression by just reading. Let’s look at an example. For clearness I replaced the ‘\n’ newline char with a ‘@’ and whitespace with ‘-‘.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;-----12@contents&quot; | sed &#x27;s/-*\(.\&#123;6,\&#125;\)@/\1--/&#x27;</span><br><span class="line">----12--contents</span><br></pre></td></tr></table></figure>
<p>The regular expression ‘-(.{6,})@’ (or just ‘-(.{6,})@’) tells sed to match some ‘-‘ characters followed by at least 6 other characters, followed by a ‘@’ symbol. Sed captures them (remembers them) in \1.</p>
<p>In this example sed matches the first ‘-‘ (the ‘-‘ part of regex), then the following six characters “—-12” and ‘@’ (the ‘(.{6,})@’ part of regex). Now it replaces the matched part of the string “-----12@” with the contents of captured group which is “—-12” plus two extra whitespace. The final result is that “-----12@” gets replaced with “—-12–”.</p>
<p>10.Number each non-empty line of a file (called filename).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/./=&#x27;</span> filename | sed <span class="string">&#x27;/./N; s/\n/ /&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner is again two one-liners. The output of the first one-liner gets piped to the input of second. The first one-liner filters out lines with at least one character in them. The regular expression ‘&#x2F;.&#x2F;‘ says: match lines with at least one char in them. When the empty lines (containing just a newline) get sent to the pattern space, the newline character gets removed, so the empty lines do not get matched. The second one-liner does the same one-liner #8 did, except that only numbered lines get joined and printed out. Command ‘&#x2F;.&#x2F;N’ makes sure that empty lines are left as-is.</p>
<p>11.Count the number of lines in a file (emulates “wc -l”).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;$=&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner uses a command line switch “-n” to modify sed’s behavior. The “-n” switch tells sed not to send the line to output after it has been processed in the pattern space. The only way to make sed output anything with the “-n” switch being on is to use a command that modifies the output stream directly (these commands are ‘&#x3D;’, ‘a’, ‘c’, ‘i’, ‘I’, ‘p’, ‘P’, ‘r’ and ‘w’). In this one-liner what seems to be the command “$&#x3D;” is actually a restriction pattern “$” together with the “&#x3D;” command. The restriction pattern “$” applies the “&#x3D;” command to the last line only. The “&#x3D;” command outputs the current line number to standard output. As it is applied to the last line only, this one-liner outputs the number of lines in the file.</p>
<h2 id="3-Text-Conversion-and-Substitution"><a href="#3-Text-Conversion-and-Substitution" class="headerlink" title="3. Text Conversion and Substitution."></a>3. Text Conversion and Substitution.</h2><p>12.Convert DOS&#x2F;Windows newlines (CRLF) to Unix newlines (LF).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/.$//&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-one liner assumes that all lines end with CR+LF (carriage return + line feed) and we are in a Unix environment. Once the line gets read into pattern space, the newline gets thrown away, so we are left with lines ending in CR. The ‘s&#x2F;.$&#x2F;&#x2F;‘ command erases the last character by matching the last character of the line (regex ‘.$’) and substituting it with nothing. Now when the pattern space gets output, it gets appended the newline and we are left with lines ending with LF.</p>
<p>The assumption about being in a Unix environment is necessary because the newline that gets appended when the pattern space gets copied to output stream is the newline of that environment.</p>
<p>13.Another way to convert DOS&#x2F;Windows newlines (CRLF) to Unix newlines (LF).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/^M$//&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner again assumes that we are in a Unix environment. It erases the carriage return control character ^M. You can usually enter the ^M control char literally by first pressing Ctrl-V (it’s control key + v key) and then Ctrl-M.</p>
<p>14.Yet another way to convert DOS&#x2F;Windows newlines to Unix newlines.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sed <span class="string">&#x27;s/\x0D$//&#x27;</span></span><br></pre></td></tr></table></figure>
<p>This one-liner assumes that we are on a Unix machine. It also assumes that we use a version of sed that supports hex escape codes, such as GNU sed. The hex value for CR is 0x0D (13 decimal). This one-liner erases this character.</p>
<p>15-17. Convert Unix newlines (LF) to DOS&#x2F;Windows newlines (CRLF).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sed <span class="string">&quot;s/$/`echo -e \\\r`/&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>This one-liner also assumes that we are in a Unix environment. It calls shell for help. The ‘echo -e \r’ command inserts a literal carriage return character in the sed expression. The sed “s&#x2F;$&#x2F;char&#x2F;“ command appends a character to the end of current pattern space.</p>
<p>18.Another way to convert Unix newlines (LF) to DOS&#x2F;Windows newlines (CRLF).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/$/\r/&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner assumes that we use GNU sed. GNU sed is smarter than other seds and can take escape characters in the replace part of s&#x2F;&#x2F;&#x2F; command.</p>
<p>19.Convert Unix newlines (LF) to DOS&#x2F;Windows newlines (CRLF) from DOS&#x2F;Windows.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&quot;s/$//&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner works from DOS&#x2F;Windows. It’s basically a no-op one-liner. It replaces nothing with nothing and then sends out the line to output stream where it gets CRLF appended.</p>
<p>20.Another way to convert Unix newlines (LF) to DOS&#x2F;Windows newlines (CRLF) from DOS&#x2F;Windows.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -n p</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This is also a no-op one-liner, just like #19. The shortest one-liner which does the same is:</p>
<p>21.Convert DOS&#x2F;Windows newlines (LF) to Unix format (CRLF) from DOS&#x2F;Windows.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&quot;s/\r//&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Eric says that this one-liner works only with UnxUtils sed v4.0.7 or higher. I don’t know anything about this version of sed, so let’s just trust him. This one-liner strips carriage return (CR) chars from lines. Then when they get output, CRLF gets appended by magic.</p>
<p>Eric mentions that the only way to convert LF to CRLF on a DOS machine is to use tr:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr -d \r &amp;lt;infile &amp;gt;outfile</span><br></pre></td></tr></table></figure>

<p>22.Delete leading whitespace (tabs and spaces) from each line.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/^[ \t]*//&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Pretty simple, it matches zero-or-more spaces and tabs at the beginning of the line and replaces them with nothing, i.e. erases them.</p>
<p>23.Delete trailing whitespace (tabs and spaces) from each line.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/[ \t]*$//&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner is very similar to #22. It does the same substitution, just matching zero-or-more spaces and tabs at the end of the line, and then erases them.</p>
<p>24.Delete both leading and trailing whitespace from each line.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/^[ \t]*//;s/[ \t]*$//&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one liner combines #22 and #23. First it does what #22 does, erase the leading whitespace, and then it does the same as #23, erase trailing whitespace.</p>
<p>25.Insert five blank spaces at the beginning of each line.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/^/     /&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>It does it by matching the null-string at the beginning of line (^) and replaces it with five spaces “     “.</p>
<p>26.Align lines right on a 79-column width.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sed -e :a -e <span class="string">&#x27;s/^.\&#123;1,78\&#125;$/ &amp;/;ta&#x27;</span></span><br></pre></td></tr></table></figure>
<p>This one-liner uses a new command line option and two new commands. The new command line option is ‘-e’. It allows to write a sed program in several parts. For example, a sed program with two substitution rules could be written as “sed -e ‘s&#x2F;one&#x2F;two&#x2F;‘ -e ‘s&#x2F;three&#x2F;four’” instead of “sed ‘s&#x2F;one&#x2F;two&#x2F;;s&#x2F;three&#x2F;four’”. It makes it more readable. In this one-liner the first “-e” creates a label called “a”. The ‘:’ command followed by a name crates a named label. The second “-e” uses a new command “t”. The “t” command branches to a named label if the last substitute command modified pattern space. This branching technique can be used to create loops in sed. In this one-liner the substitute command left-pads the string (right aligns it) a single whitespace at a time, until the total length of the string exceeds 78 chars. The “&amp;” in substitution command means the matched string.</p>
<p>Translating it in modern language, it would look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (str.length() &lt;= 78) &#123;</span><br><span class="line"> str = &quot; &quot; + str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>27.Center all text in the middle of 79-column width.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed  -e :a -e <span class="string">&#x27;s/^.\&#123;1,77\&#125;$/ &amp; /;ta&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner is very similar to #26, but instead of left padding the line one whitespace character at a time it pads it on both sides until it has reached length of at least 77 chars. Then another two whitespaces get added at the last iteration and it has grown to 79 chars.</p>
<p>Another way to do the same is</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed  -e :a -e &#x27;s/^.\&#123;1,77\&#125;$/ &amp;/;ta&#x27; -e &#x27;s/\( *\)\1/\1/&#x27;</span><br></pre></td></tr></table></figure>

<p>This one-liner left pads the string one whitespace char at a time until it has reached length of 78 characters. Then the additional “s&#x2F;( *)\1&#x2F;\1&#x2F;“ command gets executed which divides the leading whitespace “in half”. This effectively centers the string. Unlike the previous one-liner this one-liner does not add trailing whitespace. It just adds enough leading whitespace to center the string.</p>
<p>28.Substitute (find and replace) the first occurrence of “foo” with “bar” on each line.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/foo/bar/&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This is the simplest sed one-liner possible. It uses the substitute command and applies it once on each line. It substitutes string “foo” with “bar”.</p>
<p>29.Substitute (find and replace) the fourth occurrence of “foo” with “bar” on each line.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sed <span class="string">&#x27;s/foo/bar/4&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner uses a flag for the substitute command. With no flags the first occurrence of pattern is changed. With a numeric flag like “&#x2F;1”, “&#x2F;2”, etc. only that occurrence is substituted. This one-liner uses numeric flag “&#x2F;4” which makes it change fourth occurrence on each line.</p>
<p>30.Substitute (find and replace) all occurrence of “foo” with “bar” on each line.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sed <span class="string">&#x27;s/foo/bar/g&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner uses another flag. The “&#x2F;g” flag which stands for global. With global flag set, substitute command does as many substitutions as possible, i.e., all.</p>
<p>31.Substitute (find and replace) the first occurrence of a repeated occurrence of “foo” with “bar”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/\(.*\)foo\(.*foo\)/\1bar\2/&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Let’s understand this one-liner with an example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;this is foo and another foo quux&quot; | sed &#x27;s/\(.*\)foo\(.*foo\)/\1bar\2/&#x27;</span><br><span class="line">this is bar and another foo quux</span><br></pre></td></tr></table></figure>
<p>As you can see, this one liner replaced the first “foo” with “bar”.</p>
<p>It did it by using two capturing groups. The first capturing group caught everything before the first “foo”. In this example it was text “this is “. The second group caught everything after the first “foo”, including the second “foo”. In this example “ and another foo”. The matched text was then replaced with contents of first group “this is “ followed by “bar” and contents of second group “ and another foo”. Since “ quux” was not part of the match it was left unchanged. Joining these parts the resulting string is “this is bar and another foo quux”, which is exactly what we got from running the one-liner.</p>
<p>32.Substitute (find and replace) only the last occurrence of “foo” with “bar”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/\(.*\)foo/\1bar/&#x27;</span></span><br></pre></td></tr></table></figure>
<p>This one-liner uses a capturing group that captures everything up to “foo”. It replaces the captured group and “foo” with captured group itself (the \1 back-reference) and “bar”. It results in the last occurrence of “foo” getting replaced with “bar”.</p>
<p>33.Substitute all occurrences of “foo” with “bar” on all lines that contain “baz”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/baz/s/foo/bar/g&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner uses a regular expression to restrict the substitution to lines matching “baz”. The lines that do not match “baz” get simply printed out, but those that do match “baz” get the substitution applied.</p>
<p>34.Substitute all occurrences of “foo” with “bar” on all lines that DO NOT contain “baz”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/baz/!s/foo/bar/g&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Sed commands can be inverted and applied on lines that DO NOT match a certain pattern. The exclamation “!” before a sed commands does it. In this one-liner the substitution command is applied to the lines that DO NOT match “baz”.</p>
<p>35.Change text “scarlet”, “ruby” or “puce” to “red”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/scarlet/red/g;s/ruby/red/g;s/puce/red/g&#x27;</span></span><br><span class="line"></span><br><span class="line">gsed <span class="string">&#x27;s/scarlet\|ruby\|puce/red/g&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner just uses three consecutive substitution commands. The first replaces “scarlet” with “red”, the second replaced “ruby” with “red” and the last one replaces “puce” with “red”.</p>
<p>If you are using GNU sed, then you can do it simpler:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed &#x27;s/scarlet\|ruby\|puce/red/g&#x27;</span><br></pre></td></tr></table></figure>
<p>GNU sed provides more advanced regular expressions which support alternation. This one-liner uses alternation and the substitute command reads “replace ‘scarlet’ OR ‘ruby’ OR ‘puce’ with ‘red’”.</p>
<p>36.Reverse order of lines (emulate “tac” Unix command).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1!G;h;$!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner acts as the “tac” Unix utility. It’s tricky to explain. The easiest way to explain it is by using an example.</p>
<p>Let’s use a file with just 3 lines:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat file</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>
<p>Running this one-liner on this file produces the file in reverse order:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sed &#x27;1!G;h;$!d&#x27; file</span><br><span class="line">baz</span><br><span class="line">bar</span><br><span class="line">foo</span><br></pre></td></tr></table></figure>
<p>The first one-liner’s command “1!G” gets applied to all the lines which are not the first line. The second command “h” gets applied to all lines. The third command “$!d” gets applied to all lines except the last one.</p>
<p>Let’s go through the execution line by line.</p>
<p>Line 1: Only the “h” command gets applied for the first line “foo”. It copies this line to hold buffer. Hold buffer now contains “foo”. Nothing gets output as the “d” command gets applied.<br>Line 2: The “G” command gets applied. It appends the contents of hold buffer to pattern space. The pattern space now contains. “bar\nfoo”. The “h” command gets applied, it copies “bar\nfoo” to hold buffer. It now contains “bar\nfoo”. Nothing gets output.<br>Line 3: The “G” command gets applied. It appends hold buffer to the third line. The pattern space now contains “baz\nbar\nfoo”. As this was the last line, “d” does not get applied and the contents of pattern space gets printed. It’s “baz\nbar\nfoo”. File got reversed.</p>
<p>If we had had more lines, they would have simply get appended to hold buffer in reverse order.</p>
<p>Here is another way to do the same:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;1!G;h;$p&#x27;</span><br></pre></td></tr></table></figure>
<p>It silences the output with “-n” switch and forces the output with “p” command only at the last line.</p>
<p>These two one-liners actually use a lot of memory because they keep the whole file in hold buffer in reverse order before printing it out. Avoid these one-liners for large files.</p>
<p>37.Reverse a line (emulates “rev” Unix command).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/\n/!G;s/\(.\)\(.*\n\)/&amp;\2\1/;//D;s/.//&#x27;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This is a very complicated one-liner. I had trouble understanding it the first time I saw it and ended up asking on comp.unix.shell for help.</p>
<p>Let’s re-format this sed one-liner:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;</span><br><span class="line">  /\n/ !G</span><br><span class="line">  s/\(.\)\(.*\n\)/&amp;\2\1/</span><br><span class="line">  //D</span><br><span class="line">  s/.//</span><br><span class="line">&#x27; </span><br></pre></td></tr></table></figure>
<p>The first line “&#x2F;\n&#x2F; !G” appends a newline to the end of the pattern space if there was none.</p>
<p>The second line “s&#x2F;(.)(.*\n)&#x2F;&amp;\2\1&#x2F;“ is a simple s&#x2F;&#x2F;&#x2F; expression which groups the first character as \1 and all the others as \2. Then it replaces the whole matched string with “&amp;\2\1”, where “&amp;” is the whole matched text (“\1\2”). For example, if the input string is “1234” then after the s&#x2F;&#x2F;&#x2F; expression, it becomes “1234\n234\n1”.</p>
<p>The third line is “&#x2F;&#x2F;D”. This statement is the key in this one-liner. An empty pattern &#x2F;&#x2F; matches the last existing regex, so it’s exactly the same as: &#x2F;(.)(.\n)&#x2F;D. The “D” command deletes from the start of the input till the first newline and then resumes editing with first command in script. It creates a loop. As long as &#x2F;(.)(.\n)&#x2F; is satisfied, sed will resume all previous operations. After several loops, the text in the pattern space becomes “\n4321”. Then &#x2F;(.)(.*\n)&#x2F; fails and sed goes to the next command.</p>
<p>The fourth line “s&#x2F;.&#x2F;&#x2F;“ removes the first character in the pattern space which is the newline char. The contents in pattern space becomes “4321” – reverse of “1234”.</p>
<p>There you have it, a line has been reversed.</p>
<p>38.Join pairs of lines side-by-side (emulates “paste” Unix command).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;$!N;s/\n/ /&#x27;</span><br></pre></td></tr></table></figure>
<p> This one-liner joins two consecutive lines with the “N” command. They get joined with a “\n” character between them. The substitute command replaces this newline with a space, thus joining every pair of lines with a whitespace.</p>
<p>39.Append a line to the next if it ends with a backslash “&quot;.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e :a -e &#x27;/\\$/N; s/\\\n//; ta&#x27;</span><br></pre></td></tr></table></figure>
<p>The first expression ‘:a’ creates a named label “a”. The second expression looks to see if the current line ends with a backslash “&quot;. If it does, it joins it with the line following it using the “N” command. Then the slash and the newline between joined lines get erased with “s&#x2F;\n&#x2F;&#x2F;“ command. If the substitution was successful we branch to the beginning of expression and do the same again, in hope that we might have another backslash. If the substitution was not successful, the line did not end with a backslash and we print it out.</p>
<p>Here is an example of running this one-liner:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat filename</span><br><span class="line">line one \</span><br><span class="line">line two</span><br><span class="line">line three</span><br><span class="line">$ sed -e :a -e &#x27;/\\$/N; s/\\\n//; ta&#x27; filename</span><br><span class="line">line one line two</span><br><span class="line">line three</span><br></pre></td></tr></table></figure>
<p>Lines one and two got joined because the first line ended with backslash.</p>
<p>40.Append a line to the previous if it starts with an equal sign “&#x3D;”.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e :a -e &#x27;$!N;s/\n=/ /;ta&#x27; -e &#x27;P;D&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner also starts with creating a named label “a”. Then it tests to see if it is not the last line and appends the next line to the current one with “N” command. If the just appended line starts with a “&#x3D;”, one-liner branches the label “a” to see if there are more lines starting with “&#x3D;”. During this process a substitution gets executed which throws away the newline character which came from joining with “N” and the “&#x3D;”. If the substitution fails, one-liner prints out the pattern space up to the newline character with the “P” command, and deletes the contents of pattern space up to the newline character with “D” command, and repeats the process.</p>
<p>Here is an example of running it:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat filename</span><br><span class="line">line one</span><br><span class="line">=line two</span><br><span class="line">=line three</span><br><span class="line">line four</span><br><span class="line">$ sed -e :a -e &#x27;$!N;s/\n=/ /;ta&#x27; -e &#x27;P;D&#x27; filename</span><br><span class="line">line one line two line three</span><br><span class="line">line four</span><br></pre></td></tr></table></figure>
<p>Lines one, two and three got joined, because lines two and three started with ‘&#x3D;’. Line four got printed as-is.</p>
<p>41.Digit group (commify) a numeric string.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed -e :a -e &#x27;s/\(.*[0-9]\)\([0-9]\&#123;3\&#125;\)/\1,\2/;ta&#x27;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">gsed &#x27;:a;s/\B[0-9]\&#123;3\&#125;\&gt;/,&amp;/;ta&#x27;</span><br></pre></td></tr></table></figure>

<p>This one-liner turns a string of digits, such as “1234567” to “1,234,567”. This is called commifying or digit grouping.</p>
<p>First the one-liner creates a named label “a”. Then it captures two groups of digits. The first group is all the digits up to last three digits. The last three digits gets captures in the 2nd group. Then the two matching groups get separated by a comma. Then the same rules get applied to the line again and again until all the numbers have been grouped in groups of three.</p>
<p>Substitution command “\1,\2” separates contents of group one with a comma from the contents of group two.</p>
<p>Here is an example to understand the grouping happening here better. Suppose you have a numeric string “1234567”. The first group captures all the numbers until the last three “1234”. The second group captures last three numbers “567”. They get joined by a comma. Now the string is “1234,567”. The same stuff is applied to the string again. Number “1” gets captured in the first group and the numbers “234” in the second. The number string is “1,234,567”. Trying to apply the same rules again fail because there is just one digit at the beginning of string, so the string gets printed out and sed moves on to the next line.</p>
<p>If you have GNU sed, you can use a simpler one-liner:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed &#x27;:a;s/\B[0-9]\&#123;3\&#125;\&gt;/,&amp;/;ta&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner starts with creating a named label “a” and then loops over the string the same way as the previous one-liner did. The only difference is how groups of three digits get matched. GNU sed has some additional patterns. There are two patterns that make this one-liner work. The first is “\B”, which matches anywhere except at a word boundary. It’s needed so we did not go beyond word boundary. Look at this example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;12345 1234 123&quot; | sed &#x27;s/[0-9]\&#123;3\&#125;\&amp;gt;/,&amp;/g&#x27;</span><br><span class="line">12,345 1,234 ,123</span><br></pre></td></tr></table></figure>
<p>It’s clearly wrong. The last 123 got a comma added. Adding the “\B” makes sure we match the numbers only at word boundary:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;12345 1234 123&quot; | sed &#x27;s/\B[0-9]\&#123;3\&#125;\&amp;gt;/,&amp;/g&#x27;</span><br><span class="line">12,345 1,234 123</span><br></pre></td></tr></table></figure>
<p>The second is “&gt;”. It matches the null string at the end of a word. It’s necessary because we need to to match the right-most three digits. If we did not have it, the expression would match after the first digit.</p>
<p>42.Add commas to numbers with decimal points and minus signs.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed -r &#x27;:a;s/(^|[^0-9.])([0-9]+)([0-9]&#123;3&#125;)/\1\2,\3/g;ta&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner works in GNU sed only. It turns on extended regular expression support with the “-r” switch. Then it loops over a line matching three groups and separates the first two from the third with a comma.</p>
<p>The first group makes sure we ignore a leading non-digit character, such as + or -. If there is no leading non-digit character, then it just anchors at the beginning of the string which always matches.</p>
<p>The second group matches a bunch of numbers. The third group makes sure the second group does not match too many. It matches 3 consecutive numbers at the end of the string.</p>
<p>Once the groups have been captured, the “\1\2,\3” substitution is done and the expression is looped again, until the whole string has been commified.</p>
<p>43.Add a blank line after every five lines.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;n;n;n;n;G;&#x27;</span><br></pre></td></tr></table></figure>
<p>The “n” command is called four times in this one-liner. Each time it’s called it prints out the current pattern space, empties it and reads in the next line of input. After calling it four times, the fifth line is read into the pattern space and then the “G” command gets called. The “G” command appends a newline to the fifth line. Then the next round of four “n” commands is done. Next time the first “n” command is called it prints out the newlined fifth line, thus inserting a blank line after every 5 lines.</p>
<p>The same can be achieved with GNU sed’s step extension:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed &#x27;0~5G&#x27;</span><br></pre></td></tr></table></figure>
<p>GNU sed’s step extensions can be generalized as “first~step”. It matches every “step”‘th line starting with line “first”. In this one-liner it matches every 5th line starting with line 0.</p>
<ol start="4">
<li><p>Selective Printing of Certain Lines.</p>
</li>
<li><p>Print the first 10 lines of a file (emulates “head -10”).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed 10q</span><br></pre></td></tr></table></figure>
<p>This one-liner restricts the “q” (quit) command to line “10”. It means that this command gets executed only when sed reads the 10th line. For all the other lines there is no command specified. When there is no command specified, the default action is to print the line as-is. This one-liner prints lines 1-9 unmodified and at 10th line quits. Notice something strange? It was supposed to print first 10 lines of a file, but it seems that it just printed only the first 9… Worry not! The quit command is sneaky in its nature. Upon quitting with “q” command, sed actually prints the contents of pattern space and only then quits. As a result lines 1-10 get printed!</p>
</li>
</ol>
<p>Please see the first part of the article for explanation of “pattern space”.</p>
<ol start="45">
<li>Print the first line of a file (emulates “head -1”).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed q</span><br></pre></td></tr></table></figure>
The explanation of this one-liner is almost the same as of the previous. Sed quits and prints the first line.</li>
</ol>
<p>A more detailed explanation - after the first line has been placed in the pattern space, sed executes the “q” command. This command forces sed to quit; but due to strange nature of the “q” command, sed also prints the contents of pattern space. As a result, only the first line gets printed.</p>
<ol start="46">
<li>Print the last 10 lines of a file (emulates “tail -10”).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e :a -e &#x27;$q;N;11,$D;ba&#x27;</span><br></pre></td></tr></table></figure>
This one-liner is tricky to explain. It always keeps the last 10 lines in pattern space and at the very last line of input it quits and prints them.</li>
</ol>
<p>I’ll try to explain it. The first “-e :a” creates a label called “a”. The second “-e” does the following: “$q” - if it is the last line, quit and print the pattern space. If it is not the last line, execute three commands “N”, “11,$D” and “ba”. The “N” command reads the next line of input and appends it to the pattern space. The line gets separated from the rest of the pattern space by a new line character. The “11,$D” command executes the “D” command if the current line number is greater than or equal to 11 (“11,$” means from 11th line to end of file). The “D” command deletes the portion of pattern space up to the first new line character. The last command “ba” branches to a label named “a” (beginning of script). This guarantees that the pattern space never contains more than 10 lines, because as line 11 gets appended to pattern space, line 1 gets deleted, as line 12 gets appended line 2 gets deleted, etc.</p>
<ol start="47">
<li>Print the last 2 lines of a file (emulates “tail -2”).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;$!N;$!D&#x27;</span><br></pre></td></tr></table></figure>
This one-liner is also tricky. First of all, the “$!” address restricts commands “N” and “D” to all the lines except the last line.</li>
</ol>
<p>Notice how the addresses can be negated. If “$<command>“ restricts a command to the last line, then “$!<command>“ restricts the command to all but the last line. This can be applied to all restriction operations.</p>
<p>In this one-liner the “N” command reads the next line from input and appends it to pattern space. The “D” command deletes everything in pattern space up to the first “\n” symbol. These two commands always keep only the most recently read line in pattern space. When processing the second-to-last line, “N” gets executed and appends the last line to the pattern space. The “D” does not get executed as “N” consumed the last line. At this moment sed quits and prints out the last two lines of the file.</p>
<ol start="48">
<li>Print the last line of a file (emulates “tail -1”).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;$!d&#x27;</span><br></pre></td></tr></table></figure>
This one-liner discards all the lines except the last one. The “d” command deletes the current pattern space, reads in the next line, and restarts the execution of commands from the first. In this case it just loops over itself like “dddd…ddd” until it hits the last line. At the last line no command is executed (“$!d” restricted execution of “d” to all the lines but last) and the pattern space gets printed.</li>
</ol>
<p>Another way to do the same:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;$p&#x27;</span><br></pre></td></tr></table></figure>
<p>The “-n” parameter suppresses automatic printing of pattern space. It means that without an explicit “p” command (or other commands that act directly on the output stream), sed is dead silent. The “p” command stands for “print” and it prints the pattern space. This one-liner calls the “p” command at the very last line of input. All the other lines are silently discarded.</p>
<ol start="49">
<li>Print next-to-the-last line of a file.</li>
</ol>
<p>Eric gives three different one-liners to do this. The first one prints a blank line if the file contains just 1 line:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;$!&#123;h;d;&#125;&#x27; -e x</span><br></pre></td></tr></table></figure>
<p>This one-liner executes the “h;d” commands for all the lines except the last one (“$!” restricts “h;d” commands to all lines except last). The “h” command puts the current line in hold buffer and “d” deletes the current line, and starts execution at the first sed command (“h;d” gets executed again, and again, …). At every single line, that line gets copied to hold buffer. At the very last line “h;d” does not get executed. At this moment “x” gets a chance to execute. The “x” command exchanges the contents of hold buffer with pattern space. Remember that the previous line is still in the hold buffer. The “x” command puts it back in pattern space, and sed prints it! There you go, the next-to-last line was printed!</p>
<p>In case there is just 1 line in the file, only the “x” command gets executed. As the hold buffer initially is empty, “x” puts emptiness in pattern space (I use word “put” here but it actually exchanges the pattern space with hold space). Now sed prints the contents of pattern space, but it’s empty, so sed prints out just a blank line.</p>
<p>The second prints the first line if the file contains just 1 line:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;1&#123;$q;&#125;&#x27; -e &#x27;$!&#123;h;d;&#125;&#x27; -e x</span><br></pre></td></tr></table></figure>
<p>This sed-one liner is divided in two parts. The first part “1{$q;}” handles the case when the file contains just a single line. The second part “$!{h;d;} x” is exactly the same as in the previous one-liner! Thus, I need to explain just the first part.</p>
<p>The first part says - if it is the first line “1”, then execute “$q”. The “$q” command means - if it is the last line, then quit. What it effectively does is it quits if the first line is the last line (i.e. file contains just one line). Remember from one-liner #44 that before quitting sed prints the contents of pattern space. As a result, if the file contains just one line, sed prints it.</p>
<p>The third prints nothing for 1 line files:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;1&#123;$d;&#125;&#x27; -e &#x27;$!&#123;h;d;&#125;&#x27; -e x</span><br></pre></td></tr></table></figure>
<p>This one-liner is again divided in two parts. The first part is “1{$d;}” and the second is exactly the same as in the previous two one-liners. I will explain just the first part.</p>
<p>The first part says - if it is the first line “1”, then execute “$d”. The “$d” command means - if it is the last line, then delete the pattern space and start all over again. In case the first line is the last (only one line in file), there is nothing more to be done and sed quits, printing nothing.</p>
<ol start="50">
<li>Print only the lines that match a regular expression (emulates “grep”).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/regexp/p&#x27;</span><br></pre></td></tr></table></figure>
This one-liner suppresses automatic printing of pattern space with the “-n” switch and makes use of “p” command to print only the lines that match “&#x2F;regexp&#x2F;“. The lines that do not match this regex get silently discarded. The ones that match get printed. That’s it.</li>
</ol>
<p>Another one-liner that does the same:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/regexp/!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner deletes all the lines that do not match “&#x2F;regexp&#x2F;“. The other lines get printed by default. The “!” before “d” command inverts the line matching.</p>
<ol start="51">
<li>Print only the lines that do not match a regular expression (emulates “grep -v”).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/regexp/!p&#x27;</span><br></pre></td></tr></table></figure>
This one-liner is the inverse of the previous.</li>
</ol>
<p>The “-n” prevents automatic printing of pattern space. The “&#x2F;regexp&#x2F;“ restricts the “!p” command only to lines that match “&#x2F;regexp&#x2F;“, but the “!” switch prevents “p” from acting on these lines. What happens is “p” acts on all lines that do not match “&#x2F;regexp&#x2F;“, and they get “p”rinted.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/regexp/d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is the inverse of the previous (#50).</p>
<p>This one-liner executed the “d” (delete) command on all lines that match “&#x2F;regexp&#x2F;“, thus leaving only the lines that do not match. They get printed automatically.</p>
<ol start="52">
<li><p>Print the line immediately before regexp, but not the line containing the regexp.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/regexp/&#123;g;1!p;&#125;;h&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner saves each line in hold buffer with “h” command. If a line matches the regexp, the hold buffer (containing the previous line) gets copied to pattern space with “g” command and the pattern space gets printed out with “p” command. The “1!” restricts “p” not to print on the first line (as there are no lines before the first).</p>
</li>
<li><p>Print the line immediately after regexp, but not the line containing the regexp.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/regexp/&#123;n;p;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>First of all, this one-liner disables automatic printing of pattern space with “-n” command line argument. Then, for all the lines that match “&#x2F;regexp&#x2F;“, this one-liner executes “n” and “p” commands. The “n” command is the only command that depends on “-n” flag explicitly. If “-n” is specified it will empty the current pattern space and read in the next line of input. If “-n” is not specified, it will print out the current pattern space before emptying it. As in this one-liner “-n” is specified, the “n” command empties the pattern space, reads in the next line and then the “p” command prints that line out.</p>
</li>
<li><p>Print one line before and after regexp. Also print the line matching regexp and its line number. (emulates “grep -A1 -B1”).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e &#x27;/regexp/&#123;=;x;1!p;g;$!N;p;D;&#125;&#x27; -e h</span><br></pre></td></tr></table></figure>
<p>First let’s look at “h” command at the end of script. It gets executed on every line and stores the current line in pattern space in hold buffer. The idea of storing the current line in hold buffer is that if the next line matches “&#x2F;regexp&#x2F;“ then the previous line is available in hold buffer.</p>
</li>
</ol>
<p>Now let’s look at the complicated “&#x2F;regexp&#x2F;{&#x3D;;x;1!p;g;$!N;p;D;}” command. It gets executed only if the line matches “&#x2F;regexp&#x2F;“. The first thing it does is it prints the current line number with “&#x3D;” command. Then, it exchanges the hold buffer with pattern space by using the “x” command. As I explained, the “h” command at the end of the script makes sure that the hold buffer always contains the previous line. Now we have put it in the pattern space with “x” command. Next, if it’s not the first line, “1!p” prints the pattern space, effectively printing the previous line. Now the “g” command gets executed. It copies the original line that was just exchanged with hold buffer back to pattern space. Now the “$!N” executes. If it is not the last line, “N” appends the next line to the current pattern space (and separates them with “\n” char). Pattern space now contains the line that matched “&#x2F;regexp&#x2F;“ and the next line. The “p” command prints that. “D” deletes the current line (line that matched “&#x2F;regexp&#x2F;“) from pattern space and finally “h” gets executed again, that puts the contents of pattern space into hold buffer. As “D” deleted the current line, the next line was put in hold buffer.</p>
<ol start="55">
<li><p>Grep for “AAA” and “BBB” and “CCC” in any order.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/AAA/!d; /BBB/!d; /CCC/!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner inverts the “d” command to be executed on lines that do not contain either “AAA”, “BBB” or “CCC”. If a line does not contain one of them, it gets deleted and sed proceeds to the next line. Only if all three of the patterns are present, does the sed print the line.</p>
</li>
<li><p>Grep for “AAA” and “BBB” and “CCC” in that order.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/AAA.*BBB.*CCC/!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner deletes lines that do not match regexp “&#x2F;AAA.BBB.CCC&#x2F;“. For example, a line “AAAfooBBBbarCCC” will get printed but “AAAfooCCCbarBBB” baz will not.</p>
</li>
</ol>
<p>It can also be written as:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/AAA.*BBB.*CCC/p&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner prints lines that contain AAA…BBB…CCC in that order.</p>
<ol start="57">
<li>Grep for “AAA” or “BBB”, or “CCC”.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;/AAA/b&#x27; -e &#x27;/BBB/b&#x27; -e &#x27;/CCC/b&#x27; -e d</span><br></pre></td></tr></table></figure>
This one-liner uses the “b” command to branch to the end of the script if the line matches “AAA” or “BBB” or “CCC”. At the end of the script the line gets implicitly printed. If the line does not match “AAA” or “BBB” or “CCC”, the script reaches the “d” command that deletes the line.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed &#x27;/AAA\|BBB\|CCC/!d&#x27;</span><br></pre></td></tr></table></figure>
This one-liner works with GNU sed. GNU sed allows alternation operator | to be used to match separate things. It’s a more compact way of saying match “AAA” or “BBB”, or “CCC”.</li>
</ol>
<p>If you are using GNU sed, then there is actually no need to escape the pipes |. You may specify the “-r” command line option to use extended regular expressions. This way this one liner becomes:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed -r &#x27;/AAA|BBB|CCC/!d&#x27;</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed -rn &#x27;/AAA|BBB|CCC/p&#x27;</span><br></pre></td></tr></table></figure>
<ol start="58">
<li>Print a paragraph that contains “AAA”. (Paragraphs are separated by blank lines).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;/./&#123;H;$!d;&#125;&#x27; -e &#x27;x;/AAA/!d;&#x27;</span><br></pre></td></tr></table></figure>
First notice that this one-liner is divided in two parts for clearness. The first part is “&#x2F;.&#x2F;{H;$!d;}” and the second part is “x;&#x2F;AAA&#x2F;!d”.</li>
</ol>
<p>The first part has an interesting pattern match “&#x2F;.&#x2F;“. What do you think it does? Well, a line separating paragraphs would be a blank line, meaning it would not have any characters in it. This pattern matches only the lines that are not separating paragraphs. These lines get appended to hold buffer with “H” command. They also get prevented from printing with “d” command (except for the last line, when “d” does not get executed (“$!” restricts “d” to all but the last line)). Once sed sees a blank line, the “&#x2F;.&#x2F;“ pattern no longer matches and the second part of one-liner gets executed.</p>
<p>The second part exchanges the hold buffer with pattern space by using the “x” command. The pattern space now contains the whole paragraph of text. Next sed tests if the paragraph contains “AAA”. If it does, sed does nothing which results in printing the paragraph. If the paragraph does not contain “AAA”, sed executes the “d” command that deletes it without printing and restarts execution at first command.</p>
<ol start="59">
<li>Print a paragraph if it contains “AAA” and “BBB” and “CCC” in any order.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;/./&#123;H;$!d;&#125;&#x27; -e &#x27;x;/AAA/!d;/BBB/!d;/CCC/!d&#x27;</span><br></pre></td></tr></table></figure>
This one-liner is also split in two parts for clarity. The first part is exactly the same as the first part of previous one-liner. The second part is very similar to one-liner #55 and also the previous.</li>
</ol>
<p>The “x” command in the 2nd part does exactly the same as in previous one-liner, it exchanges the hold buffer, that contains the paragraph with pattern space. Next sed does three tests - it tests if the paragraph contains “AAA”, “BBB” and “CCC”. If the paragraph does not contain even one of them, the “d” command gets executed that purges the paragraph. If it contains all three patterns, sed happily prints the paragraph.</p>
<ol start="60">
<li>Print a paragraph if it contains “AAA” or “BBB” or “CCC”.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;/./&#123;H;$!d;&#125;&#x27; -e &#x27;x;/AAA/b&#x27; -e &#x27;/BBB/b&#x27; -e &#x27;/CCC/b&#x27; -e d</span><br></pre></td></tr></table></figure>
The first part is exactly the same as in previous two one-liners and does not require explanation. The second part that happens to be “-e ‘x;&#x2F;AAA&#x2F;b’ -e ‘&#x2F;BBB&#x2F;b’ -e ‘&#x2F;CCC&#x2F;b’ -e d” is almost exactly the same as in one-liner #57.</li>
</ol>
<p>The “x” command exchanges the paragraph stored in hold buffer with the pattern space. Then it tests if the pattern space (paragraph) contains “AAA”, if it does, sed branches to end of script with “b” command, that happily makes sed print the paragraph. If “AAA” did not match, sed does exactly the same testing for pattern “BBB”. If it again did not match, it tests for “CCC”. If none of these patterns were found, sed executes the “d” command that deletes everything and restarts this one-liner.</p>
<p>Here is another way to do the same with GNU sed:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed &#x27;/./&#123;H;$!d;&#125;;x;/AAA\|BBB\|CCC/b;d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is exactly the same as previous one. It just compresses the three tests for “AAA”, “BBB” or “CCC” into one “&#x2F;AAA|BBB|CCC&#x2F;“ as explained in one-liner #57.</p>
<ol start="61">
<li><p>Print only the lines that are 65 characters in length or more.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/^.\&#123;65\&#125;/p&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner prints lines that are 65 characters in length or more. It does it by using a regular expression “^.{65}” that matches any 65 characters at the beginning of line. If there are less than 65 characters, the regex does not match and the line does not get printed (as automatic printing was disabled with “-n” command line option).</p>
</li>
<li><p>Print only the lines that are less than 65 chars.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/^.\&#123;65\&#125;/!p&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner inverts the previous one. If the line matches 65 characters, then it is not printed “!p”. If it does not match, it gets printed.</p>
</li>
</ol>
<p>Another way to do the same:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^.\&#123;65\&#125;/d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner deletes all lines that match 65 characters. All others implicitly get printed.</p>
<ol start="63">
<li><p>Print section of a file from a regex to end of file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/regexp/,$p&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses a tricky range match “&#x2F;regex&#x2F;,$”. It matches lines starting from the first line that matches “&#x2F;regex&#x2F;“ to the end of file “$”. The “p” command prints these lines. All other lines get silently discarded.</p>
</li>
<li><p>Print lines 8-12 (inclusive) of a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;8,12p&#x27;</span><br></pre></td></tr></table></figure>
<p>This is another type of range match. This range matches a section of lines between two lines numbers (inclusive). In this case it’s lines [8 to 12].</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;8,12!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This is the same one-liner, just written differently. It deletes lines that are outside of range [8, 12] and prints those in this range.</p>
</li>
<li><p>Print line number 52.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;52p&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner restricts the “p” command to line “52”. Only this line gets “p”rinted.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;52!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner deletes all lines except line 52. Line 52 gets printed.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;52q;d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one is the smartest. It quits at line 52 with “q” command. The previous two one-liners would loop over all the remaining lines and do nothing. Remember from one-liner #44 that quit command prints the pattern space with it. The “d” command makes sure that no other line gets printed while sed gets to line 52.</p>
</li>
<li><p>Beginning at line 3, print every 7th line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed -n &#x27;3~7p&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses a line range match extension of GNU sed. A line range in format “first<del>step” matches every step’th line starting from first. In this one-liner it’s “3</del>7”, meaning match every 7th line starting from 3rd. The “-n” flag prevents printing any other lines, and “p” in “3~7p” prints the matched line.</p>
</li>
</ol>
<p>For everyone else, this one-liner works:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;3,$&#123;p;n;n;n;n;n;n;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner executes commands “p;n;n;n;n;n;n” for lines starting the 3rd line. The “3,$” is a line range match that restricts commands by line numbers. The “$” means end of file and “3” means 3rd line.</p>
<p>The “p;n;n;n;n;n;n” command prints the line, then skips 6, prints the 7th, skips 6, prints the 14th, etc. As it starts executing at line 3, the effect is - print line 3, skip 6, print line 10, skip 6, print line 17, …. That is, print every 7th line beginning at 3rd.</p>
<ol start="67">
<li>Print section of lines between two regular expressions (inclusive).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/Iowa/,/Montana/p&#x27;</span><br></pre></td></tr></table></figure>
This one-liner prints all the lines between the first line that matches a regular expression “Iowa” and the first line that matches a regular expression “Montana”.</li>
</ol>
<p>It uses a range match “&#x2F;start&#x2F;,&#x2F;finish&#x2F;“ that matches all lines starting from a line that matches “start” and ending with the first line that matches “finish”.</p>
<ol start="5">
<li><p>Selective Deletion of Certain Lines</p>
</li>
<li><p>Print all lines in the file except a section between two regular expressions.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/Iowa/,/Montana/d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner continues where the previous left off. One-liner #67 used the range match “&#x2F;start&#x2F;,&#x2F;finish&#x2F;“ to print lines between two regular expressions (inclusive). This one-liner, on the other hand, deletes lines between two regular expressions and prints all the lines outside this range. Just to remind you, a range “&#x2F;start&#x2F;,&#x2F;finish&#x2F;“ matches all lines starting from the first line that matches a regular expression “&#x2F;start&#x2F;“ to the first line that matches a regular expression “&#x2F;finish&#x2F;“. In this particular one-liner the “d”, delete, command is applied to these lines. The delete command prevents the matching lines from ever seeing the light.</p>
</li>
</ol>
<p>For example, suppose your input to this one-liner was:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Florida</span><br><span class="line">&lt;strong&gt;Iowa</span><br><span class="line">New York</span><br><span class="line">San Jose</span><br><span class="line">Montana&lt;/strong&gt;</span><br><span class="line">Texas</span><br><span class="line">Fairbanks</span><br></pre></td></tr></table></figure>
<p>Then after the sed program has finished running, the output is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Florida</span><br><span class="line">Texas</span><br><span class="line">Fairbanks</span><br></pre></td></tr></table></figure>
<p>We see this output because the lines from Iowa to Montana matched the “&#x2F;Iowa&#x2F;,&#x2F;Montana&#x2F;“ range match (i put the matched lines in bold) and were deleted.</p>
<ol start="69">
<li>Delete duplicate, consecutive lines from a file (emulates “uniq”).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;$!N; /^\(.*\)\n\1$/!P; D&#x27;</span><br></pre></td></tr></table></figure>
This one-liner acts as the “uniq” Unix utility. So how does it work? First of all, for every line that is not the very last line of input, sed appends the next line to the pattern space by the “N” command. The “N” command is restricted to all but the last line by “$!” restriction pattern. The newly appended line is separated from the previous line by the “\n” character. Next, the pattern space is matched against “&#x2F;^(.*)\n\1$&#x2F;“ regular expression. This regular expression captures the previous line up to “\n” character and saves it in the match group “\1”. Then it tests if the newly appended line is the same as the previous one. If it is not, the “P” gets executed. If it is, the “P” command does not get executed. The “P” command prints everything in the pattern space up to the first “\n” character. Next the “D” command executes and deletes everything up to the first “\n” char, leaving only the newly read line in pattern space. It also forces the sed script to begin from the first command.</li>
</ol>
<p>This way it loops over all lines, comparing two consecutive lines. If they are equal, the first line gets deleted, and a new line gets appended to what’s left. If they are not equal, the first one gets deleted, and deleted.</p>
<p>I think it’s hard to understand what is going on from this description. I’ll illustrate it with an example. Suppose this is the input:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">foo</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>
<p>The first thing sed does is it reads the first line of input in pattern space. The pattern space now contains “foo”. Now the “N” command executed. The pattern space now contains “foo\nfoo”. Next the pattern space is tested against “&#x2F;^(.)\n\1$&#x2F;“ regular expression. This regular expression matches because “(.)” is “foo” and “&#x2F;^(.)\n\1$&#x2F;“ is “foo\nfoo”, exactly what we have in the pattern space. As it matched, the “P” command does not get executed. Now the “D” command executes, deleting the everything up to first “\n” from pattern space. The pattern space now contains just “foo”. The “D” command forces sed to start from the first command. Now the “N” is executed again, the pattern space now contains “foo\nfoo” again and the same thing happens, “P” does not get executed and “D” deletes the first “foo”, leaving the pattern space with just “foo” in it. Now the “N” gets executed once again, this time “bar” gets appended to pattern space. It contains “foo\nbar” now. The regular expression “&#x2F;^(.)\n\1$&#x2F;“ does not match and “P” gets executed, printing “foo”. After that “D” gets executed wiping “foo” from pattern space. The pattern space now contains “bar”. The commands restart and “N” gets executed, it appends the next “bar” to current pattern space. Now it contains “bar\nbar”. Just like with “foo\nfoo”, nothing gets printed, and “D” deletes the first “bar”, leaving pattern space with “bar”. The one-liner restarts its execution. Now “N” reads in the final line “baz”. The pattern space contains “bar\nbaz” which does not match the regular expression. The “P” prints out the “bar” and “D” deletes “bar”. Now “N” does not get executed because we are at the last line of input. The “$!N” restricts “N” to all lines but last. At this moment pattern space contains only the last “baz”, the regular expression does not match, so “baz” gets printed. The “D” command executes, emptying the pattern space. There is no more input and sed quits.</p>
<p>The output for this example is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>
<p>I think this is one of the most detailed explanations I have written about a single one liner. :)</p>
<ol start="70">
<li>Delete duplicate, nonconsecutive lines from a file.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;G; s/\n/&amp;&amp;/; /^\([ -~]*\n\).*\n\1/d; s/\n//; h; P&#x27;</span><br></pre></td></tr></table></figure>
This is a very tricky one-liner. It stores the unique lines in hold buffer and at each newly read line, tests if the new line already is in the hold buffer. If it is, then the new line is purged. If it’s not, then it’s saved in hold buffer for future tests and printed.</li>
</ol>
<p>A more detailed description - at each line this one-liner appends the contents of hold buffer to pattern space with “G” command. The appended string gets separated from the existing contents of pattern space by “\n” character. Next, a substitution is made to that substitutes the “\n” character with two “\n\n”. The substitute command “s&#x2F;\n&#x2F;&amp;&amp;&#x2F;“ does that. The “&amp;” means the matched string. As the matched string was “\n”, then “&amp;&amp;” is two copies of it “\n\n”. Next, a test “&#x2F;^([ -<del>]\n).\n\1&#x2F;“ is done to see if the contents of group capture group 1 is repeated. The capture group 1 is all the characters from space “ “ to “</del>“ (which include all printable chars). The “[ -<del>]” matches that. Replacing one “\n” with two was the key idea here. As “([ -</del>]\n)” is greedy (matches as much as possible), the double newline makes sure that it matches as little text as possible. If the test is successful, the current input line was already seen and “d” purges the whole pattern space and starts script execution from the beginning. If the test was not successful, the doubled “\n\n” gets replaced with a single “\n” by “s&#x2F;\n&#x2F;&#x2F;“ command. Then “h” copies the whole string to hold buffer, and “P” prints the new line.</p>
<ol start="71">
<li>Delete all lines except duplicate consecutive lines (emulates “uniq -d”).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;$!N; s/^\(.*\)\n\1$/\1/; t; D&#x27;</span><br></pre></td></tr></table></figure>
This sed one-liner prints only the duplicate lines. This sed one-liner starts with reading in the next line from input with the “N” command. As I already mentioned, the current line and the next get separated by “\n” character after “N” executes. This one-liner also restrics “N” to all lines but last with “$!” restriction. Now a substitution “s&#x2F;^(.*)\n\1$&#x2F;\1&#x2F;“ is tried. Similarly to one-liner #69, this substitution replaces two repeating strings with one. For example, a string “foo\nfoo” gets replaced with just “foo”. Now, if this substitution was successful (there was a repeated string), the “t” command takes the script to the end where the current pattern space gets printed automatically. If the substitution was not successful, “D” executes, deleting the non-repeated string. The cycle continues and this way only the duplicate lines get printed once.</li>
</ol>
<p>Let’s take a look at an example. Suppose the input is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>
<p>This one-liner reads the first line and immediately executes the “N” command. The pattern space now is “foo\nfoo”. The substitution “s&#x2F;^(.*)\n\1$&#x2F;\1&#x2F;“ is tried and it’s successful, because “foo” is repeated twice. The pattern space now contains just a single “foo”. As the substitution was successful, “t” command branches to the end of the script. At this moment “foo” gets printed. Now the cycle repeats. Sed reads in “bar”, the “N” command appends “baz” to “bar”. The pattern space now is “bar\nbaz”. The substitution is tried, but it’s not successful, as “bar” is not repeated. As the substitution failed, “t” does nothing and “D” executes, deleting “bar” from pattern space. The pattern space is left with single “baz”. Command “N” no longer executes as we reached end of file, substitution fails, “t” fails, and “D” deletes the “baz”.</p>
<p>The end result is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br></pre></td></tr></table></figure>
<p>Just as we expected - only the duplicate line got printed.</p>
<ol start="72">
<li><p>Delete the first 10 lines of a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1,10d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner restricts the “d” command to a range of lines by number. The “1,10” means a range matching lines 1 to 10 inclusive. On each of the lines the “d” command gets executed. It deletes the current pattern space, and restarts the commands from beginning. The default action for lines &gt; 10 is to print the line.</p>
</li>
<li><p>Delete the last line of a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;$d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner restricts the “d” command to the last line of file. It’s done by specifying the special char “$” as the line to match. It matches only the last line. The last line gets deleted, but the others get printed implicitly.</p>
</li>
<li><p>Delete the last 2 lines of a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;N;$!P;$!D;$d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner always keeps two lines in the pattern space. At the very last line, it just does not output these last two. All the others before last two get output implicitly. Let’s see how it does it. As soon as sed reads the first line of input in pattern space, it executes the first command “N”. It places the 2nd line of input in pattern space. The next two commands “$!P” and “$!D” print the first part of pattern space up to newline character, and delete this part from pattern space. They keep doing it until the very last line gets appended to pattern space by “N” command. At this moment the last two lines are in pattern space and “$d” executes, deleting them both. That’s it. Last two lines got deleted.</p>
</li>
</ol>
<p>If there is just one line of data, then it outputs it.</p>
<ol start="75">
<li><p>Delete the last 10 lines of a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e :a -e &#x27;$d;N;2,10ba&#x27; -e &#x27;P;D&#x27;</span><br></pre></td></tr></table></figure>
<p>This is really straight forward one-liner. It always keeps 10 lines in pattern-space, by appending each new input line with “N”, and deleting the 11th excessive line with “D”. Once the end of file is reached, it “d” the whole pattern space, deleting the last 10 lines.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e :a -e &#x27;1,10!&#123;P;N;D;&#125;;N;ba&#x27;</span><br></pre></td></tr></table></figure>
<p>This is also a straight forward one-liner. For the lines that are not 1-10, it appends them to pattern space with “N”. For lines &gt; 10, it prints the first line in pattern space with “P”, appends another line with “N” and deletes the printed line with “D”. The “D” command causes sed to branch to the beginning of script! The “N;ba” at the end never, ever gets executed again for lines &gt; 10. It keeps looping this way “P”, “N”, “D”, always keeping 10 lines in pattern space and printing line-10 on each cycle. The “N” command causes script to quit if it tries to read past end of file.</p>
</li>
<li><p>Delete every 8th line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed &#x27;0~8d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner only works with GNU Sed only. It uses a special address range match “first~step” that matches every step’th line starting with the first. In this one-liner first is 0 and step is 8. Zero is not a valid physical line number, so the very first line of input does not match. The first line to match is 8th, then 16th, then 24th, etc. Each line that matches is deleted by “d” command.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;n;n;n;n;n;n;n;d;&#x27;</span><br></pre></td></tr></table></figure>
<p>This is a portable version. The “n” command prints the current pattern space, empties it, and reads in the next line. It does so for every 7 lines, and 8th line gets deleted with “d”. This process continues until all input has been processed.</p>
</li>
<li><p>Delete lines that match regular expression pattern.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/pattern/d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner executes the “d” command on all lines that match “&#x2F;pattern&#x2F;“. The “d” command deletes the line and skips to the next line.</p>
</li>
<li><p>Delete all blank lines in a file (emulates “grep ‘.’”.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^$/d&#x27;</span><br></pre></td></tr></table></figure>
<p>The regular expression “&#x2F;^$&#x2F;“ in this one-liner tests if the beginning of line matches the end of the line. Only the empty lines have this property and sed deletes them.</p>
</li>
</ol>
<p>Another way to do the same is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/./!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner tests if the line matches at least one character. The dot “.” in the regular expression matches any character. An empty line does not have any characters and it does not match this regular expression. Sed deletes all the lines that do not match this regular expression.</p>
<ol start="79">
<li>Delete all consecutive blank lines from a file (emulates “cat -s”).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/./,/^$/!d&#x27;</span><br></pre></td></tr></table></figure>
This one-liner leaves one blank line at the end of the file, if there are multiple blanks at the end. Other than that, all consecutive blanks are stripped.</li>
</ol>
<p>It uses an inverse range match “&#x2F;start&#x2F;,&#x2F;finish&#x2F;!” to “d” delete lines from first blank line, to first non-blank, non-inclusive.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^$/N;/\n$/D&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner leaves one blank line at the beginning and end of the file, if there are multiple blanks at both sides. Other than that, all consecutive blanks are stripped.</p>
<p>The consecutive empty lines get appended in pattern space by “&#x2F;^$&#x2F;N” command. The “&#x2F;\n$&#x2F;D” command matches and deletes blanks until only 1 is left. At that moment it no longer matches, and the line is output.</p>
<ol start="80">
<li><p>Delete all consecutive blank lines from a file except the first two.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^$/N;/\n$/N;//D&#x27;</span><br></pre></td></tr></table></figure>
<p>In case of &gt; 2 blank lines, this one-liner trims them down to two. There is a catch to this one-liner. Let me explain it first. See the last command “&#x2F;&#x2F;D”? It’s a shortcut for “&#x2F;previous-match&#x2F;D”. In this case it’s shortcut for “&#x2F;\n$&#x2F;D”. Alright, now the one-liner itself. On every empty line, it appends the next to current pattern space with “&#x2F;^$&#x2F;N” command. Next it tests if the line just read in was actually a blank line with “&#x2F;\n$&#x2F;“, if it is, it reads another line in with “N”. At this moment it repeats the same test “&#x2F;\n$&#x2F;“. If the line was a blank one again, it deletes the first blank line and restarts sed script from the beginning. Notice that at all times only 2 consecutive blank lines are in pattern space. This way any number of blank lines get deleted and only two are left.</p>
</li>
<li><p>Delete all leading blank lines at the top of a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/./,$!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner inverts a match “match from the first non-blank line to end of file”. It becomes “match from the beginning of file to last blank line”.</p>
</li>
<li><p>Delete all trailing blank lines at the end of a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e :a -e &#x27;/^\n*$/&#123;$d;N;ba&#x27; -e &#x27;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner accumulates blank lines in pattern space until it either hits end or hits a non-blank line. If it hits end, “$d” deletes the whole pattern space (which contained just the trailing blank lines) and quits. If however, it hits non-blank line, the whole pattern space gets printed implicitly and script continues as if nothing had happened.</p>
</li>
</ol>
<p>This one is a portable version.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed -e :a -e &#x27;/^\n*$/N;/\n$/ba&#x27;</span><br></pre></td></tr></table></figure>
<p>This is the same script, except a shorter version, made to work with Gnu Sed.</p>
<ol start="83">
<li><p>Delete the last line of each paragraph.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/^$/&#123;p;h;&#125;;/./&#123;x;/./p;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner always keeps the previous line in hold buffer. It’s accomplished by 2nd block of commands “&#x2F;.&#x2F;{x;&#x2F;.&#x2F;p;}”. In this block, the pattern space (1 line) gets exchanged with hold buffer (1 line) by “x” command and if the hold buffer was not empty, it gets printed by “p”. The next moment to note is what happens on the first empty line. That is the line after the paragraph. At this moment “&#x2F;^$&#x2F;{p;h;}” gets executed, that prints the blank line (but does not print the last line of paragraph!), and puts the blank line in hold buffer. Once a new paragraph is reached, the script executed just like it was the very first paragraph of the input.</p>
</li>
<li><p>Special Sed Applications</p>
</li>
<li><p>Remove nroff overstrikes.</p>
</li>
</ol>
<p>Nroff overstrikes are chars that are formatted to stand out in bold. They are achieved like in old typewriters, where you would do backspace and hit the same key again. In nroff it’s key CHAR, CTRL+H, CHAR. This one-liner deletes the CHAR, CTRL+H, leaving just plain CHAR.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/.^H//g&#x27;</span><br></pre></td></tr></table></figure>
<p>Press Ctrl+V and then Ctrl+H to insert ^H literally in sed one-liner. It then uses the substitute command to delete any char “.” followed by CTRL+H “^H”.</p>
<p>Another way to do the same is use a hex escape expression that works in most recent seds:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/.\x08//g&#x27;</span><br></pre></td></tr></table></figure>
<p>Yet another way is to use “echo” and enable interpretation of backslashed characters:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/.&#x27;`echo -e &quot;\b&quot;`&#x27;//g&#x27;</span><br></pre></td></tr></table></figure>
<ol start="85">
<li><p>Print Usenet&#x2F;HTTP&#x2F;Email message header.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed -r &#x27;/^\r?$/q&#x27;</span><br></pre></td></tr></table></figure>
<p>Usenet, HTTP and Email headers are similar. They are a bunch of text lines, separated from the body of the message with two new lines “\r\n\r\n”. Some implementations might even go with just “\n\n”. This one-liner quits on the first line that is either empty or contains “\r”. In other words, it prints the message header and quits.</p>
</li>
<li><p>Print Usenet&#x2F;HTTP&#x2F;Email message body.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1,/^$/d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses a range match “1,&#x2F;^$&#x2F;“ to delete lines starting from 1st, and ending with the first blank line (inclusive). As I explained in the previous one-liner #78 above, “&#x2F;^$&#x2F;“ matches empty lines. All the lines before first blank line in a Usenet&#x2F;Email message or a HTTP header are message headers. They get deleted.</p>
</li>
<li><p>Extract subject from an email message.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^Subject: */!d; s///; q&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner deletes all lines that do not match “^Subject: “. Then it re-uses the match in “s&#x2F;&#x2F;&#x2F;“ to delete “Subject: “ part from the line, leaving just the real subject. Please notice how “s&#x2F;&#x2F;&#x2F;“ is equivalent to “s&#x2F;previous-match&#x2F;&#x2F;“, where “previous-match” is “^Subject: *” in this one-liner.</p>
</li>
<li><p>Extract sender information from an email message.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^From: */!d; s///; q&#x27;</span><br></pre></td></tr></table></figure>
<p>This one liner is equivalent to the previous one, except it prints sender information from email.</p>
</li>
<li><p>Extract email address from a “Name Surname <a href="mailto:&#x65;&#109;&#97;&#x69;&#x6c;&#x40;&#100;&#111;&#x6d;&#x61;&#105;&#110;&#46;&#99;&#x6f;&#109;">&#x65;&#109;&#97;&#x69;&#x6c;&#x40;&#100;&#111;&#x6d;&#x61;&#105;&#110;&#46;&#99;&#x6f;&#109;</a>“ string.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/.*&lt; *//;s/ *&gt;.*//;</span><br></pre></td></tr></table></figure>
<p>This one-liner strips all symbols before &lt; symbol (and any whitespace after it), and stips all symbols after &gt; symbol (including whitespace before it). That’s it. What’s left is <a href="mailto:&#101;&#109;&#97;&#x69;&#x6c;&#64;&#100;&#x6f;&#109;&#x61;&#x69;&#x6e;&#x2e;&#x63;&#x6f;&#109;">&#101;&#109;&#97;&#x69;&#x6c;&#64;&#100;&#x6f;&#109;&#x61;&#x69;&#x6e;&#x2e;&#x63;&#x6f;&#109;</a>.</p>
</li>
<li><p>Add a leading angle bracket and space to each line (quote an email message).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/^/&gt; /&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner substitutes zero-width anchor “^” that matches beginning of line with “&gt; “. As it’s a zero-width anchor, the result is that “&gt; “ gets added to beginning of each line.</p>
</li>
<li><p>Delete leading angle bracket from each line (unquote an email message).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/^&gt; //&#x27;</span><br></pre></td></tr></table></figure>
<p>It does what it says, deletes two characters “&gt;” and a space “ “ from the beginning of each line.</p>
</li>
<li><p>Strip HTML tags.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e :a -e &#x27;s/&amp;lt;[^&gt;]*&gt;//g;/&amp;lt;/N;//ba&#x27;</span><br></pre></td></tr></table></figure>
<p>Sed is not made for parsing HTML. This is a very crude version of HTML tag eraser. It starts by creating a branch label named “a”. Then on each line it substitutes “&lt;[^&gt;]&gt;” with nothing as many times as possible (“g” flag for s&#x2F;&#x2F;&#x2F; command). The “&lt;[^&gt;]&gt;” expression means match match symbol “&lt;” followed by any other symbols that are not “&gt;”, and that ends with “&gt;”. This is a common pattern in regular expressions for non-greediness. Next, the one-liner tests if there are any open tags left on the line, if there are “N” reads the next line of input to make it work across multiple lines. “&#x2F;&#x2F;ba” finally branches to the beginning of the script (it’s short for “&#x2F;previous-expression&#x2F;ba” which in this case is “&#x2F;&lt;&#x2F;ba”).</p>
</li>
</ol>
<p>I love writing about programming and I am happy to announce my second e-book called Sed One-Liners Explained. This book is based on my popular Sed One-Liners Explained article series that has been read over 1,500,000 times.</p>
<p>I reviewed all the one-liners in the series, fixed various mistakes, greatly improved the explanations, added a bunch of new one-liners, bringing the total count to 100, and added three new chapters – an introduction to sed, a summary of sed addresses and ranges, and a chapter on debugging sed scripts with sed-sed.<br>Table of Contents</p>
<p>The e-book explains exactly 100 one-liners. It’s divided into the following chapters:</p>
<pre><code>Preface
Chapter 1: Introduction to sed
Chapter 2: Line Spacing
Chapter 3: Line Numbering
Chapter 4: Text Conversion and Substitution
Chapter 5: Selective Printing of Certain Lines
Chapter 6: Selective Deletion of Certain Lines
Chapter 1: Special sed Applications
Appendix A: Summary of All sed Commands
Appendix B: Addresses and Ranges
Appendix C: Debugging sed Scripts with sed-sed
Index
</code></pre>
<p>What’s sed?</p>
<p>Sed is the superman of UNIX stream editing. It’s a small utility that’s present on every UNIX system and it transforms one stream of text into another. Let’s take a look at several practical examples that sed can carry out easily. All these examples and many more are explained in the e-book.</p>
<p>I have also made the first chapter of the book, Introduction to sed, freely available. Please download the e-book preview to read it. The introductory chapter explains general principles of sed, introduces the four spaces of sed, addresses and ranges, and various command line flags.</p>
<p>Example 1: Replace “lamb” with “goat” on every line</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/lamb/goat/&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the famous s&#x2F;…&#x2F;…&#x2F; command. The s command substitutes the text in the first part of the command with the text in the second part. In this one-liner it replaces lamb with goat.</p>
<p>A very detailed explanation of how sed reads the lines, how it executes the commands and how the printing happens is presented in the freely available introduction chapter. Please take a look.</p>
<p>Example 2: Replace only the second occurrence of “lamb” with “goat” on every line</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/lamb/goat/2&#x27;</span><br></pre></td></tr></table></figure>
<p>Sed is the only tool that I know that takes a numeric argument to the s command. The numeric argument, in this case 2, specifies which occurrence of the text to replace. In this example only the 2nd occurrence of “lamb” gets replaced with “goat”.</p>
<p>Example 3: Number the lines in a file</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed = file | sed &#x27;N; s/\n/: /&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is actually two one-liners. The first one uses the &#x3D; command that inserts a line containing the line number before every original line in the file. Then this output gets piped to the second sed command that joins two adjacent lines with the N command. When joining lines with the N command, a newline character \n is placed between them. Therefore it uses the s command to replace this newline \n with a colon followed by a space “: “.</p>
<p>So for example, if the file contains lines:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">good job</span><br><span class="line">sunny day</span><br></pre></td></tr></table></figure>
<p>Then after running the one-liner, the result is going to be:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1: hello world</span><br><span class="line">2: good job</span><br><span class="line">3: sunny day</span><br></pre></td></tr></table></figure>
<p>Example 4: Delete every 2nd line</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;n;d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the n command that prints the current line (actually the current pattern space, see the introduction chapter for in-depth explanation), deletes it, and reads the next line. Then sed executes the d command that deletes the current line without printing. This way the 1st line gets printed, the 2nd line gets deleted, then the 3rd line gets printed again, then the 4th gets deleted, etc.</p>
<p>Example 5: ROT 13 encode every line</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;</span><br><span class="line">y/abcdefghijklmnopqrstuvwxyz/nopqrstuvwxyzabcdefghijklm/</span><br><span class="line">y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/NOPQRSTUVWXYZABCDEFGHIJKLM/</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure>
<p>Here the y&#x2F;set1&#x2F;set2&#x2F; command is used. The y command substitutes elements in the set1 with the corresponding elements in the set2. The first y command replaces all lowercase letters with their 13-char-shifted counterparts, and the second y command does the same for the uppercase letters. So for example, character a gets replaced by n, b gets replaced by o, character Z gets replaced by M, etc.</p>
<p>Sed is actually very powerful. It’s as powerful as a Turing machine, meaning you can write any computer program in it. Check out these programs written in sed. Run them as sed -f file.sed:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tetris</span><br><span class="line">Sokoban (game)</span><br><span class="line">Calculator</span><br><span class="line">Turing machine</span><br></pre></td></tr></table></figure>
<p>After you read the e-book you’ll be able to understand all these complex programs!</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://magesfc.github.io">mage</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://magesfc.github.io/mage/6a323979d022165779db1cbb3367540e235cec9e/">https://magesfc.github.io/mage/6a323979d022165779db1cbb3367540e235cec9e/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://magesfc.github.io" target="_blank">马哥私房菜</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/cookbook/">cookbook</a><a class="post-meta__tags" href="/tags/sed/">sed</a></div><div class="post_share"><div class="social-share" data-image="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/null" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/mage/428e45833de1d6977f072fa67593f8a21d9a315c/"><img class="prev-cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python学习之Primer_on_Python_Decorators</div></div></a></div><div class="next-post pull-right"><a href="/mage/2af42b0589d7a698da699f89aa9e0bbfb1825a3c/"><img class="next-cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JPA学习总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/mage/fbdc2108c9ff66cef6915dd7b0ca474e0f1bfcab/" title="Linux学习之awk学习之cookbook技巧"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之awk学习之cookbook技巧</div></div></a></div><div><a href="/mage/a718e01bee375dd72d94fd15211e2e4f41c0a52c/" title="Linux学习之bash学习之cookbook技巧"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之bash学习之cookbook技巧</div></div></a></div><div><a href="/mage/04947dc3d5b90a6c19672409e839d803a0aef01a/" title="Linux学习之perl学习之cookbook技巧"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-10</div><div class="title">Linux学习之perl学习之cookbook技巧</div></div></a></div><div><a href="/mage/bead5c222ebd755a0ea0b8165ff0663545d6c700/" title="Linux学习之10个有用的链式操作符及其实例"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之10个有用的链式操作符及其实例</div></div></a></div><div><a href="/mage/16b8c6357057536aa45c505f7c99cb9d22c87038/" title="Linux学习之awk学习之Linux-awk-command系列"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之awk学习之Linux-awk-command系列</div></div></a></div><div><a href="/mage/29b1dee9b6336ea01be4716d95ecfbad663018d6/" title="Linux学习之bash学习之几个特殊变量"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之bash学习之几个特殊变量</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mage</div><div class="author-info__description"> 这里是 马哥 的个人博客 </div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">161</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">180</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mamh2021"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mamh2021" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-1-File-Spacing-Numbering-and-Text-Conversion-and-Substitution"><span class="toc-number">1.</span> <span class="toc-text">Part 1: File Spacing, Numbering and Text Conversion and Substitution</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-File-spacing"><span class="toc-number">1.1.</span> <span class="toc-text">1. File spacing.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Numbering"><span class="toc-number">1.2.</span> <span class="toc-text">2. Numbering.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Text-Conversion-and-Substitution"><span class="toc-number">1.3.</span> <span class="toc-text">3. Text Conversion and Substitution.</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/mage/a718e01bee375dd72d94fd15211e2e4f41c0a52c/" title="Linux学习之bash学习之cookbook技巧"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux学习之bash学习之cookbook技巧"/></a><div class="content"><a class="title" href="/mage/a718e01bee375dd72d94fd15211e2e4f41c0a52c/" title="Linux学习之bash学习之cookbook技巧">Linux学习之bash学习之cookbook技巧</a><time datetime="2022-11-04T04:39:46.000Z" title="更新于 2022-11-04 12:39:46">2022-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/84776adcfbfc963bd1f2f6d5bd3fd8d22c6a46a5/" title="jenkins插件学习之show-build-parameters-plugin"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jenkins插件学习之show-build-parameters-plugin"/></a><div class="content"><a class="title" href="/mage/84776adcfbfc963bd1f2f6d5bd3fd8d22c6a46a5/" title="jenkins插件学习之show-build-parameters-plugin">jenkins插件学习之show-build-parameters-plugin</a><time datetime="2022-11-04T03:53:50.000Z" title="更新于 2022-11-04 11:53:50">2022-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/23369f1e1080d1a6749c477927cb9acccf216b36/" title="jenkins插件学习之matrix-project-plugin"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jenkins插件学习之matrix-project-plugin"/></a><div class="content"><a class="title" href="/mage/23369f1e1080d1a6749c477927cb9acccf216b36/" title="jenkins插件学习之matrix-project-plugin">jenkins插件学习之matrix-project-plugin</a><time datetime="2022-11-04T03:53:32.000Z" title="更新于 2022-11-04 11:53:32">2022-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/f69d2317dbb9ce1dbfccbd61f81a402200d7547f/" title="jenkins插件学习之job-parameter-summary-plugin"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jenkins插件学习之job-parameter-summary-plugin"/></a><div class="content"><a class="title" href="/mage/f69d2317dbb9ce1dbfccbd61f81a402200d7547f/" title="jenkins插件学习之job-parameter-summary-plugin">jenkins插件学习之job-parameter-summary-plugin</a><time datetime="2022-11-04T03:53:14.000Z" title="更新于 2022-11-04 11:53:14">2022-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/dd153582d58799584987955d6355cf3c32f1bc7f/" title="jenkins插件学习之hidden-parameter-plugin"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jenkins插件学习之hidden-parameter-plugin"/></a><div class="content"><a class="title" href="/mage/dd153582d58799584987955d6355cf3c32f1bc7f/" title="jenkins插件学习之hidden-parameter-plugin">jenkins插件学习之hidden-parameter-plugin</a><time datetime="2022-11-04T03:52:57.000Z" title="更新于 2022-11-04 11:52:57">2022-11-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By mage</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>