<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linuxå­¦ä¹ ä¹‹sedå­¦ä¹ ä¹‹cookbookæŠ€å·§ | é©¬å“¥ç§æˆ¿èœ</title><meta name="author" content="mage"><meta name="copyright" content="mage"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="sed ä¸€è¡Œå‘½ä»¤ è§£é‡Š Sed One-Liners Explained,  https:&#x2F;&#x2F;catonmat.net&#x2F;sed-one-liners-explained-part-one åœ¨å¼€å§‹è§£é‡Šä¹‹å‰ï¼Œæˆ‘æƒ³åˆ†äº«ä¸€ä¸‹æ”¹å˜æˆ‘å¯¹ sed çš„çœ‹æ³•çš„å…³é”®æ€æƒ³ã€‚å®ƒæ˜¯ sed çš„å››ä¸ªå†…å­˜ç©ºé—´â€”â€”è¾“å…¥æµã€è¾“å‡ºæµã€æ¨¡å¼ç©ºé—´ã€ä¿æŒç¼“å†²åŒºã€‚input stream, output stream, pattern sp">
<meta property="og:type" content="article">
<meta property="og:title" content="Linuxå­¦ä¹ ä¹‹sedå­¦ä¹ ä¹‹cookbookæŠ€å·§">
<meta property="og:url" content="https://magesfc.github.io/mage/6a323979d022165779db1cbb3367540e235cec9e/">
<meta property="og:site_name" content="é©¬å“¥ç§æˆ¿èœ">
<meta property="og:description" content="sed ä¸€è¡Œå‘½ä»¤ è§£é‡Š Sed One-Liners Explained,  https:&#x2F;&#x2F;catonmat.net&#x2F;sed-one-liners-explained-part-one åœ¨å¼€å§‹è§£é‡Šä¹‹å‰ï¼Œæˆ‘æƒ³åˆ†äº«ä¸€ä¸‹æ”¹å˜æˆ‘å¯¹ sed çš„çœ‹æ³•çš„å…³é”®æ€æƒ³ã€‚å®ƒæ˜¯ sed çš„å››ä¸ªå†…å­˜ç©ºé—´â€”â€”è¾“å…¥æµã€è¾“å‡ºæµã€æ¨¡å¼ç©ºé—´ã€ä¿æŒç¼“å†²åŒºã€‚input stream, output stream, pattern sp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg">
<meta property="article:published_time" content="2022-02-23T09:47:21.000Z">
<meta property="article:modified_time" content="2022-05-10T11:00:59.000Z">
<meta property="article:author" content="mage">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="cookbook">
<meta property="article:tag" content="sed">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg"><link rel="shortcut icon" href="http://www.blackshark.com/favicon.ico"><link rel="canonical" href="https://magesfc.github.io/mage/6a323979d022165779db1cbb3367540e235cec9e/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: 'å¤åˆ¶æˆåŠŸ',
    error: 'å¤åˆ¶é”™è¯¯',
    noSupport: 'æµè§ˆå™¨ä¸æ”¯æŒ'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'å¤©',
  date_suffix: {
    just: 'åˆšåˆš',
    min: 'åˆ†é’Ÿå‰',
    hour: 'å°æ—¶å‰',
    day: 'å¤©å‰',
    month: 'ä¸ªæœˆå‰'
  },
  copyright: {"limitCount":150,"languages":{"author":"ä½œè€…: mage","link":"é“¾æ¥: ","source":"æ¥æº: é©¬å“¥ç§æˆ¿èœ","info":"è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linuxå­¦ä¹ ä¹‹sedå­¦ä¹ ä¹‹cookbookæŠ€å·§',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-10 19:00:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">.card-announcement .social-button{margin:.6rem 0 0 0;text-align:center}.card-announcement .social-button a{display:block;background-color:var(--btn-bg);color:var(--btn-color);text-align:center;line-height:2.4;margin:4px 0}.card-announcement .social-button a:hover{background-color:var(--btn-hover-color)}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">æ–‡ç« </div><div class="length-num">161</div></a><a href="/tags/"><div class="headline">æ ‡ç­¾</div><div class="length-num">180</div></a><a href="/categories/"><div class="headline">åˆ†ç±»</div><div class="length-num">34</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> é¦–é¡µ</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> ç›®å½•</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> å½’æ¡£</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> æ ‡ç­¾</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> åˆ†ç±»</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> ç²¾é€‰æ–‡æ¡£</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> ğŸš€ å¿«é€Ÿå¼€å§‹</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/dc584b87/"><span> ğŸ“‘ ä¸»é¢˜é¡µé¢</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4aa8abbe/"><span> ğŸ›  ä¸»é¢˜é…ç½®-1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/ceeb73f/"><span> ğŸ›  ä¸»é¢˜é…ç½®-2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/98d20436/"><span> â“ ä¸»é¢˜é—®ç­”</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4073eda/"><span> âš¡ï¸ è¿›é˜¶æ•™ç¨‹</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/198a4240/"><span> âœ¨ æ›´æ–°æ—¥å¿—</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://butterfly.js.org/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> å…¶ä»–ç¤ºä¾‹</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> å…³äº</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">é©¬å“¥ç§æˆ¿èœ</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> é¦–é¡µ</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> ç›®å½•</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> å½’æ¡£</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> æ ‡ç­¾</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> åˆ†ç±»</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> ç²¾é€‰æ–‡æ¡£</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> ğŸš€ å¿«é€Ÿå¼€å§‹</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/dc584b87/"><span> ğŸ“‘ ä¸»é¢˜é¡µé¢</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4aa8abbe/"><span> ğŸ›  ä¸»é¢˜é…ç½®-1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/ceeb73f/"><span> ğŸ›  ä¸»é¢˜é…ç½®-2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/98d20436/"><span> â“ ä¸»é¢˜é—®ç­”</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4073eda/"><span> âš¡ï¸ è¿›é˜¶æ•™ç¨‹</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/198a4240/"><span> âœ¨ æ›´æ–°æ—¥å¿—</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://butterfly.js.org/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> å…¶ä»–ç¤ºä¾‹</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> å…³äº</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linuxå­¦ä¹ ä¹‹sedå­¦ä¹ ä¹‹cookbookæŠ€å·§</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">å‘è¡¨äº</span><time class="post-meta-date-created" datetime="2022-02-23T09:47:21.000Z" title="å‘è¡¨äº 2022-02-23 17:47:21">2022-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">æ›´æ–°äº</span><time class="post-meta-date-updated" datetime="2022-05-10T11:00:59.000Z" title="æ›´æ–°äº 2022-05-10 19:00:59">2022-05-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/">linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linuxå­¦ä¹ ä¹‹sedå­¦ä¹ ä¹‹cookbookæŠ€å·§"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">é˜…è¯»é‡:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>sed ä¸€è¡Œå‘½ä»¤ è§£é‡Š</p>
<p>Sed One-Liners Explained,  <a target="_blank" rel="noopener" href="https://catonmat.net/sed-one-liners-explained-part-one">https://catonmat.net/sed-one-liners-explained-part-one</a></p>
<p>åœ¨å¼€å§‹è§£é‡Šä¹‹å‰ï¼Œæˆ‘æƒ³åˆ†äº«ä¸€ä¸‹æ”¹å˜æˆ‘å¯¹ sed çš„çœ‹æ³•çš„å…³é”®æ€æƒ³ã€‚<br>å®ƒæ˜¯ sed çš„å››ä¸ªå†…å­˜ç©ºé—´â€”â€”è¾“å…¥æµã€è¾“å‡ºæµã€æ¨¡å¼ç©ºé—´ã€ä¿æŒç¼“å†²åŒºã€‚<br>input stream, output stream, pattern space, hold buffer</p>
<p>Sed å¯¹è¾“å…¥æµè¿›è¡Œæ“ä½œå¹¶äº§ç”Ÿä¸€ä¸ªè¾“å‡ºæµã€‚è¾“å…¥æµä¸­çš„è¡Œè¢«æ”¾å…¥æ¨¡å¼ç©ºé—´ï¼ˆå¯ä»¥ä¿®æ”¹å®ƒä»¬ï¼‰ï¼Œç„¶åæ¨¡å¼ç©ºé—´è¢«å‘é€åˆ°è¾“å‡ºæµã€‚<br>ä¿æŒç¼“å†²åŒºå¯ç”¨äºä¸´æ—¶å­˜å‚¨ã€‚è¿™å››ä¸ªç©ºæ ¼å®Œå…¨æ”¹å˜äº†æˆ‘å¯¹ sed çš„çœ‹æ³•ã€‚é€šè¿‡æœ¬æ–‡ä¸­çš„ç¤ºä¾‹ï¼Œæ‚¨å°†äº†è§£æ‰€æœ‰æœ‰å…³å®ƒä»¬çš„ä¿¡æ¯ã€‚</p>
<h1 id="Part-1-File-Spacing-Numbering-and-Text-Conversion-and-Substitution"><a href="#Part-1-File-Spacing-Numbering-and-Text-Conversion-and-Substitution" class="headerlink" title="Part 1: File Spacing, Numbering and Text Conversion and Substitution"></a>Part 1: File Spacing, Numbering and Text Conversion and Substitution</h1><h2 id="1-File-spacing"><a href="#1-File-spacing" class="headerlink" title="1. File spacing."></a>1. File spacing.</h2><p>1.Double-space a file.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed G</span><br></pre></td></tr></table></figure>
<p>è¿™ä¸ªGå‘½ä»¤ä¼šç»™æ¯è¡Œåé¢éƒ½æ·»åŠ ä¸€ä¸ªæ–°çš„æ¢è¡Œã€‚</p>
<p>This sed one-liner uses the G command. If you grabbed my cheat sheet youâ€™ll see that G appends a newline followed by the contents of hold buffer to pattern space. In this example the hold buffer is empty all the time (only three commands h, H and x modify hold buffer), so we end up simply appending a newline to the pattern space. Once all the commands have been executed (in this case just the G command), sed puts the contents of pattern space to output stream followed by a newline. And there we have it. Every line now is followed by two newlines â€“ one added by the G command and the other by output stream. File has been double spaced.</p>
<p>è¿™ä¸ª sed one-liner ä½¿ç”¨ G å‘½ä»¤ã€‚ å¦‚æœä½ æŠ“ä½äº†æˆ‘çš„å¤‡å¿˜å•ï¼Œä½ ä¼šçœ‹åˆ° G åœ¨æ¨¡å¼ç©ºé—´ä¸­æ·»åŠ äº†ä¸€ä¸ªæ¢è¡Œç¬¦ï¼Œåè·Ÿä¿æŒç¼“å†²åŒºçš„å†…å®¹ã€‚ åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œä¿æŒç¼“å†²åŒºä¸€ç›´æ˜¯ç©ºçš„ï¼ˆåªæœ‰ä¸‰ä¸ªå‘½ä»¤ hã€H å’Œ x ä¿®æ”¹äº†ä¿æŒç¼“å†²åŒºï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ€ç»ˆåªæ˜¯ç®€å•åœ°å°†æ¢è¡Œç¬¦é™„åŠ åˆ°æ¨¡å¼ç©ºé—´ã€‚ ä¸€æ—¦æ‰€æœ‰çš„å‘½ä»¤éƒ½è¢«æ‰§è¡Œï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹åªæ˜¯ G å‘½ä»¤ï¼‰ï¼Œsed å°†æ¨¡å¼ç©ºé—´çš„å†…å®¹æ”¾åˆ°è¾“å‡ºæµä¸­ï¼Œç„¶åæ˜¯ä¸€ä¸ªæ¢è¡Œç¬¦ã€‚ æˆ‘ä»¬ç»ˆäºå¾—åˆ°å®ƒäº†ã€‚ ç°åœ¨æ¯ä¸€è¡Œåé¢éƒ½æœ‰ä¸¤ä¸ªæ¢è¡Œç¬¦â€”â€”ä¸€ä¸ªç”± G å‘½ä»¤æ·»åŠ ï¼Œå¦ä¸€ä¸ªç”±è¾“å‡ºæµæ·»åŠ ã€‚ æ–‡ä»¶æ˜¯åŒå€è¡Œè·çš„ã€‚</p>
<p>2.æ¯è¡Œåä»…åŠ ä¸Šä¸€ä¸ªç©ºè¡Œ</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/^$/d;G&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>è¿™ä¸ªæ˜¯å…ˆåˆ é™¤æ–‡ä»¶ä¸­çš„ç©ºè¡Œï¼Œç„¶ååœ¨æ¯è¡Œåé¢éƒ½åŠ ä¸Šæ–°çš„ç©ºè¡Œã€‚  &#x2F;^$&#x2F;è¿™ä¸ªæ˜¯ä¸€ä¸ªåŒ¹é…æ¨¡å¼ï¼ŒåŒ¹é…empty linesã€‚</p>
<p>Sed allows to restrict commands only to certain lines. This one-liner operates only on lines that match the regular expression &#x2F;^$&#x2F;. What are those lines? Those are the empty lines. Note that before doing the regular expression match, sed pushes the input line to pattern space. When doing it, sed strips the trailing newline character. The empty lines contain just the newline character, so after they have been put into pattern space, this only character has been removed and pattern space stays empty. Regular expression &#x2F;^$&#x2F; matches an empty pattern space and sed applies d command on it, which deletes the current pattern space, reads in the next line, puts it into the pattern space and aborts the current command, and starts the execution from the beginning. The lines which do not match emptiness get a newline character appended by the G command, just like in one-liner #1.</p>
<p>In general sed allows to restrict operations to certain lines (5th, 27th, etc.), to a range of lines (lines 10-20), to lines matching a pattern (lines containing the word â€œcatonmatâ€), and to lines between two patterns (lines between â€œcatonmatâ€ and â€œcodersâ€). Youâ€™ll learn about this soon.<br>Sed å…è®¸å°†å‘½ä»¤é™åˆ¶åœ¨æŸäº›è¡Œã€‚è¿™ä¸ªå•è¡Œåªå¯¹åŒ¹é…æ­£åˆ™è¡¨è¾¾å¼ &#x2F;^$&#x2F; çš„è¡Œèµ·ä½œç”¨ã€‚å“ªäº›è¡Œï¼Ÿè¿™äº›ç©ºè¡Œã€‚è¯·æ³¨æ„ï¼Œåœ¨è¿›è¡Œæ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ä¹‹å‰ï¼Œsed ä¼šå°†è¾“å…¥è¡Œæ¨é€åˆ°æ¨¡å¼ç©ºé—´ã€‚æ‰§è¡Œæ­¤æ“ä½œæ—¶ï¼Œsed ä¼šå»é™¤å°¾éšçš„æ¢è¡Œç¬¦ã€‚ç©ºè¡ŒåªåŒ…å«æ¢è¡Œç¬¦ï¼Œå› æ­¤åœ¨å®ƒä»¬è¢«æ”¾å…¥æ¨¡å¼ç©ºé—´åï¼Œè¿™ä¸ªå”¯ä¸€çš„å­—ç¬¦å·²è¢«åˆ é™¤ï¼Œæ¨¡å¼ç©ºé—´ä¿æŒä¸ºç©ºã€‚æ­£åˆ™è¡¨è¾¾å¼ &#x2F;^$&#x2F; åŒ¹é…ä¸€ä¸ªç©ºçš„æ¨¡å¼ç©ºé—´å¹¶ sed å¯¹å…¶åº”ç”¨ d å‘½ä»¤ï¼Œè¿™ä¼šåˆ é™¤å½“å‰æ¨¡å¼ç©ºé—´ï¼Œè¯»å…¥ä¸‹ä¸€è¡Œï¼Œå°†å…¶æ”¾å…¥æ¨¡å¼ç©ºé—´å¹¶ä¸­æ­¢å½“å‰å‘½ä»¤ï¼Œå¹¶ä»å¼€å§‹ã€‚ä¸ç©ºè¡Œä¸åŒ¹é…çš„è¡Œå¾—åˆ°ä¸€ä¸ªç”± G å‘½ä»¤é™„åŠ çš„æ¢è¡Œç¬¦ï¼Œå°±åƒåœ¨å•è¡Œ#1 ä¸­ä¸€æ ·ã€‚</p>
<p>ä¸€èˆ¬æ¥è¯´ï¼Œsed å…è®¸å°†æ“ä½œé™åˆ¶åœ¨æŸäº›è¡Œï¼ˆç¬¬ 5ã€27 ç­‰ï¼‰ã€ä¸€ç³»åˆ—è¡Œï¼ˆç¬¬ 10-20 è¡Œï¼‰ã€åŒ¹é…æ¨¡å¼çš„è¡Œï¼ˆåŒ…å«å•è¯â€œcatonmatâ€çš„è¡Œï¼‰ï¼Œä»¥åŠä¹‹é—´çš„è¡Œä¸¤ç§æ¨¡å¼ï¼ˆâ€œcatonmatâ€å’Œâ€œcodersâ€ä¹‹é—´çš„è¡Œï¼‰ã€‚æ‚¨å¾ˆå¿«å°±ä¼šäº†è§£è¿™ä¸€ç‚¹ã€‚</p>
<p>3.Triple-space a file.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;G;G&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Several sed commands can be combined by separating them with ; symbol. Such commands get executed one after another. This one-liner does twice what the one-liner #1 does â€“ appends two newlines (via two G commands) to output.</p>
<p>4.Undo double-spacing.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;n;d&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>This one-liner assumes that even-numbered lines are always blank. It uses two new commands â€“ n and d. The n command prints out the current pattern space (unless the -n flag has been specified), empties the current pattern space and reads in the next line of input. We assumed that even-numbered lines are always blank. This means that â€˜nâ€™ prints the first, third, fifth, â€¦, etc. line and reads in the following line. The line following the printed line is always an empty line. Now the â€˜dâ€™ command gets executed. The â€˜dâ€™ command deletes the current pattern space, reads in the next line, puts the new line into the pattern space and aborts the current command, and starts the execution from the first sed command. Now the the â€˜nâ€™ commands gets executed again, then â€˜dâ€™, then â€˜nâ€™, etc.</p>
<p>To make it shorter - â€˜nâ€™ prints out the current line, and â€˜dâ€™ deletes the empty line, thus undoing the double-spacing.</p>
<p>5.Insert a blank line above every line that matches â€œregexâ€.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/regex/&#123;x;p;x;&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one liner uses the restriction operation together with two new commands - â€˜xâ€™ and â€˜pâ€™. The â€˜xâ€™ command exchanges the hold buffer with the pattern buffer. The â€˜pâ€™ command duplicates input â€“ prints out the entire pattern space. This one-liner works the following way: a line is read in pattern space, then the â€˜xâ€™ command exchanges it with the empty hold buffer. Next the â€˜pâ€™ command prints out emptiness followed by a newline, so we get an empty line printed before the actual line. Then â€˜xâ€™ exchanges the hold buffer (which now contains the line) with pattern space again. There are no more commands so sed prints out the pattern space. We have printed a newline followed by the line, or saying it in different words, inserted a blank line above every line.</p>
<p>Also notice the { â€¦ }. This is command grouping. It says, execute all the commands in â€œâ€¦â€ on the line that matches the restriction operation.</p>
<p>6 Insert a blank line below every line that matches â€œregexâ€.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/regex/G&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one liner combines restriction operation with the â€˜Gâ€™ command, described in one-liner #1. For every line that matches &#x2F;regex&#x2F;, sed appends a newline to pattern space. All the other lines that do not match &#x2F;regex&#x2F; just get printed out without modification.</p>
<p>7.Insert a blank line above and below every line that matches â€œregexâ€.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/regex/&#123;x;p;x;G;&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner combines one-liners #5, #6 and #1. Lines matching &#x2F;regex&#x2F; get a newline appended before them and printed (x;p;x from #5). Then they are followed by another newline from the â€˜Gâ€™ command (one-liner #6 or #1).</p>
<h2 id="2-Numbering"><a href="#2-Numbering" class="headerlink" title="2. Numbering."></a>2. Numbering.</h2><p>8.Number each line of a file (named filename). Left align the number.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed = filename | sed <span class="string">&#x27;N;s/\n/\t/&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>One-liners get trickier and trickier. This one-liner is actually two separate one-liners. The first sed one-liner uses a new command called â€˜&#x3D;â€™. This command operates directly on the output stream and prints the current line number. There is no way to capture the current line number to pattern space. Thatâ€™s why the second one-liner gets called. The output of first one-liner gets piped to the input of second. The second one-liner uses another new command â€˜Nâ€™. The â€˜Nâ€™ command appends a newline and the next line to current pattern space. Then the famous â€˜s&#x2F;&#x2F;&#x2F;â€˜ command gets executed which replaces the newline character just appended with a tab. After these operations the line gets printed out.</p>
<p>To make it clear what â€˜&#x3D;â€™ does, take a look at this example file:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line one</span><br><span class="line">line two</span><br><span class="line">line three</span><br></pre></td></tr></table></figure>
<p>Running the first one-liner â€˜sed &#x3D; filenameâ€™, produces output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">line one</span><br><span class="line">2</span><br><span class="line">line two</span><br><span class="line">3</span><br><span class="line">line three</span><br></pre></td></tr></table></figure>
<p>Now, the â€˜Nâ€™ command of the second one-liner joins these lines with a newline character:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1\nline one</span><br><span class="line">2\nline two</span><br><span class="line">3\nline three</span><br></pre></td></tr></table></figure>
<p>The â€˜s&#x2F;\n&#x2F;\t&#x2F;â€˜ replaces the newline chars with tabs, so we end up with:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1     line one</span><br><span class="line">2     line two</span><br><span class="line">3     line three</span><br></pre></td></tr></table></figure>
<p>The example is a little inaccurate as line joining with a newline char happens line after line, not on all lines at once.</p>
<p>9.Number each line of a file (named filename). Right align the number.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sed = filename | sed <span class="string">&#x27;N; s/^/     /; s/ *\(.\&#123;6,\&#125;\)\n/\1  /&#x27;</span></span><br></pre></td></tr></table></figure>

<p>This one-liner is also actually two one-liners. The first one liner numbers the lines, just like #8. The second one-liner uses the â€˜Nâ€™ command to join the line containing the line number with the actual line. Then it uses two substitute commands to right align the number. The first â€˜sâ€™ command â€˜s&#x2F;^&#x2F; &#x2F;â€˜ appends 5 white-spaces to the beginning of line. The second â€˜sâ€™ command â€˜s&#x2F; *(.{6,})\n&#x2F;\1 &#x2F;â€˜ captures at least six symbols up to a newline and replaces the capture and newline with the back-reference â€˜\1â€™ and two more whitespace to separate line number from the contents of line.</p>
<p>I think itâ€™s hard to understand the last part of this sed expression by just reading. Letâ€™s look at an example. For clearness I replaced the â€˜\nâ€™ newline char with a â€˜@â€™ and whitespace with â€˜-â€˜.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;-----12@contents&quot; | sed &#x27;s/-*\(.\&#123;6,\&#125;\)@/\1--/&#x27;</span><br><span class="line">----12--contents</span><br></pre></td></tr></table></figure>
<p>The regular expression â€˜-(.{6,})@â€™ (or just â€˜-(.{6,})@â€™) tells sed to match some â€˜-â€˜ characters followed by at least 6 other characters, followed by a â€˜@â€™ symbol. Sed captures them (remembers them) in \1.</p>
<p>In this example sed matches the first â€˜-â€˜ (the â€˜-â€˜ part of regex), then the following six characters â€œâ€”-12â€ and â€˜@â€™ (the â€˜(.{6,})@â€™ part of regex). Now it replaces the matched part of the string â€œ-----12@â€ with the contents of captured group which is â€œâ€”-12â€ plus two extra whitespace. The final result is that â€œ-----12@â€ gets replaced with â€œâ€”-12â€“â€.</p>
<p>10.Number each non-empty line of a file (called filename).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/./=&#x27;</span> filename | sed <span class="string">&#x27;/./N; s/\n/ /&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner is again two one-liners. The output of the first one-liner gets piped to the input of second. The first one-liner filters out lines with at least one character in them. The regular expression â€˜&#x2F;.&#x2F;â€˜ says: match lines with at least one char in them. When the empty lines (containing just a newline) get sent to the pattern space, the newline character gets removed, so the empty lines do not get matched. The second one-liner does the same one-liner #8 did, except that only numbered lines get joined and printed out. Command â€˜&#x2F;.&#x2F;Nâ€™ makes sure that empty lines are left as-is.</p>
<p>11.Count the number of lines in a file (emulates â€œwc -lâ€).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;$=&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner uses a command line switch â€œ-nâ€ to modify sedâ€™s behavior. The â€œ-nâ€ switch tells sed not to send the line to output after it has been processed in the pattern space. The only way to make sed output anything with the â€œ-nâ€ switch being on is to use a command that modifies the output stream directly (these commands are â€˜&#x3D;â€™, â€˜aâ€™, â€˜câ€™, â€˜iâ€™, â€˜Iâ€™, â€˜pâ€™, â€˜Pâ€™, â€˜râ€™ and â€˜wâ€™). In this one-liner what seems to be the command â€œ$&#x3D;â€ is actually a restriction pattern â€œ$â€ together with the â€œ&#x3D;â€ command. The restriction pattern â€œ$â€ applies the â€œ&#x3D;â€ command to the last line only. The â€œ&#x3D;â€ command outputs the current line number to standard output. As it is applied to the last line only, this one-liner outputs the number of lines in the file.</p>
<h2 id="3-Text-Conversion-and-Substitution"><a href="#3-Text-Conversion-and-Substitution" class="headerlink" title="3. Text Conversion and Substitution."></a>3. Text Conversion and Substitution.</h2><p>12.Convert DOS&#x2F;Windows newlines (CRLF) to Unix newlines (LF).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/.$//&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-one liner assumes that all lines end with CR+LF (carriage return + line feed) and we are in a Unix environment. Once the line gets read into pattern space, the newline gets thrown away, so we are left with lines ending in CR. The â€˜s&#x2F;.$&#x2F;&#x2F;â€˜ command erases the last character by matching the last character of the line (regex â€˜.$â€™) and substituting it with nothing. Now when the pattern space gets output, it gets appended the newline and we are left with lines ending with LF.</p>
<p>The assumption about being in a Unix environment is necessary because the newline that gets appended when the pattern space gets copied to output stream is the newline of that environment.</p>
<p>13.Another way to convert DOS&#x2F;Windows newlines (CRLF) to Unix newlines (LF).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/^M$//&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner again assumes that we are in a Unix environment. It erases the carriage return control character ^M. You can usually enter the ^M control char literally by first pressing Ctrl-V (itâ€™s control key + v key) and then Ctrl-M.</p>
<p>14.Yet another way to convert DOS&#x2F;Windows newlines to Unix newlines.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sed <span class="string">&#x27;s/\x0D$//&#x27;</span></span><br></pre></td></tr></table></figure>
<p>This one-liner assumes that we are on a Unix machine. It also assumes that we use a version of sed that supports hex escape codes, such as GNU sed. The hex value for CR is 0x0D (13 decimal). This one-liner erases this character.</p>
<p>15-17. Convert Unix newlines (LF) to DOS&#x2F;Windows newlines (CRLF).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sed <span class="string">&quot;s/$/`echo -e \\\r`/&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>This one-liner also assumes that we are in a Unix environment. It calls shell for help. The â€˜echo -e \râ€™ command inserts a literal carriage return character in the sed expression. The sed â€œs&#x2F;$&#x2F;char&#x2F;â€œ command appends a character to the end of current pattern space.</p>
<p>18.Another way to convert Unix newlines (LF) to DOS&#x2F;Windows newlines (CRLF).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/$/\r/&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner assumes that we use GNU sed. GNU sed is smarter than other seds and can take escape characters in the replace part of s&#x2F;&#x2F;&#x2F; command.</p>
<p>19.Convert Unix newlines (LF) to DOS&#x2F;Windows newlines (CRLF) from DOS&#x2F;Windows.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&quot;s/$//&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner works from DOS&#x2F;Windows. Itâ€™s basically a no-op one-liner. It replaces nothing with nothing and then sends out the line to output stream where it gets CRLF appended.</p>
<p>20.Another way to convert Unix newlines (LF) to DOS&#x2F;Windows newlines (CRLF) from DOS&#x2F;Windows.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -n p</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This is also a no-op one-liner, just like #19. The shortest one-liner which does the same is:</p>
<p>21.Convert DOS&#x2F;Windows newlines (LF) to Unix format (CRLF) from DOS&#x2F;Windows.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&quot;s/\r//&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Eric says that this one-liner works only with UnxUtils sed v4.0.7 or higher. I donâ€™t know anything about this version of sed, so letâ€™s just trust him. This one-liner strips carriage return (CR) chars from lines. Then when they get output, CRLF gets appended by magic.</p>
<p>Eric mentions that the only way to convert LF to CRLF on a DOS machine is to use tr:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr -d \r &amp;lt;infile &amp;gt;outfile</span><br></pre></td></tr></table></figure>

<p>22.Delete leading whitespace (tabs and spaces) from each line.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/^[ \t]*//&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Pretty simple, it matches zero-or-more spaces and tabs at the beginning of the line and replaces them with nothing, i.e. erases them.</p>
<p>23.Delete trailing whitespace (tabs and spaces) from each line.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/[ \t]*$//&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner is very similar to #22. It does the same substitution, just matching zero-or-more spaces and tabs at the end of the line, and then erases them.</p>
<p>24.Delete both leading and trailing whitespace from each line.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/^[ \t]*//;s/[ \t]*$//&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one liner combines #22 and #23. First it does what #22 does, erase the leading whitespace, and then it does the same as #23, erase trailing whitespace.</p>
<p>25.Insert five blank spaces at the beginning of each line.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/^/     /&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>It does it by matching the null-string at the beginning of line (^) and replaces it with five spaces â€œ     â€œ.</p>
<p>26.Align lines right on a 79-column width.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sed -e :a -e <span class="string">&#x27;s/^.\&#123;1,78\&#125;$/ &amp;/;ta&#x27;</span></span><br></pre></td></tr></table></figure>
<p>This one-liner uses a new command line option and two new commands. The new command line option is â€˜-eâ€™. It allows to write a sed program in several parts. For example, a sed program with two substitution rules could be written as â€œsed -e â€˜s&#x2F;one&#x2F;two&#x2F;â€˜ -e â€˜s&#x2F;three&#x2F;fourâ€™â€ instead of â€œsed â€˜s&#x2F;one&#x2F;two&#x2F;;s&#x2F;three&#x2F;fourâ€™â€. It makes it more readable. In this one-liner the first â€œ-eâ€ creates a label called â€œaâ€. The â€˜:â€™ command followed by a name crates a named label. The second â€œ-eâ€ uses a new command â€œtâ€. The â€œtâ€ command branches to a named label if the last substitute command modified pattern space. This branching technique can be used to create loops in sed. In this one-liner the substitute command left-pads the string (right aligns it) a single whitespace at a time, until the total length of the string exceeds 78 chars. The â€œ&amp;â€ in substitution command means the matched string.</p>
<p>Translating it in modern language, it would look like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (str.length() &lt;= 78) &#123;</span><br><span class="line"> str = &quot; &quot; + str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>27.Center all text in the middle of 79-column width.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed  -e :a -e <span class="string">&#x27;s/^.\&#123;1,77\&#125;$/ &amp; /;ta&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner is very similar to #26, but instead of left padding the line one whitespace character at a time it pads it on both sides until it has reached length of at least 77 chars. Then another two whitespaces get added at the last iteration and it has grown to 79 chars.</p>
<p>Another way to do the same is</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed  -e :a -e &#x27;s/^.\&#123;1,77\&#125;$/ &amp;/;ta&#x27; -e &#x27;s/\( *\)\1/\1/&#x27;</span><br></pre></td></tr></table></figure>

<p>This one-liner left pads the string one whitespace char at a time until it has reached length of 78 characters. Then the additional â€œs&#x2F;( *)\1&#x2F;\1&#x2F;â€œ command gets executed which divides the leading whitespace â€œin halfâ€. This effectively centers the string. Unlike the previous one-liner this one-liner does not add trailing whitespace. It just adds enough leading whitespace to center the string.</p>
<p>28.Substitute (find and replace) the first occurrence of â€œfooâ€ with â€œbarâ€ on each line.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/foo/bar/&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This is the simplest sed one-liner possible. It uses the substitute command and applies it once on each line. It substitutes string â€œfooâ€ with â€œbarâ€.</p>
<p>29.Substitute (find and replace) the fourth occurrence of â€œfooâ€ with â€œbarâ€ on each line.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sed <span class="string">&#x27;s/foo/bar/4&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner uses a flag for the substitute command. With no flags the first occurrence of pattern is changed. With a numeric flag like â€œ&#x2F;1â€, â€œ&#x2F;2â€, etc. only that occurrence is substituted. This one-liner uses numeric flag â€œ&#x2F;4â€ which makes it change fourth occurrence on each line.</p>
<p>30.Substitute (find and replace) all occurrence of â€œfooâ€ with â€œbarâ€ on each line.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sed <span class="string">&#x27;s/foo/bar/g&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner uses another flag. The â€œ&#x2F;gâ€ flag which stands for global. With global flag set, substitute command does as many substitutions as possible, i.e., all.</p>
<p>31.Substitute (find and replace) the first occurrence of a repeated occurrence of â€œfooâ€ with â€œbarâ€.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/\(.*\)foo\(.*foo\)/\1bar\2/&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Letâ€™s understand this one-liner with an example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;this is foo and another foo quux&quot; | sed &#x27;s/\(.*\)foo\(.*foo\)/\1bar\2/&#x27;</span><br><span class="line">this is bar and another foo quux</span><br></pre></td></tr></table></figure>
<p>As you can see, this one liner replaced the first â€œfooâ€ with â€œbarâ€.</p>
<p>It did it by using two capturing groups. The first capturing group caught everything before the first â€œfooâ€. In this example it was text â€œthis is â€œ. The second group caught everything after the first â€œfooâ€, including the second â€œfooâ€. In this example â€œ and another fooâ€. The matched text was then replaced with contents of first group â€œthis is â€œ followed by â€œbarâ€ and contents of second group â€œ and another fooâ€. Since â€œ quuxâ€ was not part of the match it was left unchanged. Joining these parts the resulting string is â€œthis is bar and another foo quuxâ€, which is exactly what we got from running the one-liner.</p>
<p>32.Substitute (find and replace) only the last occurrence of â€œfooâ€ with â€œbarâ€.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/\(.*\)foo/\1bar/&#x27;</span></span><br></pre></td></tr></table></figure>
<p>This one-liner uses a capturing group that captures everything up to â€œfooâ€. It replaces the captured group and â€œfooâ€ with captured group itself (the \1 back-reference) and â€œbarâ€. It results in the last occurrence of â€œfooâ€ getting replaced with â€œbarâ€.</p>
<p>33.Substitute all occurrences of â€œfooâ€ with â€œbarâ€ on all lines that contain â€œbazâ€.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/baz/s/foo/bar/g&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner uses a regular expression to restrict the substitution to lines matching â€œbazâ€. The lines that do not match â€œbazâ€ get simply printed out, but those that do match â€œbazâ€ get the substitution applied.</p>
<p>34.Substitute all occurrences of â€œfooâ€ with â€œbarâ€ on all lines that DO NOT contain â€œbazâ€.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/baz/!s/foo/bar/g&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Sed commands can be inverted and applied on lines that DO NOT match a certain pattern. The exclamation â€œ!â€ before a sed commands does it. In this one-liner the substitution command is applied to the lines that DO NOT match â€œbazâ€.</p>
<p>35.Change text â€œscarletâ€, â€œrubyâ€ or â€œpuceâ€ to â€œredâ€.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/scarlet/red/g;s/ruby/red/g;s/puce/red/g&#x27;</span></span><br><span class="line"></span><br><span class="line">gsed <span class="string">&#x27;s/scarlet\|ruby\|puce/red/g&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This one-liner just uses three consecutive substitution commands. The first replaces â€œscarletâ€ with â€œredâ€, the second replaced â€œrubyâ€ with â€œredâ€ and the last one replaces â€œpuceâ€ with â€œredâ€.</p>
<p>If you are using GNU sed, then you can do it simpler:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed &#x27;s/scarlet\|ruby\|puce/red/g&#x27;</span><br></pre></td></tr></table></figure>
<p>GNU sed provides more advanced regular expressions which support alternation. This one-liner uses alternation and the substitute command reads â€œreplace â€˜scarletâ€™ OR â€˜rubyâ€™ OR â€˜puceâ€™ with â€˜redâ€™â€.</p>
<p>36.Reverse order of lines (emulate â€œtacâ€ Unix command).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1!G;h;$!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner acts as the â€œtacâ€ Unix utility. Itâ€™s tricky to explain. The easiest way to explain it is by using an example.</p>
<p>Letâ€™s use a file with just 3 lines:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat file</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>
<p>Running this one-liner on this file produces the file in reverse order:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sed &#x27;1!G;h;$!d&#x27; file</span><br><span class="line">baz</span><br><span class="line">bar</span><br><span class="line">foo</span><br></pre></td></tr></table></figure>
<p>The first one-linerâ€™s command â€œ1!Gâ€ gets applied to all the lines which are not the first line. The second command â€œhâ€ gets applied to all lines. The third command â€œ$!dâ€ gets applied to all lines except the last one.</p>
<p>Letâ€™s go through the execution line by line.</p>
<p>Line 1: Only the â€œhâ€ command gets applied for the first line â€œfooâ€. It copies this line to hold buffer. Hold buffer now contains â€œfooâ€. Nothing gets output as the â€œdâ€ command gets applied.<br>Line 2: The â€œGâ€ command gets applied. It appends the contents of hold buffer to pattern space. The pattern space now contains. â€œbar\nfooâ€. The â€œhâ€ command gets applied, it copies â€œbar\nfooâ€ to hold buffer. It now contains â€œbar\nfooâ€. Nothing gets output.<br>Line 3: The â€œGâ€ command gets applied. It appends hold buffer to the third line. The pattern space now contains â€œbaz\nbar\nfooâ€. As this was the last line, â€œdâ€ does not get applied and the contents of pattern space gets printed. Itâ€™s â€œbaz\nbar\nfooâ€. File got reversed.</p>
<p>If we had had more lines, they would have simply get appended to hold buffer in reverse order.</p>
<p>Here is another way to do the same:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;1!G;h;$p&#x27;</span><br></pre></td></tr></table></figure>
<p>It silences the output with â€œ-nâ€ switch and forces the output with â€œpâ€ command only at the last line.</p>
<p>These two one-liners actually use a lot of memory because they keep the whole file in hold buffer in reverse order before printing it out. Avoid these one-liners for large files.</p>
<p>37.Reverse a line (emulates â€œrevâ€ Unix command).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/\n/!G;s/\(.\)\(.*\n\)/&amp;\2\1/;//D;s/.//&#x27;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>This is a very complicated one-liner. I had trouble understanding it the first time I saw it and ended up asking on comp.unix.shell for help.</p>
<p>Letâ€™s re-format this sed one-liner:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;</span><br><span class="line">  /\n/ !G</span><br><span class="line">  s/\(.\)\(.*\n\)/&amp;\2\1/</span><br><span class="line">  //D</span><br><span class="line">  s/.//</span><br><span class="line">&#x27; </span><br></pre></td></tr></table></figure>
<p>The first line â€œ&#x2F;\n&#x2F; !Gâ€ appends a newline to the end of the pattern space if there was none.</p>
<p>The second line â€œs&#x2F;(.)(.*\n)&#x2F;&amp;\2\1&#x2F;â€œ is a simple s&#x2F;&#x2F;&#x2F; expression which groups the first character as \1 and all the others as \2. Then it replaces the whole matched string with â€œ&amp;\2\1â€, where â€œ&amp;â€ is the whole matched text (â€œ\1\2â€). For example, if the input string is â€œ1234â€ then after the s&#x2F;&#x2F;&#x2F; expression, it becomes â€œ1234\n234\n1â€.</p>
<p>The third line is â€œ&#x2F;&#x2F;Dâ€. This statement is the key in this one-liner. An empty pattern &#x2F;&#x2F; matches the last existing regex, so itâ€™s exactly the same as: &#x2F;(.)(.\n)&#x2F;D. The â€œDâ€ command deletes from the start of the input till the first newline and then resumes editing with first command in script. It creates a loop. As long as &#x2F;(.)(.\n)&#x2F; is satisfied, sed will resume all previous operations. After several loops, the text in the pattern space becomes â€œ\n4321â€. Then &#x2F;(.)(.*\n)&#x2F; fails and sed goes to the next command.</p>
<p>The fourth line â€œs&#x2F;.&#x2F;&#x2F;â€œ removes the first character in the pattern space which is the newline char. The contents in pattern space becomes â€œ4321â€ â€“ reverse of â€œ1234â€.</p>
<p>There you have it, a line has been reversed.</p>
<p>38.Join pairs of lines side-by-side (emulates â€œpasteâ€ Unix command).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;$!N;s/\n/ /&#x27;</span><br></pre></td></tr></table></figure>
<p> This one-liner joins two consecutive lines with the â€œNâ€ command. They get joined with a â€œ\nâ€ character between them. The substitute command replaces this newline with a space, thus joining every pair of lines with a whitespace.</p>
<p>39.Append a line to the next if it ends with a backslash â€œ&quot;.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e :a -e &#x27;/\\$/N; s/\\\n//; ta&#x27;</span><br></pre></td></tr></table></figure>
<p>The first expression â€˜:aâ€™ creates a named label â€œaâ€. The second expression looks to see if the current line ends with a backslash â€œ&quot;. If it does, it joins it with the line following it using the â€œNâ€ command. Then the slash and the newline between joined lines get erased with â€œs&#x2F;\n&#x2F;&#x2F;â€œ command. If the substitution was successful we branch to the beginning of expression and do the same again, in hope that we might have another backslash. If the substitution was not successful, the line did not end with a backslash and we print it out.</p>
<p>Here is an example of running this one-liner:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat filename</span><br><span class="line">line one \</span><br><span class="line">line two</span><br><span class="line">line three</span><br><span class="line">$ sed -e :a -e &#x27;/\\$/N; s/\\\n//; ta&#x27; filename</span><br><span class="line">line one line two</span><br><span class="line">line three</span><br></pre></td></tr></table></figure>
<p>Lines one and two got joined because the first line ended with backslash.</p>
<p>40.Append a line to the previous if it starts with an equal sign â€œ&#x3D;â€.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e :a -e &#x27;$!N;s/\n=/ /;ta&#x27; -e &#x27;P;D&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner also starts with creating a named label â€œaâ€. Then it tests to see if it is not the last line and appends the next line to the current one with â€œNâ€ command. If the just appended line starts with a â€œ&#x3D;â€, one-liner branches the label â€œaâ€ to see if there are more lines starting with â€œ&#x3D;â€. During this process a substitution gets executed which throws away the newline character which came from joining with â€œNâ€ and the â€œ&#x3D;â€. If the substitution fails, one-liner prints out the pattern space up to the newline character with the â€œPâ€ command, and deletes the contents of pattern space up to the newline character with â€œDâ€ command, and repeats the process.</p>
<p>Here is an example of running it:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat filename</span><br><span class="line">line one</span><br><span class="line">=line two</span><br><span class="line">=line three</span><br><span class="line">line four</span><br><span class="line">$ sed -e :a -e &#x27;$!N;s/\n=/ /;ta&#x27; -e &#x27;P;D&#x27; filename</span><br><span class="line">line one line two line three</span><br><span class="line">line four</span><br></pre></td></tr></table></figure>
<p>Lines one, two and three got joined, because lines two and three started with â€˜&#x3D;â€™. Line four got printed as-is.</p>
<p>41.Digit group (commify) a numeric string.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed -e :a -e &#x27;s/\(.*[0-9]\)\([0-9]\&#123;3\&#125;\)/\1,\2/;ta&#x27;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">gsed &#x27;:a;s/\B[0-9]\&#123;3\&#125;\&gt;/,&amp;/;ta&#x27;</span><br></pre></td></tr></table></figure>

<p>This one-liner turns a string of digits, such as â€œ1234567â€ to â€œ1,234,567â€. This is called commifying or digit grouping.</p>
<p>First the one-liner creates a named label â€œaâ€. Then it captures two groups of digits. The first group is all the digits up to last three digits. The last three digits gets captures in the 2nd group. Then the two matching groups get separated by a comma. Then the same rules get applied to the line again and again until all the numbers have been grouped in groups of three.</p>
<p>Substitution command â€œ\1,\2â€ separates contents of group one with a comma from the contents of group two.</p>
<p>Here is an example to understand the grouping happening here better. Suppose you have a numeric string â€œ1234567â€. The first group captures all the numbers until the last three â€œ1234â€. The second group captures last three numbers â€œ567â€. They get joined by a comma. Now the string is â€œ1234,567â€. The same stuff is applied to the string again. Number â€œ1â€ gets captured in the first group and the numbers â€œ234â€ in the second. The number string is â€œ1,234,567â€. Trying to apply the same rules again fail because there is just one digit at the beginning of string, so the string gets printed out and sed moves on to the next line.</p>
<p>If you have GNU sed, you can use a simpler one-liner:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed &#x27;:a;s/\B[0-9]\&#123;3\&#125;\&gt;/,&amp;/;ta&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner starts with creating a named label â€œaâ€ and then loops over the string the same way as the previous one-liner did. The only difference is how groups of three digits get matched. GNU sed has some additional patterns. There are two patterns that make this one-liner work. The first is â€œ\Bâ€, which matches anywhere except at a word boundary. Itâ€™s needed so we did not go beyond word boundary. Look at this example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;12345 1234 123&quot; | sed &#x27;s/[0-9]\&#123;3\&#125;\&amp;gt;/,&amp;/g&#x27;</span><br><span class="line">12,345 1,234 ,123</span><br></pre></td></tr></table></figure>
<p>Itâ€™s clearly wrong. The last 123 got a comma added. Adding the â€œ\Bâ€ makes sure we match the numbers only at word boundary:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;12345 1234 123&quot; | sed &#x27;s/\B[0-9]\&#123;3\&#125;\&amp;gt;/,&amp;/g&#x27;</span><br><span class="line">12,345 1,234 123</span><br></pre></td></tr></table></figure>
<p>The second is â€œ&gt;â€. It matches the null string at the end of a word. Itâ€™s necessary because we need to to match the right-most three digits. If we did not have it, the expression would match after the first digit.</p>
<p>42.Add commas to numbers with decimal points and minus signs.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed -r &#x27;:a;s/(^|[^0-9.])([0-9]+)([0-9]&#123;3&#125;)/\1\2,\3/g;ta&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner works in GNU sed only. It turns on extended regular expression support with the â€œ-râ€ switch. Then it loops over a line matching three groups and separates the first two from the third with a comma.</p>
<p>The first group makes sure we ignore a leading non-digit character, such as + or -. If there is no leading non-digit character, then it just anchors at the beginning of the string which always matches.</p>
<p>The second group matches a bunch of numbers. The third group makes sure the second group does not match too many. It matches 3 consecutive numbers at the end of the string.</p>
<p>Once the groups have been captured, the â€œ\1\2,\3â€ substitution is done and the expression is looped again, until the whole string has been commified.</p>
<p>43.Add a blank line after every five lines.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;n;n;n;n;G;&#x27;</span><br></pre></td></tr></table></figure>
<p>The â€œnâ€ command is called four times in this one-liner. Each time itâ€™s called it prints out the current pattern space, empties it and reads in the next line of input. After calling it four times, the fifth line is read into the pattern space and then the â€œGâ€ command gets called. The â€œGâ€ command appends a newline to the fifth line. Then the next round of four â€œnâ€ commands is done. Next time the first â€œnâ€ command is called it prints out the newlined fifth line, thus inserting a blank line after every 5 lines.</p>
<p>The same can be achieved with GNU sedâ€™s step extension:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed &#x27;0~5G&#x27;</span><br></pre></td></tr></table></figure>
<p>GNU sedâ€™s step extensions can be generalized as â€œfirst~stepâ€. It matches every â€œstepâ€â€˜th line starting with line â€œfirstâ€. In this one-liner it matches every 5th line starting with line 0.</p>
<ol start="4">
<li><p>Selective Printing of Certain Lines.</p>
</li>
<li><p>Print the first 10 lines of a file (emulates â€œhead -10â€).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed 10q</span><br></pre></td></tr></table></figure>
<p>This one-liner restricts the â€œqâ€ (quit) command to line â€œ10â€. It means that this command gets executed only when sed reads the 10th line. For all the other lines there is no command specified. When there is no command specified, the default action is to print the line as-is. This one-liner prints lines 1-9 unmodified and at 10th line quits. Notice something strange? It was supposed to print first 10 lines of a file, but it seems that it just printed only the first 9â€¦ Worry not! The quit command is sneaky in its nature. Upon quitting with â€œqâ€ command, sed actually prints the contents of pattern space and only then quits. As a result lines 1-10 get printed!</p>
</li>
</ol>
<p>Please see the first part of the article for explanation of â€œpattern spaceâ€.</p>
<ol start="45">
<li>Print the first line of a file (emulates â€œhead -1â€).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed q</span><br></pre></td></tr></table></figure>
The explanation of this one-liner is almost the same as of the previous. Sed quits and prints the first line.</li>
</ol>
<p>A more detailed explanation - after the first line has been placed in the pattern space, sed executes the â€œqâ€ command. This command forces sed to quit; but due to strange nature of the â€œqâ€ command, sed also prints the contents of pattern space. As a result, only the first line gets printed.</p>
<ol start="46">
<li>Print the last 10 lines of a file (emulates â€œtail -10â€).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e :a -e &#x27;$q;N;11,$D;ba&#x27;</span><br></pre></td></tr></table></figure>
This one-liner is tricky to explain. It always keeps the last 10 lines in pattern space and at the very last line of input it quits and prints them.</li>
</ol>
<p>Iâ€™ll try to explain it. The first â€œ-e :aâ€ creates a label called â€œaâ€. The second â€œ-eâ€ does the following: â€œ$qâ€ - if it is the last line, quit and print the pattern space. If it is not the last line, execute three commands â€œNâ€, â€œ11,$Dâ€ and â€œbaâ€. The â€œNâ€ command reads the next line of input and appends it to the pattern space. The line gets separated from the rest of the pattern space by a new line character. The â€œ11,$Dâ€ command executes the â€œDâ€ command if the current line number is greater than or equal to 11 (â€œ11,$â€ means from 11th line to end of file). The â€œDâ€ command deletes the portion of pattern space up to the first new line character. The last command â€œbaâ€ branches to a label named â€œaâ€ (beginning of script). This guarantees that the pattern space never contains more than 10 lines, because as line 11 gets appended to pattern space, line 1 gets deleted, as line 12 gets appended line 2 gets deleted, etc.</p>
<ol start="47">
<li>Print the last 2 lines of a file (emulates â€œtail -2â€).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;$!N;$!D&#x27;</span><br></pre></td></tr></table></figure>
This one-liner is also tricky. First of all, the â€œ$!â€ address restricts commands â€œNâ€ and â€œDâ€ to all the lines except the last line.</li>
</ol>
<p>Notice how the addresses can be negated. If â€œ$<command>â€œ restricts a command to the last line, then â€œ$!<command>â€œ restricts the command to all but the last line. This can be applied to all restriction operations.</p>
<p>In this one-liner the â€œNâ€ command reads the next line from input and appends it to pattern space. The â€œDâ€ command deletes everything in pattern space up to the first â€œ\nâ€ symbol. These two commands always keep only the most recently read line in pattern space. When processing the second-to-last line, â€œNâ€ gets executed and appends the last line to the pattern space. The â€œDâ€ does not get executed as â€œNâ€ consumed the last line. At this moment sed quits and prints out the last two lines of the file.</p>
<ol start="48">
<li>Print the last line of a file (emulates â€œtail -1â€).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;$!d&#x27;</span><br></pre></td></tr></table></figure>
This one-liner discards all the lines except the last one. The â€œdâ€ command deletes the current pattern space, reads in the next line, and restarts the execution of commands from the first. In this case it just loops over itself like â€œddddâ€¦dddâ€ until it hits the last line. At the last line no command is executed (â€œ$!dâ€ restricted execution of â€œdâ€ to all the lines but last) and the pattern space gets printed.</li>
</ol>
<p>Another way to do the same:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;$p&#x27;</span><br></pre></td></tr></table></figure>
<p>The â€œ-nâ€ parameter suppresses automatic printing of pattern space. It means that without an explicit â€œpâ€ command (or other commands that act directly on the output stream), sed is dead silent. The â€œpâ€ command stands for â€œprintâ€ and it prints the pattern space. This one-liner calls the â€œpâ€ command at the very last line of input. All the other lines are silently discarded.</p>
<ol start="49">
<li>Print next-to-the-last line of a file.</li>
</ol>
<p>Eric gives three different one-liners to do this. The first one prints a blank line if the file contains just 1 line:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;$!&#123;h;d;&#125;&#x27; -e x</span><br></pre></td></tr></table></figure>
<p>This one-liner executes the â€œh;dâ€ commands for all the lines except the last one (â€œ$!â€ restricts â€œh;dâ€ commands to all lines except last). The â€œhâ€ command puts the current line in hold buffer and â€œdâ€ deletes the current line, and starts execution at the first sed command (â€œh;dâ€ gets executed again, and again, â€¦). At every single line, that line gets copied to hold buffer. At the very last line â€œh;dâ€ does not get executed. At this moment â€œxâ€ gets a chance to execute. The â€œxâ€ command exchanges the contents of hold buffer with pattern space. Remember that the previous line is still in the hold buffer. The â€œxâ€ command puts it back in pattern space, and sed prints it! There you go, the next-to-last line was printed!</p>
<p>In case there is just 1 line in the file, only the â€œxâ€ command gets executed. As the hold buffer initially is empty, â€œxâ€ puts emptiness in pattern space (I use word â€œputâ€ here but it actually exchanges the pattern space with hold space). Now sed prints the contents of pattern space, but itâ€™s empty, so sed prints out just a blank line.</p>
<p>The second prints the first line if the file contains just 1 line:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;1&#123;$q;&#125;&#x27; -e &#x27;$!&#123;h;d;&#125;&#x27; -e x</span><br></pre></td></tr></table></figure>
<p>This sed-one liner is divided in two parts. The first part â€œ1{$q;}â€ handles the case when the file contains just a single line. The second part â€œ$!{h;d;} xâ€ is exactly the same as in the previous one-liner! Thus, I need to explain just the first part.</p>
<p>The first part says - if it is the first line â€œ1â€, then execute â€œ$qâ€. The â€œ$qâ€ command means - if it is the last line, then quit. What it effectively does is it quits if the first line is the last line (i.e. file contains just one line). Remember from one-liner #44 that before quitting sed prints the contents of pattern space. As a result, if the file contains just one line, sed prints it.</p>
<p>The third prints nothing for 1 line files:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;1&#123;$d;&#125;&#x27; -e &#x27;$!&#123;h;d;&#125;&#x27; -e x</span><br></pre></td></tr></table></figure>
<p>This one-liner is again divided in two parts. The first part is â€œ1{$d;}â€ and the second is exactly the same as in the previous two one-liners. I will explain just the first part.</p>
<p>The first part says - if it is the first line â€œ1â€, then execute â€œ$dâ€. The â€œ$dâ€ command means - if it is the last line, then delete the pattern space and start all over again. In case the first line is the last (only one line in file), there is nothing more to be done and sed quits, printing nothing.</p>
<ol start="50">
<li>Print only the lines that match a regular expression (emulates â€œgrepâ€).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/regexp/p&#x27;</span><br></pre></td></tr></table></figure>
This one-liner suppresses automatic printing of pattern space with the â€œ-nâ€ switch and makes use of â€œpâ€ command to print only the lines that match â€œ&#x2F;regexp&#x2F;â€œ. The lines that do not match this regex get silently discarded. The ones that match get printed. Thatâ€™s it.</li>
</ol>
<p>Another one-liner that does the same:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/regexp/!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner deletes all the lines that do not match â€œ&#x2F;regexp&#x2F;â€œ. The other lines get printed by default. The â€œ!â€ before â€œdâ€ command inverts the line matching.</p>
<ol start="51">
<li>Print only the lines that do not match a regular expression (emulates â€œgrep -vâ€).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/regexp/!p&#x27;</span><br></pre></td></tr></table></figure>
This one-liner is the inverse of the previous.</li>
</ol>
<p>The â€œ-nâ€ prevents automatic printing of pattern space. The â€œ&#x2F;regexp&#x2F;â€œ restricts the â€œ!pâ€ command only to lines that match â€œ&#x2F;regexp&#x2F;â€œ, but the â€œ!â€ switch prevents â€œpâ€ from acting on these lines. What happens is â€œpâ€ acts on all lines that do not match â€œ&#x2F;regexp&#x2F;â€œ, and they get â€œpâ€rinted.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/regexp/d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is the inverse of the previous (#50).</p>
<p>This one-liner executed the â€œdâ€ (delete) command on all lines that match â€œ&#x2F;regexp&#x2F;â€œ, thus leaving only the lines that do not match. They get printed automatically.</p>
<ol start="52">
<li><p>Print the line immediately before regexp, but not the line containing the regexp.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/regexp/&#123;g;1!p;&#125;;h&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner saves each line in hold buffer with â€œhâ€ command. If a line matches the regexp, the hold buffer (containing the previous line) gets copied to pattern space with â€œgâ€ command and the pattern space gets printed out with â€œpâ€ command. The â€œ1!â€ restricts â€œpâ€ not to print on the first line (as there are no lines before the first).</p>
</li>
<li><p>Print the line immediately after regexp, but not the line containing the regexp.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/regexp/&#123;n;p;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>First of all, this one-liner disables automatic printing of pattern space with â€œ-nâ€ command line argument. Then, for all the lines that match â€œ&#x2F;regexp&#x2F;â€œ, this one-liner executes â€œnâ€ and â€œpâ€ commands. The â€œnâ€ command is the only command that depends on â€œ-nâ€ flag explicitly. If â€œ-nâ€ is specified it will empty the current pattern space and read in the next line of input. If â€œ-nâ€ is not specified, it will print out the current pattern space before emptying it. As in this one-liner â€œ-nâ€ is specified, the â€œnâ€ command empties the pattern space, reads in the next line and then the â€œpâ€ command prints that line out.</p>
</li>
<li><p>Print one line before and after regexp. Also print the line matching regexp and its line number. (emulates â€œgrep -A1 -B1â€).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e &#x27;/regexp/&#123;=;x;1!p;g;$!N;p;D;&#125;&#x27; -e h</span><br></pre></td></tr></table></figure>
<p>First letâ€™s look at â€œhâ€ command at the end of script. It gets executed on every line and stores the current line in pattern space in hold buffer. The idea of storing the current line in hold buffer is that if the next line matches â€œ&#x2F;regexp&#x2F;â€œ then the previous line is available in hold buffer.</p>
</li>
</ol>
<p>Now letâ€™s look at the complicated â€œ&#x2F;regexp&#x2F;{&#x3D;;x;1!p;g;$!N;p;D;}â€ command. It gets executed only if the line matches â€œ&#x2F;regexp&#x2F;â€œ. The first thing it does is it prints the current line number with â€œ&#x3D;â€ command. Then, it exchanges the hold buffer with pattern space by using the â€œxâ€ command. As I explained, the â€œhâ€ command at the end of the script makes sure that the hold buffer always contains the previous line. Now we have put it in the pattern space with â€œxâ€ command. Next, if itâ€™s not the first line, â€œ1!pâ€ prints the pattern space, effectively printing the previous line. Now the â€œgâ€ command gets executed. It copies the original line that was just exchanged with hold buffer back to pattern space. Now the â€œ$!Nâ€ executes. If it is not the last line, â€œNâ€ appends the next line to the current pattern space (and separates them with â€œ\nâ€ char). Pattern space now contains the line that matched â€œ&#x2F;regexp&#x2F;â€œ and the next line. The â€œpâ€ command prints that. â€œDâ€ deletes the current line (line that matched â€œ&#x2F;regexp&#x2F;â€œ) from pattern space and finally â€œhâ€ gets executed again, that puts the contents of pattern space into hold buffer. As â€œDâ€ deleted the current line, the next line was put in hold buffer.</p>
<ol start="55">
<li><p>Grep for â€œAAAâ€ and â€œBBBâ€ and â€œCCCâ€ in any order.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/AAA/!d; /BBB/!d; /CCC/!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner inverts the â€œdâ€ command to be executed on lines that do not contain either â€œAAAâ€, â€œBBBâ€ or â€œCCCâ€. If a line does not contain one of them, it gets deleted and sed proceeds to the next line. Only if all three of the patterns are present, does the sed print the line.</p>
</li>
<li><p>Grep for â€œAAAâ€ and â€œBBBâ€ and â€œCCCâ€ in that order.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/AAA.*BBB.*CCC/!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner deletes lines that do not match regexp â€œ&#x2F;AAA.BBB.CCC&#x2F;â€œ. For example, a line â€œAAAfooBBBbarCCCâ€ will get printed but â€œAAAfooCCCbarBBBâ€ baz will not.</p>
</li>
</ol>
<p>It can also be written as:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/AAA.*BBB.*CCC/p&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner prints lines that contain AAAâ€¦BBBâ€¦CCC in that order.</p>
<ol start="57">
<li>Grep for â€œAAAâ€ or â€œBBBâ€, or â€œCCCâ€.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;/AAA/b&#x27; -e &#x27;/BBB/b&#x27; -e &#x27;/CCC/b&#x27; -e d</span><br></pre></td></tr></table></figure>
This one-liner uses the â€œbâ€ command to branch to the end of the script if the line matches â€œAAAâ€ or â€œBBBâ€ or â€œCCCâ€. At the end of the script the line gets implicitly printed. If the line does not match â€œAAAâ€ or â€œBBBâ€ or â€œCCCâ€, the script reaches the â€œdâ€ command that deletes the line.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed &#x27;/AAA\|BBB\|CCC/!d&#x27;</span><br></pre></td></tr></table></figure>
This one-liner works with GNU sed. GNU sed allows alternation operator | to be used to match separate things. Itâ€™s a more compact way of saying match â€œAAAâ€ or â€œBBBâ€, or â€œCCCâ€.</li>
</ol>
<p>If you are using GNU sed, then there is actually no need to escape the pipes |. You may specify the â€œ-râ€ command line option to use extended regular expressions. This way this one liner becomes:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed -r &#x27;/AAA|BBB|CCC/!d&#x27;</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed -rn &#x27;/AAA|BBB|CCC/p&#x27;</span><br></pre></td></tr></table></figure>
<ol start="58">
<li>Print a paragraph that contains â€œAAAâ€. (Paragraphs are separated by blank lines).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;/./&#123;H;$!d;&#125;&#x27; -e &#x27;x;/AAA/!d;&#x27;</span><br></pre></td></tr></table></figure>
First notice that this one-liner is divided in two parts for clearness. The first part is â€œ&#x2F;.&#x2F;{H;$!d;}â€ and the second part is â€œx;&#x2F;AAA&#x2F;!dâ€.</li>
</ol>
<p>The first part has an interesting pattern match â€œ&#x2F;.&#x2F;â€œ. What do you think it does? Well, a line separating paragraphs would be a blank line, meaning it would not have any characters in it. This pattern matches only the lines that are not separating paragraphs. These lines get appended to hold buffer with â€œHâ€ command. They also get prevented from printing with â€œdâ€ command (except for the last line, when â€œdâ€ does not get executed (â€œ$!â€ restricts â€œdâ€ to all but the last line)). Once sed sees a blank line, the â€œ&#x2F;.&#x2F;â€œ pattern no longer matches and the second part of one-liner gets executed.</p>
<p>The second part exchanges the hold buffer with pattern space by using the â€œxâ€ command. The pattern space now contains the whole paragraph of text. Next sed tests if the paragraph contains â€œAAAâ€. If it does, sed does nothing which results in printing the paragraph. If the paragraph does not contain â€œAAAâ€, sed executes the â€œdâ€ command that deletes it without printing and restarts execution at first command.</p>
<ol start="59">
<li>Print a paragraph if it contains â€œAAAâ€ and â€œBBBâ€ and â€œCCCâ€ in any order.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;/./&#123;H;$!d;&#125;&#x27; -e &#x27;x;/AAA/!d;/BBB/!d;/CCC/!d&#x27;</span><br></pre></td></tr></table></figure>
This one-liner is also split in two parts for clarity. The first part is exactly the same as the first part of previous one-liner. The second part is very similar to one-liner #55 and also the previous.</li>
</ol>
<p>The â€œxâ€ command in the 2nd part does exactly the same as in previous one-liner, it exchanges the hold buffer, that contains the paragraph with pattern space. Next sed does three tests - it tests if the paragraph contains â€œAAAâ€, â€œBBBâ€ and â€œCCCâ€. If the paragraph does not contain even one of them, the â€œdâ€ command gets executed that purges the paragraph. If it contains all three patterns, sed happily prints the paragraph.</p>
<ol start="60">
<li>Print a paragraph if it contains â€œAAAâ€ or â€œBBBâ€ or â€œCCCâ€.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e &#x27;/./&#123;H;$!d;&#125;&#x27; -e &#x27;x;/AAA/b&#x27; -e &#x27;/BBB/b&#x27; -e &#x27;/CCC/b&#x27; -e d</span><br></pre></td></tr></table></figure>
The first part is exactly the same as in previous two one-liners and does not require explanation. The second part that happens to be â€œ-e â€˜x;&#x2F;AAA&#x2F;bâ€™ -e â€˜&#x2F;BBB&#x2F;bâ€™ -e â€˜&#x2F;CCC&#x2F;bâ€™ -e dâ€ is almost exactly the same as in one-liner #57.</li>
</ol>
<p>The â€œxâ€ command exchanges the paragraph stored in hold buffer with the pattern space. Then it tests if the pattern space (paragraph) contains â€œAAAâ€, if it does, sed branches to end of script with â€œbâ€ command, that happily makes sed print the paragraph. If â€œAAAâ€ did not match, sed does exactly the same testing for pattern â€œBBBâ€. If it again did not match, it tests for â€œCCCâ€. If none of these patterns were found, sed executes the â€œdâ€ command that deletes everything and restarts this one-liner.</p>
<p>Here is another way to do the same with GNU sed:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed &#x27;/./&#123;H;$!d;&#125;;x;/AAA\|BBB\|CCC/b;d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is exactly the same as previous one. It just compresses the three tests for â€œAAAâ€, â€œBBBâ€ or â€œCCCâ€ into one â€œ&#x2F;AAA|BBB|CCC&#x2F;â€œ as explained in one-liner #57.</p>
<ol start="61">
<li><p>Print only the lines that are 65 characters in length or more.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/^.\&#123;65\&#125;/p&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner prints lines that are 65 characters in length or more. It does it by using a regular expression â€œ^.{65}â€ that matches any 65 characters at the beginning of line. If there are less than 65 characters, the regex does not match and the line does not get printed (as automatic printing was disabled with â€œ-nâ€ command line option).</p>
</li>
<li><p>Print only the lines that are less than 65 chars.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/^.\&#123;65\&#125;/!p&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner inverts the previous one. If the line matches 65 characters, then it is not printed â€œ!pâ€. If it does not match, it gets printed.</p>
</li>
</ol>
<p>Another way to do the same:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^.\&#123;65\&#125;/d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner deletes all lines that match 65 characters. All others implicitly get printed.</p>
<ol start="63">
<li><p>Print section of a file from a regex to end of file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/regexp/,$p&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses a tricky range match â€œ&#x2F;regex&#x2F;,$â€. It matches lines starting from the first line that matches â€œ&#x2F;regex&#x2F;â€œ to the end of file â€œ$â€. The â€œpâ€ command prints these lines. All other lines get silently discarded.</p>
</li>
<li><p>Print lines 8-12 (inclusive) of a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;8,12p&#x27;</span><br></pre></td></tr></table></figure>
<p>This is another type of range match. This range matches a section of lines between two lines numbers (inclusive). In this case itâ€™s lines [8 to 12].</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;8,12!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This is the same one-liner, just written differently. It deletes lines that are outside of range [8, 12] and prints those in this range.</p>
</li>
<li><p>Print line number 52.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;52p&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner restricts the â€œpâ€ command to line â€œ52â€. Only this line gets â€œpâ€rinted.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;52!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner deletes all lines except line 52. Line 52 gets printed.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;52q;d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one is the smartest. It quits at line 52 with â€œqâ€ command. The previous two one-liners would loop over all the remaining lines and do nothing. Remember from one-liner #44 that quit command prints the pattern space with it. The â€œdâ€ command makes sure that no other line gets printed while sed gets to line 52.</p>
</li>
<li><p>Beginning at line 3, print every 7th line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed -n &#x27;3~7p&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses a line range match extension of GNU sed. A line range in format â€œfirst<del>stepâ€ matches every stepâ€™th line starting from first. In this one-liner itâ€™s â€œ3</del>7â€, meaning match every 7th line starting from 3rd. The â€œ-nâ€ flag prevents printing any other lines, and â€œpâ€ in â€œ3~7pâ€ prints the matched line.</p>
</li>
</ol>
<p>For everyone else, this one-liner works:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;3,$&#123;p;n;n;n;n;n;n;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner executes commands â€œp;n;n;n;n;n;nâ€ for lines starting the 3rd line. The â€œ3,$â€ is a line range match that restricts commands by line numbers. The â€œ$â€ means end of file and â€œ3â€ means 3rd line.</p>
<p>The â€œp;n;n;n;n;n;nâ€ command prints the line, then skips 6, prints the 7th, skips 6, prints the 14th, etc. As it starts executing at line 3, the effect is - print line 3, skip 6, print line 10, skip 6, print line 17, â€¦. That is, print every 7th line beginning at 3rd.</p>
<ol start="67">
<li>Print section of lines between two regular expressions (inclusive).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/Iowa/,/Montana/p&#x27;</span><br></pre></td></tr></table></figure>
This one-liner prints all the lines between the first line that matches a regular expression â€œIowaâ€ and the first line that matches a regular expression â€œMontanaâ€.</li>
</ol>
<p>It uses a range match â€œ&#x2F;start&#x2F;,&#x2F;finish&#x2F;â€œ that matches all lines starting from a line that matches â€œstartâ€ and ending with the first line that matches â€œfinishâ€.</p>
<ol start="5">
<li><p>Selective Deletion of Certain Lines</p>
</li>
<li><p>Print all lines in the file except a section between two regular expressions.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/Iowa/,/Montana/d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner continues where the previous left off. One-liner #67 used the range match â€œ&#x2F;start&#x2F;,&#x2F;finish&#x2F;â€œ to print lines between two regular expressions (inclusive). This one-liner, on the other hand, deletes lines between two regular expressions and prints all the lines outside this range. Just to remind you, a range â€œ&#x2F;start&#x2F;,&#x2F;finish&#x2F;â€œ matches all lines starting from the first line that matches a regular expression â€œ&#x2F;start&#x2F;â€œ to the first line that matches a regular expression â€œ&#x2F;finish&#x2F;â€œ. In this particular one-liner the â€œdâ€, delete, command is applied to these lines. The delete command prevents the matching lines from ever seeing the light.</p>
</li>
</ol>
<p>For example, suppose your input to this one-liner was:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Florida</span><br><span class="line">&lt;strong&gt;Iowa</span><br><span class="line">New York</span><br><span class="line">San Jose</span><br><span class="line">Montana&lt;/strong&gt;</span><br><span class="line">Texas</span><br><span class="line">Fairbanks</span><br></pre></td></tr></table></figure>
<p>Then after the sed program has finished running, the output is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Florida</span><br><span class="line">Texas</span><br><span class="line">Fairbanks</span><br></pre></td></tr></table></figure>
<p>We see this output because the lines from Iowa to Montana matched the â€œ&#x2F;Iowa&#x2F;,&#x2F;Montana&#x2F;â€œ range match (i put the matched lines in bold) and were deleted.</p>
<ol start="69">
<li>Delete duplicate, consecutive lines from a file (emulates â€œuniqâ€).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;$!N; /^\(.*\)\n\1$/!P; D&#x27;</span><br></pre></td></tr></table></figure>
This one-liner acts as the â€œuniqâ€ Unix utility. So how does it work? First of all, for every line that is not the very last line of input, sed appends the next line to the pattern space by the â€œNâ€ command. The â€œNâ€ command is restricted to all but the last line by â€œ$!â€ restriction pattern. The newly appended line is separated from the previous line by the â€œ\nâ€ character. Next, the pattern space is matched against â€œ&#x2F;^(.*)\n\1$&#x2F;â€œ regular expression. This regular expression captures the previous line up to â€œ\nâ€ character and saves it in the match group â€œ\1â€. Then it tests if the newly appended line is the same as the previous one. If it is not, the â€œPâ€ gets executed. If it is, the â€œPâ€ command does not get executed. The â€œPâ€ command prints everything in the pattern space up to the first â€œ\nâ€ character. Next the â€œDâ€ command executes and deletes everything up to the first â€œ\nâ€ char, leaving only the newly read line in pattern space. It also forces the sed script to begin from the first command.</li>
</ol>
<p>This way it loops over all lines, comparing two consecutive lines. If they are equal, the first line gets deleted, and a new line gets appended to whatâ€™s left. If they are not equal, the first one gets deleted, and deleted.</p>
<p>I think itâ€™s hard to understand what is going on from this description. Iâ€™ll illustrate it with an example. Suppose this is the input:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">foo</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>
<p>The first thing sed does is it reads the first line of input in pattern space. The pattern space now contains â€œfooâ€. Now the â€œNâ€ command executed. The pattern space now contains â€œfoo\nfooâ€. Next the pattern space is tested against â€œ&#x2F;^(.)\n\1$&#x2F;â€œ regular expression. This regular expression matches because â€œ(.)â€ is â€œfooâ€ and â€œ&#x2F;^(.)\n\1$&#x2F;â€œ is â€œfoo\nfooâ€, exactly what we have in the pattern space. As it matched, the â€œPâ€ command does not get executed. Now the â€œDâ€ command executes, deleting the everything up to first â€œ\nâ€ from pattern space. The pattern space now contains just â€œfooâ€. The â€œDâ€ command forces sed to start from the first command. Now the â€œNâ€ is executed again, the pattern space now contains â€œfoo\nfooâ€ again and the same thing happens, â€œPâ€ does not get executed and â€œDâ€ deletes the first â€œfooâ€, leaving the pattern space with just â€œfooâ€ in it. Now the â€œNâ€ gets executed once again, this time â€œbarâ€ gets appended to pattern space. It contains â€œfoo\nbarâ€ now. The regular expression â€œ&#x2F;^(.)\n\1$&#x2F;â€œ does not match and â€œPâ€ gets executed, printing â€œfooâ€. After that â€œDâ€ gets executed wiping â€œfooâ€ from pattern space. The pattern space now contains â€œbarâ€. The commands restart and â€œNâ€ gets executed, it appends the next â€œbarâ€ to current pattern space. Now it contains â€œbar\nbarâ€. Just like with â€œfoo\nfooâ€, nothing gets printed, and â€œDâ€ deletes the first â€œbarâ€, leaving pattern space with â€œbarâ€. The one-liner restarts its execution. Now â€œNâ€ reads in the final line â€œbazâ€. The pattern space contains â€œbar\nbazâ€ which does not match the regular expression. The â€œPâ€ prints out the â€œbarâ€ and â€œDâ€ deletes â€œbarâ€. Now â€œNâ€ does not get executed because we are at the last line of input. The â€œ$!Nâ€ restricts â€œNâ€ to all lines but last. At this moment pattern space contains only the last â€œbazâ€, the regular expression does not match, so â€œbazâ€ gets printed. The â€œDâ€ command executes, emptying the pattern space. There is no more input and sed quits.</p>
<p>The output for this example is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>
<p>I think this is one of the most detailed explanations I have written about a single one liner. :)</p>
<ol start="70">
<li>Delete duplicate, nonconsecutive lines from a file.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;G; s/\n/&amp;&amp;/; /^\([ -~]*\n\).*\n\1/d; s/\n//; h; P&#x27;</span><br></pre></td></tr></table></figure>
This is a very tricky one-liner. It stores the unique lines in hold buffer and at each newly read line, tests if the new line already is in the hold buffer. If it is, then the new line is purged. If itâ€™s not, then itâ€™s saved in hold buffer for future tests and printed.</li>
</ol>
<p>A more detailed description - at each line this one-liner appends the contents of hold buffer to pattern space with â€œGâ€ command. The appended string gets separated from the existing contents of pattern space by â€œ\nâ€ character. Next, a substitution is made to that substitutes the â€œ\nâ€ character with two â€œ\n\nâ€. The substitute command â€œs&#x2F;\n&#x2F;&amp;&amp;&#x2F;â€œ does that. The â€œ&amp;â€ means the matched string. As the matched string was â€œ\nâ€, then â€œ&amp;&amp;â€ is two copies of it â€œ\n\nâ€. Next, a test â€œ&#x2F;^([ -<del>]\n).\n\1&#x2F;â€œ is done to see if the contents of group capture group 1 is repeated. The capture group 1 is all the characters from space â€œ â€œ to â€œ</del>â€œ (which include all printable chars). The â€œ[ -<del>]â€ matches that. Replacing one â€œ\nâ€ with two was the key idea here. As â€œ([ -</del>]\n)â€ is greedy (matches as much as possible), the double newline makes sure that it matches as little text as possible. If the test is successful, the current input line was already seen and â€œdâ€ purges the whole pattern space and starts script execution from the beginning. If the test was not successful, the doubled â€œ\n\nâ€ gets replaced with a single â€œ\nâ€ by â€œs&#x2F;\n&#x2F;&#x2F;â€œ command. Then â€œhâ€ copies the whole string to hold buffer, and â€œPâ€ prints the new line.</p>
<ol start="71">
<li>Delete all lines except duplicate consecutive lines (emulates â€œuniq -dâ€).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;$!N; s/^\(.*\)\n\1$/\1/; t; D&#x27;</span><br></pre></td></tr></table></figure>
This sed one-liner prints only the duplicate lines. This sed one-liner starts with reading in the next line from input with the â€œNâ€ command. As I already mentioned, the current line and the next get separated by â€œ\nâ€ character after â€œNâ€ executes. This one-liner also restrics â€œNâ€ to all lines but last with â€œ$!â€ restriction. Now a substitution â€œs&#x2F;^(.*)\n\1$&#x2F;\1&#x2F;â€œ is tried. Similarly to one-liner #69, this substitution replaces two repeating strings with one. For example, a string â€œfoo\nfooâ€ gets replaced with just â€œfooâ€. Now, if this substitution was successful (there was a repeated string), the â€œtâ€ command takes the script to the end where the current pattern space gets printed automatically. If the substitution was not successful, â€œDâ€ executes, deleting the non-repeated string. The cycle continues and this way only the duplicate lines get printed once.</li>
</ol>
<p>Letâ€™s take a look at an example. Suppose the input is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>
<p>This one-liner reads the first line and immediately executes the â€œNâ€ command. The pattern space now is â€œfoo\nfooâ€. The substitution â€œs&#x2F;^(.*)\n\1$&#x2F;\1&#x2F;â€œ is tried and itâ€™s successful, because â€œfooâ€ is repeated twice. The pattern space now contains just a single â€œfooâ€. As the substitution was successful, â€œtâ€ command branches to the end of the script. At this moment â€œfooâ€ gets printed. Now the cycle repeats. Sed reads in â€œbarâ€, the â€œNâ€ command appends â€œbazâ€ to â€œbarâ€. The pattern space now is â€œbar\nbazâ€. The substitution is tried, but itâ€™s not successful, as â€œbarâ€ is not repeated. As the substitution failed, â€œtâ€ does nothing and â€œDâ€ executes, deleting â€œbarâ€ from pattern space. The pattern space is left with single â€œbazâ€. Command â€œNâ€ no longer executes as we reached end of file, substitution fails, â€œtâ€ fails, and â€œDâ€ deletes the â€œbazâ€.</p>
<p>The end result is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br></pre></td></tr></table></figure>
<p>Just as we expected - only the duplicate line got printed.</p>
<ol start="72">
<li><p>Delete the first 10 lines of a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1,10d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner restricts the â€œdâ€ command to a range of lines by number. The â€œ1,10â€ means a range matching lines 1 to 10 inclusive. On each of the lines the â€œdâ€ command gets executed. It deletes the current pattern space, and restarts the commands from beginning. The default action for lines &gt; 10 is to print the line.</p>
</li>
<li><p>Delete the last line of a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;$d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner restricts the â€œdâ€ command to the last line of file. Itâ€™s done by specifying the special char â€œ$â€ as the line to match. It matches only the last line. The last line gets deleted, but the others get printed implicitly.</p>
</li>
<li><p>Delete the last 2 lines of a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;N;$!P;$!D;$d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner always keeps two lines in the pattern space. At the very last line, it just does not output these last two. All the others before last two get output implicitly. Letâ€™s see how it does it. As soon as sed reads the first line of input in pattern space, it executes the first command â€œNâ€. It places the 2nd line of input in pattern space. The next two commands â€œ$!Pâ€ and â€œ$!Dâ€ print the first part of pattern space up to newline character, and delete this part from pattern space. They keep doing it until the very last line gets appended to pattern space by â€œNâ€ command. At this moment the last two lines are in pattern space and â€œ$dâ€ executes, deleting them both. Thatâ€™s it. Last two lines got deleted.</p>
</li>
</ol>
<p>If there is just one line of data, then it outputs it.</p>
<ol start="75">
<li><p>Delete the last 10 lines of a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e :a -e &#x27;$d;N;2,10ba&#x27; -e &#x27;P;D&#x27;</span><br></pre></td></tr></table></figure>
<p>This is really straight forward one-liner. It always keeps 10 lines in pattern-space, by appending each new input line with â€œNâ€, and deleting the 11th excessive line with â€œDâ€. Once the end of file is reached, it â€œdâ€ the whole pattern space, deleting the last 10 lines.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e :a -e &#x27;1,10!&#123;P;N;D;&#125;;N;ba&#x27;</span><br></pre></td></tr></table></figure>
<p>This is also a straight forward one-liner. For the lines that are not 1-10, it appends them to pattern space with â€œNâ€. For lines &gt; 10, it prints the first line in pattern space with â€œPâ€, appends another line with â€œNâ€ and deletes the printed line with â€œDâ€. The â€œDâ€ command causes sed to branch to the beginning of script! The â€œN;baâ€ at the end never, ever gets executed again for lines &gt; 10. It keeps looping this way â€œPâ€, â€œNâ€, â€œDâ€, always keeping 10 lines in pattern space and printing line-10 on each cycle. The â€œNâ€ command causes script to quit if it tries to read past end of file.</p>
</li>
<li><p>Delete every 8th line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed &#x27;0~8d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner only works with GNU Sed only. It uses a special address range match â€œfirst~stepâ€ that matches every stepâ€™th line starting with the first. In this one-liner first is 0 and step is 8. Zero is not a valid physical line number, so the very first line of input does not match. The first line to match is 8th, then 16th, then 24th, etc. Each line that matches is deleted by â€œdâ€ command.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;n;n;n;n;n;n;n;d;&#x27;</span><br></pre></td></tr></table></figure>
<p>This is a portable version. The â€œnâ€ command prints the current pattern space, empties it, and reads in the next line. It does so for every 7 lines, and 8th line gets deleted with â€œdâ€. This process continues until all input has been processed.</p>
</li>
<li><p>Delete lines that match regular expression pattern.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/pattern/d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner executes the â€œdâ€ command on all lines that match â€œ&#x2F;pattern&#x2F;â€œ. The â€œdâ€ command deletes the line and skips to the next line.</p>
</li>
<li><p>Delete all blank lines in a file (emulates â€œgrep â€˜.â€™â€.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^$/d&#x27;</span><br></pre></td></tr></table></figure>
<p>The regular expression â€œ&#x2F;^$&#x2F;â€œ in this one-liner tests if the beginning of line matches the end of the line. Only the empty lines have this property and sed deletes them.</p>
</li>
</ol>
<p>Another way to do the same is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/./!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner tests if the line matches at least one character. The dot â€œ.â€ in the regular expression matches any character. An empty line does not have any characters and it does not match this regular expression. Sed deletes all the lines that do not match this regular expression.</p>
<ol start="79">
<li>Delete all consecutive blank lines from a file (emulates â€œcat -sâ€).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/./,/^$/!d&#x27;</span><br></pre></td></tr></table></figure>
This one-liner leaves one blank line at the end of the file, if there are multiple blanks at the end. Other than that, all consecutive blanks are stripped.</li>
</ol>
<p>It uses an inverse range match â€œ&#x2F;start&#x2F;,&#x2F;finish&#x2F;!â€ to â€œdâ€ delete lines from first blank line, to first non-blank, non-inclusive.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^$/N;/\n$/D&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner leaves one blank line at the beginning and end of the file, if there are multiple blanks at both sides. Other than that, all consecutive blanks are stripped.</p>
<p>The consecutive empty lines get appended in pattern space by â€œ&#x2F;^$&#x2F;Nâ€ command. The â€œ&#x2F;\n$&#x2F;Dâ€ command matches and deletes blanks until only 1 is left. At that moment it no longer matches, and the line is output.</p>
<ol start="80">
<li><p>Delete all consecutive blank lines from a file except the first two.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^$/N;/\n$/N;//D&#x27;</span><br></pre></td></tr></table></figure>
<p>In case of &gt; 2 blank lines, this one-liner trims them down to two. There is a catch to this one-liner. Let me explain it first. See the last command â€œ&#x2F;&#x2F;Dâ€? Itâ€™s a shortcut for â€œ&#x2F;previous-match&#x2F;Dâ€. In this case itâ€™s shortcut for â€œ&#x2F;\n$&#x2F;Dâ€. Alright, now the one-liner itself. On every empty line, it appends the next to current pattern space with â€œ&#x2F;^$&#x2F;Nâ€ command. Next it tests if the line just read in was actually a blank line with â€œ&#x2F;\n$&#x2F;â€œ, if it is, it reads another line in with â€œNâ€. At this moment it repeats the same test â€œ&#x2F;\n$&#x2F;â€œ. If the line was a blank one again, it deletes the first blank line and restarts sed script from the beginning. Notice that at all times only 2 consecutive blank lines are in pattern space. This way any number of blank lines get deleted and only two are left.</p>
</li>
<li><p>Delete all leading blank lines at the top of a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/./,$!d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner inverts a match â€œmatch from the first non-blank line to end of fileâ€. It becomes â€œmatch from the beginning of file to last blank lineâ€.</p>
</li>
<li><p>Delete all trailing blank lines at the end of a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e :a -e &#x27;/^\n*$/&#123;$d;N;ba&#x27; -e &#x27;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner accumulates blank lines in pattern space until it either hits end or hits a non-blank line. If it hits end, â€œ$dâ€ deletes the whole pattern space (which contained just the trailing blank lines) and quits. If however, it hits non-blank line, the whole pattern space gets printed implicitly and script continues as if nothing had happened.</p>
</li>
</ol>
<p>This one is a portable version.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed -e :a -e &#x27;/^\n*$/N;/\n$/ba&#x27;</span><br></pre></td></tr></table></figure>
<p>This is the same script, except a shorter version, made to work with Gnu Sed.</p>
<ol start="83">
<li><p>Delete the last line of each paragraph.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/^$/&#123;p;h;&#125;;/./&#123;x;/./p;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner always keeps the previous line in hold buffer. Itâ€™s accomplished by 2nd block of commands â€œ&#x2F;.&#x2F;{x;&#x2F;.&#x2F;p;}â€. In this block, the pattern space (1 line) gets exchanged with hold buffer (1 line) by â€œxâ€ command and if the hold buffer was not empty, it gets printed by â€œpâ€. The next moment to note is what happens on the first empty line. That is the line after the paragraph. At this moment â€œ&#x2F;^$&#x2F;{p;h;}â€ gets executed, that prints the blank line (but does not print the last line of paragraph!), and puts the blank line in hold buffer. Once a new paragraph is reached, the script executed just like it was the very first paragraph of the input.</p>
</li>
<li><p>Special Sed Applications</p>
</li>
<li><p>Remove nroff overstrikes.</p>
</li>
</ol>
<p>Nroff overstrikes are chars that are formatted to stand out in bold. They are achieved like in old typewriters, where you would do backspace and hit the same key again. In nroff itâ€™s key CHAR, CTRL+H, CHAR. This one-liner deletes the CHAR, CTRL+H, leaving just plain CHAR.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/.^H//g&#x27;</span><br></pre></td></tr></table></figure>
<p>Press Ctrl+V and then Ctrl+H to insert ^H literally in sed one-liner. It then uses the substitute command to delete any char â€œ.â€ followed by CTRL+H â€œ^Hâ€.</p>
<p>Another way to do the same is use a hex escape expression that works in most recent seds:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/.\x08//g&#x27;</span><br></pre></td></tr></table></figure>
<p>Yet another way is to use â€œechoâ€ and enable interpretation of backslashed characters:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/.&#x27;`echo -e &quot;\b&quot;`&#x27;//g&#x27;</span><br></pre></td></tr></table></figure>
<ol start="85">
<li><p>Print Usenet&#x2F;HTTP&#x2F;Email message header.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsed -r &#x27;/^\r?$/q&#x27;</span><br></pre></td></tr></table></figure>
<p>Usenet, HTTP and Email headers are similar. They are a bunch of text lines, separated from the body of the message with two new lines â€œ\r\n\r\nâ€. Some implementations might even go with just â€œ\n\nâ€. This one-liner quits on the first line that is either empty or contains â€œ\râ€. In other words, it prints the message header and quits.</p>
</li>
<li><p>Print Usenet&#x2F;HTTP&#x2F;Email message body.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1,/^$/d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses a range match â€œ1,&#x2F;^$&#x2F;â€œ to delete lines starting from 1st, and ending with the first blank line (inclusive). As I explained in the previous one-liner #78 above, â€œ&#x2F;^$&#x2F;â€œ matches empty lines. All the lines before first blank line in a Usenet&#x2F;Email message or a HTTP header are message headers. They get deleted.</p>
</li>
<li><p>Extract subject from an email message.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^Subject: */!d; s///; q&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner deletes all lines that do not match â€œ^Subject: â€œ. Then it re-uses the match in â€œs&#x2F;&#x2F;&#x2F;â€œ to delete â€œSubject: â€œ part from the line, leaving just the real subject. Please notice how â€œs&#x2F;&#x2F;&#x2F;â€œ is equivalent to â€œs&#x2F;previous-match&#x2F;&#x2F;â€œ, where â€œprevious-matchâ€ is â€œ^Subject: *â€ in this one-liner.</p>
</li>
<li><p>Extract sender information from an email message.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^From: */!d; s///; q&#x27;</span><br></pre></td></tr></table></figure>
<p>This one liner is equivalent to the previous one, except it prints sender information from email.</p>
</li>
<li><p>Extract email address from a â€œName Surname <a href="mailto:&#x65;&#109;&#97;&#x69;&#x6c;&#x40;&#100;&#111;&#x6d;&#x61;&#105;&#110;&#46;&#99;&#x6f;&#109;">&#x65;&#109;&#97;&#x69;&#x6c;&#x40;&#100;&#111;&#x6d;&#x61;&#105;&#110;&#46;&#99;&#x6f;&#109;</a>â€œ string.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/.*&lt; *//;s/ *&gt;.*//;</span><br></pre></td></tr></table></figure>
<p>This one-liner strips all symbols before &lt; symbol (and any whitespace after it), and stips all symbols after &gt; symbol (including whitespace before it). Thatâ€™s it. Whatâ€™s left is <a href="mailto:&#101;&#109;&#97;&#x69;&#x6c;&#64;&#100;&#x6f;&#109;&#x61;&#x69;&#x6e;&#x2e;&#x63;&#x6f;&#109;">&#101;&#109;&#97;&#x69;&#x6c;&#64;&#100;&#x6f;&#109;&#x61;&#x69;&#x6e;&#x2e;&#x63;&#x6f;&#109;</a>.</p>
</li>
<li><p>Add a leading angle bracket and space to each line (quote an email message).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/^/&gt; /&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner substitutes zero-width anchor â€œ^â€ that matches beginning of line with â€œ&gt; â€œ. As itâ€™s a zero-width anchor, the result is that â€œ&gt; â€œ gets added to beginning of each line.</p>
</li>
<li><p>Delete leading angle bracket from each line (unquote an email message).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/^&gt; //&#x27;</span><br></pre></td></tr></table></figure>
<p>It does what it says, deletes two characters â€œ&gt;â€ and a space â€œ â€œ from the beginning of each line.</p>
</li>
<li><p>Strip HTML tags.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e :a -e &#x27;s/&amp;lt;[^&gt;]*&gt;//g;/&amp;lt;/N;//ba&#x27;</span><br></pre></td></tr></table></figure>
<p>Sed is not made for parsing HTML. This is a very crude version of HTML tag eraser. It starts by creating a branch label named â€œaâ€. Then on each line it substitutes â€œ&lt;[^&gt;]&gt;â€ with nothing as many times as possible (â€œgâ€ flag for s&#x2F;&#x2F;&#x2F; command). The â€œ&lt;[^&gt;]&gt;â€ expression means match match symbol â€œ&lt;â€ followed by any other symbols that are not â€œ&gt;â€, and that ends with â€œ&gt;â€. This is a common pattern in regular expressions for non-greediness. Next, the one-liner tests if there are any open tags left on the line, if there are â€œNâ€ reads the next line of input to make it work across multiple lines. â€œ&#x2F;&#x2F;baâ€ finally branches to the beginning of the script (itâ€™s short for â€œ&#x2F;previous-expression&#x2F;baâ€ which in this case is â€œ&#x2F;&lt;&#x2F;baâ€).</p>
</li>
</ol>
<p>I love writing about programming and I am happy to announce my second e-book called Sed One-Liners Explained. This book is based on my popular Sed One-Liners Explained article series that has been read over 1,500,000 times.</p>
<p>I reviewed all the one-liners in the series, fixed various mistakes, greatly improved the explanations, added a bunch of new one-liners, bringing the total count to 100, and added three new chapters â€“ an introduction to sed, a summary of sed addresses and ranges, and a chapter on debugging sed scripts with sed-sed.<br>Table of Contents</p>
<p>The e-book explains exactly 100 one-liners. Itâ€™s divided into the following chapters:</p>
<pre><code>Preface
Chapter 1: Introduction to sed
Chapter 2: Line Spacing
Chapter 3: Line Numbering
Chapter 4: Text Conversion and Substitution
Chapter 5: Selective Printing of Certain Lines
Chapter 6: Selective Deletion of Certain Lines
Chapter 1: Special sed Applications
Appendix A: Summary of All sed Commands
Appendix B: Addresses and Ranges
Appendix C: Debugging sed Scripts with sed-sed
Index
</code></pre>
<p>Whatâ€™s sed?</p>
<p>Sed is the superman of UNIX stream editing. Itâ€™s a small utility thatâ€™s present on every UNIX system and it transforms one stream of text into another. Letâ€™s take a look at several practical examples that sed can carry out easily. All these examples and many more are explained in the e-book.</p>
<p>I have also made the first chapter of the book, Introduction to sed, freely available. Please download the e-book preview to read it. The introductory chapter explains general principles of sed, introduces the four spaces of sed, addresses and ranges, and various command line flags.</p>
<p>Example 1: Replace â€œlambâ€ with â€œgoatâ€ on every line</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/lamb/goat/&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the famous s&#x2F;â€¦&#x2F;â€¦&#x2F; command. The s command substitutes the text in the first part of the command with the text in the second part. In this one-liner it replaces lamb with goat.</p>
<p>A very detailed explanation of how sed reads the lines, how it executes the commands and how the printing happens is presented in the freely available introduction chapter. Please take a look.</p>
<p>Example 2: Replace only the second occurrence of â€œlambâ€ with â€œgoatâ€ on every line</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/lamb/goat/2&#x27;</span><br></pre></td></tr></table></figure>
<p>Sed is the only tool that I know that takes a numeric argument to the s command. The numeric argument, in this case 2, specifies which occurrence of the text to replace. In this example only the 2nd occurrence of â€œlambâ€ gets replaced with â€œgoatâ€.</p>
<p>Example 3: Number the lines in a file</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed = file | sed &#x27;N; s/\n/: /&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is actually two one-liners. The first one uses the &#x3D; command that inserts a line containing the line number before every original line in the file. Then this output gets piped to the second sed command that joins two adjacent lines with the N command. When joining lines with the N command, a newline character \n is placed between them. Therefore it uses the s command to replace this newline \n with a colon followed by a space â€œ: â€œ.</p>
<p>So for example, if the file contains lines:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">good job</span><br><span class="line">sunny day</span><br></pre></td></tr></table></figure>
<p>Then after running the one-liner, the result is going to be:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1: hello world</span><br><span class="line">2: good job</span><br><span class="line">3: sunny day</span><br></pre></td></tr></table></figure>
<p>Example 4: Delete every 2nd line</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;n;d&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the n command that prints the current line (actually the current pattern space, see the introduction chapter for in-depth explanation), deletes it, and reads the next line. Then sed executes the d command that deletes the current line without printing. This way the 1st line gets printed, the 2nd line gets deleted, then the 3rd line gets printed again, then the 4th gets deleted, etc.</p>
<p>Example 5: ROT 13 encode every line</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;</span><br><span class="line">y/abcdefghijklmnopqrstuvwxyz/nopqrstuvwxyzabcdefghijklm/</span><br><span class="line">y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/NOPQRSTUVWXYZABCDEFGHIJKLM/</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure>
<p>Here the y&#x2F;set1&#x2F;set2&#x2F; command is used. The y command substitutes elements in the set1 with the corresponding elements in the set2. The first y command replaces all lowercase letters with their 13-char-shifted counterparts, and the second y command does the same for the uppercase letters. So for example, character a gets replaced by n, b gets replaced by o, character Z gets replaced by M, etc.</p>
<p>Sed is actually very powerful. Itâ€™s as powerful as a Turing machine, meaning you can write any computer program in it. Check out these programs written in sed. Run them as sed -f file.sed:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tetris</span><br><span class="line">Sokoban (game)</span><br><span class="line">Calculator</span><br><span class="line">Turing machine</span><br></pre></td></tr></table></figure>
<p>After you read the e-book youâ€™ll be able to understand all these complex programs!</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">æ–‡ç« ä½œè€…: </span><span class="post-copyright-info"><a href="https://magesfc.github.io">mage</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">æ–‡ç« é“¾æ¥: </span><span class="post-copyright-info"><a href="https://magesfc.github.io/mage/6a323979d022165779db1cbb3367540e235cec9e/">https://magesfc.github.io/mage/6a323979d022165779db1cbb3367540e235cec9e/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">ç‰ˆæƒå£°æ˜: </span><span class="post-copyright-info">æœ¬åšå®¢æ‰€æœ‰æ–‡ç« é™¤ç‰¹åˆ«å£°æ˜å¤–ï¼Œå‡é‡‡ç”¨ <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> è®¸å¯åè®®ã€‚è½¬è½½è¯·æ³¨æ˜æ¥è‡ª <a href="https://magesfc.github.io" target="_blank">é©¬å“¥ç§æˆ¿èœ</a>ï¼</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/cookbook/">cookbook</a><a class="post-meta__tags" href="/tags/sed/">sed</a></div><div class="post_share"><div class="social-share" data-image="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> æ‰“èµ</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/null" alt="å¾®ä¿¡"/></a><div class="post-qr-code-desc">å¾®ä¿¡</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/null" alt="æ”¯ä»˜å¯¶"/></a><div class="post-qr-code-desc">æ”¯ä»˜å¯¶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/mage/428e45833de1d6977f072fa67593f8a21d9a315c/"><img class="prev-cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">ä¸Šä¸€ç¯‡</div><div class="prev_info">Pythonå­¦ä¹ ä¹‹Primer_on_Python_Decorators</div></div></a></div><div class="next-post pull-right"><a href="/mage/2af42b0589d7a698da699f89aa9e0bbfb1825a3c/"><img class="next-cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">ä¸‹ä¸€ç¯‡</div><div class="next_info">JPAå­¦ä¹ æ€»ç»“</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>ç›¸å…³æ¨è</span></div><div class="relatedPosts-list"><div><a href="/mage/fbdc2108c9ff66cef6915dd7b0ca474e0f1bfcab/" title="Linuxå­¦ä¹ ä¹‹awkå­¦ä¹ ä¹‹cookbookæŠ€å·§"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linuxå­¦ä¹ ä¹‹awkå­¦ä¹ ä¹‹cookbookæŠ€å·§</div></div></a></div><div><a href="/mage/a718e01bee375dd72d94fd15211e2e4f41c0a52c/" title="Linuxå­¦ä¹ ä¹‹bashå­¦ä¹ ä¹‹cookbookæŠ€å·§"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linuxå­¦ä¹ ä¹‹bashå­¦ä¹ ä¹‹cookbookæŠ€å·§</div></div></a></div><div><a href="/mage/04947dc3d5b90a6c19672409e839d803a0aef01a/" title="Linuxå­¦ä¹ ä¹‹perlå­¦ä¹ ä¹‹cookbookæŠ€å·§"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-10</div><div class="title">Linuxå­¦ä¹ ä¹‹perlå­¦ä¹ ä¹‹cookbookæŠ€å·§</div></div></a></div><div><a href="/mage/bead5c222ebd755a0ea0b8165ff0663545d6c700/" title="Linuxå­¦ä¹ ä¹‹10ä¸ªæœ‰ç”¨çš„é“¾å¼æ“ä½œç¬¦åŠå…¶å®ä¾‹"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linuxå­¦ä¹ ä¹‹10ä¸ªæœ‰ç”¨çš„é“¾å¼æ“ä½œç¬¦åŠå…¶å®ä¾‹</div></div></a></div><div><a href="/mage/16b8c6357057536aa45c505f7c99cb9d22c87038/" title="Linuxå­¦ä¹ ä¹‹awkå­¦ä¹ ä¹‹Linux-awk-commandç³»åˆ—"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linuxå­¦ä¹ ä¹‹awkå­¦ä¹ ä¹‹Linux-awk-commandç³»åˆ—</div></div></a></div><div><a href="/mage/29b1dee9b6336ea01be4716d95ecfbad663018d6/" title="Linuxå­¦ä¹ ä¹‹bashå­¦ä¹ ä¹‹å‡ ä¸ªç‰¹æ®Šå˜é‡"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linuxå­¦ä¹ ä¹‹bashå­¦ä¹ ä¹‹å‡ ä¸ªç‰¹æ®Šå˜é‡</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mage</div><div class="author-info__description"> è¿™é‡Œæ˜¯ é©¬å“¥ çš„ä¸ªäººåšå®¢ </div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">æ–‡ç« </div><div class="length-num">161</div></a><a href="/tags/"><div class="headline">æ ‡ç­¾</div><div class="length-num">180</div></a><a href="/categories/"><div class="headline">åˆ†ç±»</div><div class="length-num">34</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mamh2021"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mamh2021" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>å…¬å‘Š</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>ç›®å½•</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-1-File-Spacing-Numbering-and-Text-Conversion-and-Substitution"><span class="toc-number">1.</span> <span class="toc-text">Part 1: File Spacing, Numbering and Text Conversion and Substitution</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-File-spacing"><span class="toc-number">1.1.</span> <span class="toc-text">1. File spacing.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Numbering"><span class="toc-number">1.2.</span> <span class="toc-text">2. Numbering.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Text-Conversion-and-Substitution"><span class="toc-number">1.3.</span> <span class="toc-text">3. Text Conversion and Substitution.</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>æœ€æ–°æ–‡ç« </span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/mage/a718e01bee375dd72d94fd15211e2e4f41c0a52c/" title="Linuxå­¦ä¹ ä¹‹bashå­¦ä¹ ä¹‹cookbookæŠ€å·§"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linuxå­¦ä¹ ä¹‹bashå­¦ä¹ ä¹‹cookbookæŠ€å·§"/></a><div class="content"><a class="title" href="/mage/a718e01bee375dd72d94fd15211e2e4f41c0a52c/" title="Linuxå­¦ä¹ ä¹‹bashå­¦ä¹ ä¹‹cookbookæŠ€å·§">Linuxå­¦ä¹ ä¹‹bashå­¦ä¹ ä¹‹cookbookæŠ€å·§</a><time datetime="2022-11-04T04:39:46.000Z" title="æ›´æ–°äº 2022-11-04 12:39:46">2022-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/84776adcfbfc963bd1f2f6d5bd3fd8d22c6a46a5/" title="jenkinsæ’ä»¶å­¦ä¹ ä¹‹show-build-parameters-plugin"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jenkinsæ’ä»¶å­¦ä¹ ä¹‹show-build-parameters-plugin"/></a><div class="content"><a class="title" href="/mage/84776adcfbfc963bd1f2f6d5bd3fd8d22c6a46a5/" title="jenkinsæ’ä»¶å­¦ä¹ ä¹‹show-build-parameters-plugin">jenkinsæ’ä»¶å­¦ä¹ ä¹‹show-build-parameters-plugin</a><time datetime="2022-11-04T03:53:50.000Z" title="æ›´æ–°äº 2022-11-04 11:53:50">2022-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/23369f1e1080d1a6749c477927cb9acccf216b36/" title="jenkinsæ’ä»¶å­¦ä¹ ä¹‹matrix-project-plugin"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jenkinsæ’ä»¶å­¦ä¹ ä¹‹matrix-project-plugin"/></a><div class="content"><a class="title" href="/mage/23369f1e1080d1a6749c477927cb9acccf216b36/" title="jenkinsæ’ä»¶å­¦ä¹ ä¹‹matrix-project-plugin">jenkinsæ’ä»¶å­¦ä¹ ä¹‹matrix-project-plugin</a><time datetime="2022-11-04T03:53:32.000Z" title="æ›´æ–°äº 2022-11-04 11:53:32">2022-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/f69d2317dbb9ce1dbfccbd61f81a402200d7547f/" title="jenkinsæ’ä»¶å­¦ä¹ ä¹‹job-parameter-summary-plugin"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jenkinsæ’ä»¶å­¦ä¹ ä¹‹job-parameter-summary-plugin"/></a><div class="content"><a class="title" href="/mage/f69d2317dbb9ce1dbfccbd61f81a402200d7547f/" title="jenkinsæ’ä»¶å­¦ä¹ ä¹‹job-parameter-summary-plugin">jenkinsæ’ä»¶å­¦ä¹ ä¹‹job-parameter-summary-plugin</a><time datetime="2022-11-04T03:53:14.000Z" title="æ›´æ–°äº 2022-11-04 11:53:14">2022-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/dd153582d58799584987955d6355cf3c32f1bc7f/" title="jenkinsæ’ä»¶å­¦ä¹ ä¹‹hidden-parameter-plugin"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jenkinsæ’ä»¶å­¦ä¹ ä¹‹hidden-parameter-plugin"/></a><div class="content"><a class="title" href="/mage/dd153582d58799584987955d6355cf3c32f1bc7f/" title="jenkinsæ’ä»¶å­¦ä¹ ä¹‹hidden-parameter-plugin">jenkinsæ’ä»¶å­¦ä¹ ä¹‹hidden-parameter-plugin</a><time datetime="2022-11-04T03:52:57.000Z" title="æ›´æ–°äº 2022-11-04 11:52:57">2022-11-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By mage</div><div class="framework-info"><span>æ¡†æ¶ </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>ä¸»é¢˜ </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="é˜…è¯»æ¨¡å¼"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="æµ…è‰²å’Œæ·±è‰²æ¨¡å¼è½¬æ¢"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="å•æ å’ŒåŒæ åˆ‡æ¢"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="è®¾ç½®"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="ç›®å½•"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="å›åˆ°é¡¶éƒ¨"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>