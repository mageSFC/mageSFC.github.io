<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux学习之perl学习之cookbook技巧 | 马哥私房菜</title><meta name="author" content="mage"><meta name="copyright" content="mage"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="perl 单行命令 解释 https:&#x2F;&#x2F;catonmat.net&#x2F;perl-book Perl One-Liners Explained, Part I: File Spacing Hi all! I am starting yet another article series here. Remember my two articles on Awk One-Liners Explained">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux学习之perl学习之cookbook技巧">
<meta property="og:url" content="https://magesfc.github.io/mage/04947dc3d5b90a6c19672409e839d803a0aef01a/">
<meta property="og:site_name" content="马哥私房菜">
<meta property="og:description" content="perl 单行命令 解释 https:&#x2F;&#x2F;catonmat.net&#x2F;perl-book Perl One-Liners Explained, Part I: File Spacing Hi all! I am starting yet another article series here. Remember my two articles on Awk One-Liners Explained">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg">
<meta property="article:published_time" content="2022-05-10T07:15:29.000Z">
<meta property="article:modified_time" content="2022-05-11T04:11:17.000Z">
<meta property="article:author" content="mage">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="cookbook">
<meta property="article:tag" content="perl">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg"><link rel="shortcut icon" href="http://www.blackshark.com/favicon.ico"><link rel="canonical" href="https://magesfc.github.io/mage/04947dc3d5b90a6c19672409e839d803a0aef01a/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: mage","link":"链接: ","source":"来源: 马哥私房菜","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux学习之perl学习之cookbook技巧',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-05-11 12:11:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">.card-announcement .social-button{margin:.6rem 0 0 0;text-align:center}.card-announcement .social-button a{display:block;background-color:var(--btn-bg);color:var(--btn-color);text-align:center;line-height:2.4;margin:4px 0}.card-announcement .social-button a:hover{background-color:var(--btn-hover-color)}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">152</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">170</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 精选文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> 🚀 快速开始</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/dc584b87/"><span> 📑 主题页面</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4aa8abbe/"><span> 🛠 主题配置-1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/ceeb73f/"><span> 🛠 主题配置-2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/98d20436/"><span> ❓ 主题问答</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4073eda/"><span> ⚡️ 进阶教程</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/198a4240/"><span> ✨ 更新日志</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://butterfly.js.org/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> 其他示例</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">马哥私房菜</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 精选文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> 🚀 快速开始</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/dc584b87/"><span> 📑 主题页面</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4aa8abbe/"><span> 🛠 主题配置-1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/ceeb73f/"><span> 🛠 主题配置-2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/98d20436/"><span> ❓ 主题问答</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4073eda/"><span> ⚡️ 进阶教程</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/198a4240/"><span> ✨ 更新日志</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://butterfly.js.org/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> 其他示例</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux学习之perl学习之cookbook技巧</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-10T07:15:29.000Z" title="发表于 2022-05-10 15:15:29">2022-05-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-11T04:11:17.000Z" title="更新于 2022-05-11 12:11:17">2022-05-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/">linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux学习之perl学习之cookbook技巧"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>perl 单行命令 解释</p>
<p><a target="_blank" rel="noopener" href="https://catonmat.net/perl-book">https://catonmat.net/perl-book</a></p>
<p>Perl One-Liners Explained, Part I: File Spacing</p>
<p>Hi all! I am starting yet another article series here. Remember my two articles on Awk One-Liners Explained and Sed One-Liners Explained? They have received more than 150,000 views total now and they attract several thousand new visitors every week. Inspired by their success, I am going to create my own perl1line.txt file and explain every single oneliner in it. I hope it becomes as popular as awk1line.txt and sed1line.txt.</p>
<p>A tiny intro to those unfamiliar with the awk1line.txt and sed1line.txt files – they contain around 80 useful awk and sed one-liners for doing various text file manipulations. Some examples are double spacing files, numbering lines, reversing text, and replacing certain words. They were all compiled by Eric Pement.</p>
<p>The article will be divided in seven or more parts. In parts 1 - 6 I’ll create the one-liners and explain them, and in the last part I will release the perl1line.txt file. I found that splitting the article in many parts is much easier to get it written and that’s what I will do.</p>
<p>Here is the general plan:</p>
<pre><code>Part I: File spacing (this part).
Part II: Line Numbering.
Part III: Calculations.
Part IV: String creation. Array creation.
Part V: Text conversion and substitution.
Part VI: Selective printing and deleting of certain lines.
Part VII: Handy regular expressions.
Part VIII: Release of perl1line.txt.
Part IX: Release of Perl One-Liners e-book.
</code></pre>
<p>These one-liners will make heavy use of Perl special variables. Luckily, a few years ago I compiled all the special vars in a single file and called it Perl special variable cheat-sheet. Even tho it’s mostly copied out of perldoc perlvar, it’s still handy to have in front of you. I suggest that you print it so that you always had them in front of you and you could memorize them faster.</p>
<p>Awesome news: I have written an e-book based on this article series. Check it out:<br>Perl book</p>
<p>Other than that, I can’t wait to start writing the article, so here I go:<br>File Spacing</p>
<ol>
<li>Double space a file.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;$\=&quot;\n&quot;&#x27;</span><br></pre></td></tr></table></figure>
This one-liner double spaces a file. There are three things to explain in this one-liner. The “-p” and “-e” command line options, and the “$&quot; variable.</li>
</ol>
<p>First let’s start with the “-e” option. The “-e” option can be used to enter a Perl program directly in the command line. Typically you don’t want to create source files for every small program. By using “-e” you can handily specify the program to execute on the command line.</p>
<p>Next the “-p” switch. Specifying “-p” to a Perl program causes it to assume the following loop around your program:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (&lt;&gt;) &#123;</span><br><span class="line">    # your program goes here</span><br><span class="line">&#125; continue &#123;</span><br><span class="line">    print or die &amp;#34;-p failed: $!\n&amp;#34;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This construct loops over all the input, executes your code and prints the value of “$”. This way you can effectively modify all or some lines of input. The “$” variable can be explained as an anonymous variable that gets filled with the good stuff.</p>
<p>The “$&quot; variable is similar to ORS in Awk. It gets appended after every “print” operation. Without any arguments “print” prints the contents of “$_” (the good stuff).</p>
<p>In this one-liner the code specified by “-e” is ‘$=“\n”‘, thus the whole program looks like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (&lt;&gt;) &#123;</span><br><span class="line">    $\ = &amp;#34;\n&amp;#34;;</span><br><span class="line">&#125; continue &#123;</span><br><span class="line">    print or die &amp;#34;-p failed: $!\n&amp;#34;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>What happens is that after reading each line, “$” gets filled with it (including the existing line’s newline), the “$&quot; gets set to a newline itself and “print” is called. As I already mentioned, without any arguments “print” prints the contents of “$” and “$&quot; gets appended at the end. The result is that each line gets printed unmodified and it’s followed by the “$&quot; which has been set to newline. The input has been double-spaced.</p>
<p>There is actually no need to set “$&quot; to newline on each line. It was just the shortest possible one-liner that double-spaced the file. Here are several others that do the same:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;BEGIN &#123; $\=&quot;\n&quot; &#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>This one sets the “$&quot; to newline just once before Perl does anything (BEGIN block gets executed before everything else).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;$_ .= &quot;\n&quot;;&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is equivalent to:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (&lt;&gt;) &#123;</span><br><span class="line">    $_ = $_ . &amp;#34;\n&amp;#34;</span><br><span class="line">&#125; continue &#123;</span><br><span class="line">    print or die &amp;#34;-p failed: $!\n&amp;#34;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It appends another new-line at the end of each line, then prints it out.</p>
<p>The cleanest and coolest way to do it is probably use the substitution “s&#x2F;&#x2F;&#x2F;“ operator:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;s/$/\n/&#x27;</span><br></pre></td></tr></table></figure>
<p>It replaces the regular expression “$” that matches at the end of line with a newline, effectively adding a newline at the end.</p>
<ol start="2">
<li>Double space a file, except the blank lines.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;$_ .= &quot;\n&quot; unless /^$/&#x27;</span><br></pre></td></tr></table></figure>
This one-liner double spaces all lines that are not completely empty. It does it by appending a newline character at the end of each line that is not blank. The “unless” means “if not”. And “unless &#x2F;^$&#x2F;“ means “if not ‘beginning is end of line’”. The condition “beginning is end of line” is true only for lines that contain the newline character.</li>
</ol>
<p>Here is how it looks when expanded:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (&lt;&gt;) &#123;</span><br><span class="line">    if ($_ !~ /^$/) &#123;</span><br><span class="line">        $_ .= &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; continue &#123;</span><br><span class="line">    print or die &amp;#34;-p failed: $!\n&amp;#34;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A better test that takes spaces and tabs on the line into account is this one:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;$_ .= &quot;\n&quot; if /\S/&#x27;</span><br></pre></td></tr></table></figure>
<p>Here the line is matched against “\S”. “\S” is a regular expression that is the inverse of “\s”. The inverse of “\s” is any non-whitespace character. The result is that every line that has at least one non-whitespace character (tab, vertical tab, space, etc) gets double spaced.</p>
<ol start="3">
<li><p>Triple space a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;$\=&quot;\n\n&quot;&#x27;</span><br></pre></td></tr></table></figure>
<p>Or</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;$_.=&quot;\n\n&quot;&#x27;</span><br></pre></td></tr></table></figure>
<p>They are the same as one-liner #1, except that two new-lines get appended after each line.</p>
</li>
<li><p>N-space a file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;$_.=&quot;\n&quot;x7&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses inserts 7 new lines after each line. Notice how I used ‘“\n” x 7’ to repeat the newline char 7 times. The “x” operator repeats the thing on the left N times.</p>
</li>
</ol>
<p>For example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e &#x27;print &quot;foo&quot;x5&#x27;</span><br></pre></td></tr></table></figure>
<p>would print “foofoofoofoofoo”.</p>
<ol start="5">
<li><p>Add a blank line before every line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;s//\n/&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the “s&#x2F;pattern&#x2F;replacement&#x2F;“ operator. It substitutes the first pattern (regular expression) in the “$_” variable with the replacement. In this one-liner the pattern is empty, meaning it matches any position between chars (and in this case it’s the position before first char) and replaces it with “\n”. The effect is that a newline char gets inserted before the line.</p>
</li>
<li><p>Remove all blank lines.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print unless /^$/&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses “-n” flag. The “-n” flag causes Perl to assume to following loop around your program:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LINE:</span><br><span class="line">while (&lt;&gt;) &#123;</span><br><span class="line">    # your program goes here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>What happens here is that each line gets read by the diamond “&lt;&gt;” operator and is placed in the dolar underscore special variable “$_”. At this moment you are free to do with it whatever you want. You specify that in your main program text.</p>
</li>
</ol>
<p>In this one-liner the main program is “print unless &#x2F;^$&#x2F;“, it gets inserted in the while loop above and the whole Perl program becomes:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LINE:</span><br><span class="line">while (&lt;&gt;) &#123;</span><br><span class="line">    print unless /^$/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Unraveling it further:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LINE:</span><br><span class="line">while (&lt;&gt;) &#123;</span><br><span class="line">    print $_ unless $_ =~ /^$/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This one-liner prints all non-blank lines.</p>
<p>A few other ways to do the same:</p>
<p>perl -lne ‘print if length’</p>
<p>This one uses the “-l” command line argument. The “-l” automatically chomps the input line (basically gets rid of newline at the end). Next the line is tested for its length. If there are any chars left, it evals to true and the line gets printed.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if /\S/&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner behaves differently than the “print unless &#x2F;^$&#x2F;“ one-liner. The “print unless &#x2F;^$&#x2F;“ one-liner prints lines with spaces and tabs, this one doesn’t.</p>
<ol start="7">
<li>Remove all consecutive blank lines, leaving just one.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -00 -pe &#x27;&#x27;</span><br></pre></td></tr></table></figure>
Ok, this is really tricky, ain’t it? First of all it does not have any code, the -e is empty. Next it has a silly -00 command line option. This command line option turns paragraph slurp mode on. A paragraph is text between two newlines. All the other newlines get ignored. The paragraph gets put in “$_” and the “-p” option prints it out.</li>
</ol>
<p>Later I found a shorter version of this one-liner:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -00pe0</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>Compress&#x2F;expand all blank lines into N consecutive ones.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -00 -pe &#x27;$_.=&quot;\n&quot;x4&#x27;</span><br></pre></td></tr></table></figure>
This one-liner combines the previous one and one-liner #4. It slurps lines paragraph wise, then appends (N-1) new-line. This one-liner expands (or compresses) all new-lines to 5 (“\n” x 4 prints four, and there was one at the end of paragraph itself, so 5).</li>
</ol>
<p>Perl One-Liners Explained, Part II: Line Numbering</p>
<p>This is the second part of a seven-part article on Perl one-liners. In this part I will create various one-liners for line numbering. See part one for introduction of the series.</p>
<p>Perl one-liners is my attempt to create “perl1line.txt” that is similar to “awk1line.txt” and “sed1line.txt” that have been so popular among Awk and Sed programmers.</p>
<p>The article on Perl one-liners will consist of at least seven parts:</p>
<pre><code>Part I: File spacing.
Part II: Line numbering (this part).
Part III: Calculations.
Part IV: String creation. Array creation.
Part V: Text conversion and substitution.
Part VI: Selective printing and deleting of certain lines.
Part VII: Handy regular expressions.
Part VIII: Release of perl1line.txt.
Part IX: Release of Perl One-Liners e-book.
</code></pre>
<p>The one-liners will make heavy use of Perl special variables. A few years ago I compiled all the Perl special variables in a single file and called it Perl special variable cheat-sheet. Even tho it’s mostly copied out of perldoc perlvar, it’s still handy to have in front of you. Print it!</p>
<p>Awesome news: I have written an e-book based on this article series. Check it out:<br>Perl book</p>
<p>And here are today’s one-liners:<br>Line Numbering</p>
<ol start="9">
<li>Number all lines in a file.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;$_ = &quot;$. $_&quot;&#x27;</span><br></pre></td></tr></table></figure>
As I explained in the first one-liner, “-p” causes Perl to assume a loop around the program (specified by “-e”) that reads each line of input into the “ $ “ variable, executes the program and then prints the “ $ “ variable.</li>
</ol>
<p>In this one-liner I simply modify “ $_ “ and prepend the “ $. “ variable to it. The special variable “ $. “ contains the current line number of input.</p>
<p>The result is that each line gets its line number prepended.</p>
<ol start="10">
<li>Number only non-empty lines in a file.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;$_ = ++$a.&quot; $_&quot; if /./&#x27;</span><br></pre></td></tr></table></figure>
Here we employ the “action if condition” statement that executes “action” only if “condition” is true. In this case the condition is a regular expression “&#x2F;.&#x2F;“, which matches any character except newline (that is, it matches a non-empty line); and the action is “ $ &#x3D; ++$a.” $” “, which prepends variable “ $a “ incremented by one to the current line. As we didn’t use strict pragma, $a was created automatically.</li>
</ol>
<p>The result is that at each non-empty line “ $a “ gets incremented by one and prepended to that line. And at each empty line nothing gets modified and the empty line gets printed as is.</p>
<ol start="11">
<li>Number and print only non-empty lines in a file (drop empty lines).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print ++$a.&quot; $_&quot; if /./&#x27;</span><br></pre></td></tr></table></figure>
This one-liner uses the “-n” program argument that places the line in “ $_ “ variable and then executes the program specified by “-e”. Unlike “-p”, it does not print the line after executing code in “-e”, so we have to call “print” explicitly to get it printed.</li>
</ol>
<p>The one-liner calls “print” only on lines that have at least one character in them. And exactly like in the previous one-liner, it increments the line number in variable “ $a “ by one for each non-empty line.</p>
<p>The empty lines simply get ignored and never get printed.</p>
<ol start="12">
<li><p>Number all lines but print line numbers only non-empty lines.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;$_ = &quot;$. $_&quot; if /./&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is similar to one-liner #10. Here I modify the “ $_ “ variable that holds the entire line only if the line has at least one character. All other lines (empty ones) get printed without line numbers.</p>
</li>
<li><p>Number only lines that match a pattern, print others unmodified.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;$_ = ++$a.&quot; $_&quot; if /regex/&#x27;</span><br></pre></td></tr></table></figure>
<p>Here we again use the “action if condition” statement but the condition in this case is a pattern (regular expression) “&#x2F;regex&#x2F;“. The action is the same as in one-liner #10. I don’t want to repeat, see #10 for explanation.</p>
</li>
<li><p>Number and print only lines that match a pattern.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print ++$a.&quot; $_&quot; if /regex/&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is almost exactly like #11. The only difference is that it prints numbered lines that match only “&#x2F;regex&#x2F;“.</p>
</li>
<li><p>Number all lines, but print line numbers only for lines that match a pattern.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;$_ = &quot;$. $_&quot; if /regex/&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is similar to the previous one-liner and to one-liner #12. Here the line gets its line number prepended if it matches a &#x2F;regex&#x2F;, otherwise it just gets printed without a line number.</p>
</li>
<li><p>Number all lines in a file using a custom format (emulate cat -n).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;printf &quot;%-5d %s&quot;, $., $_&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the formatted print “printf” function to print the line number together with line. In this particular example the line numbers are left aligned on 5 char boundary.</p>
</li>
</ol>
<p>Some other nice format strings are “%5d” that right-aligns line numbers on 5 char boundary and “%05d” that zero-fills and right-justifies the line numbers.</p>
<p>Here my Perl printf cheat sheet might come handy that lists all the possible format specifiers.</p>
<ol start="17">
<li>Print the total number of lines in a file (emulate wc -l).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -lne &#x27;END &#123; print $. &#125;&#x27;</span><br></pre></td></tr></table></figure>
This one-liner uses the “END” block that Perl probably took as a feature from Awk language. The END block gets executed after the program has executed. In this case the program is the hidden loop over the input that was created by the “-n” argument. After it has looped over the input, the special variable “ $. “ contains the number of lines there was in the input. The END block prints this variable. The “ -l “ parameter sets the output record separator for “print” to a newline (so that we didn’t have to print “$.\n”).</li>
</ol>
<p>Another way to do the same is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print $n=()=&amp;lt;&amp;gt;&#x27;</span><br></pre></td></tr></table></figure>
<p>This is a tricky one, but easy to understand if you know about Perl contexts. In this one-liner the “ ()&#x3D;&lt;&gt; “ part causes the &lt;&gt; operator (the diamond operator) to evaluate in list context, that causes the diamond operator to read the whole file in a list. Next, “ $n “ gets evaluated in scalar context. Evaluating a list in a scalar context returns the number of elements in the list. Thus the “ $n&#x3D;()&#x3D;&lt;&gt; “ construction is equal to the number of lines in the input, that is number of lines in the file. The print statement prints this number out. The “ -l “ argument makes sure a newline gets added after printing out this number.</p>
<p>This is the same as writing the following, except longer:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print scalar(()=&amp;lt;&amp;gt;)&#x27;</span><br></pre></td></tr></table></figure>
<p>And completely obvious version:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print scalar(@foo=&amp;lt;&amp;gt;)&#x27;</span><br></pre></td></tr></table></figure>
<p>Yet another way to do it:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;&#125;&#123;print $.&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the eskimo operator “}{“ in conjunction with “-n” command line argument. As I explained in one-liner #11, the “-n” argument forces Perl to assume a “ while(&lt;&gt;) { } “ loop around the program. The eskimo operator forces Perl to escape the loop, and the program turns out to be:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (&lt;&gt;) &#123;</span><br><span class="line">&#125;&#123;                    # eskimo operator here</span><br><span class="line">    print $.;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It’s easy to see that this program just loops over all the input and after it’s done doing so, it prints the “ $. “, which is the number of lines in the input.</p>
<ol start="18">
<li>Print the number of non-empty lines in a file.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print scalar(grep&#123;/./&#125;&amp;lt;&amp;gt;)&#x27;</span><br></pre></td></tr></table></figure>
This one-liner uses the “grep” function that is similar to the grep Unix command. Given a list of values, “ grep {condition} “ returns only those values that match condition. In this case the condition is a regular expression that matches at least one character, so the input gets filtered and the “grep{&#x2F;.&#x2F;}” returns all lines that were non empty. To get the number of characters we evaluate the list in scalar context and print the result. (As I mentioned in the previous one-liner list in scalar context evaluates to number of elements in the list).</li>
</ol>
<p>A golfer’s version of this one-liner would be to replace “scalar()” with “ ~~ “ (double bitwise negate), thus it can be shortened:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print ~~grep&#123;/./&#125;&amp;lt;&amp;gt;&#x27;</span><br></pre></td></tr></table></figure>
<p>This can be made even shorter:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print~~grep/./,&amp;lt;&amp;gt;&#x27;</span><br></pre></td></tr></table></figure>
<ol start="19">
<li>Print the number of empty lines in a file.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -lne &#x27;$a++ if /^$/; END &#123;print $a+0&#125;&#x27;</span><br></pre></td></tr></table></figure>
Here I use variable “ $a “ to count how many empty lines have I encountered. Once I have finished looping over all the lines, I print the value of $a in the END block. I use “ $a+0 “ construction to make sure “ 0 “ gets output if no lines were empty.</li>
</ol>
<p>I could have also modified the previous one-liner:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print scalar(grep&#123;/^$/&#125;&amp;lt;&amp;gt;)&#x27;</span><br></pre></td></tr></table></figure>
<p>Or written it with “ ~~ “:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print ~~grep&#123;/^$/&#125;&amp;lt;&amp;gt;&#x27;</span><br></pre></td></tr></table></figure>
<p>These last two versions are not as effective, as they would read the whole file in memory. Where as the first one would do it line by line.</p>
<ol start="20">
<li>Print the number of lines in a file that match a pattern (emulate grep -c).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -lne &#x27;$a++ if /regex/; END &#123;print $a+0&#125;&#x27;</span><br></pre></td></tr></table></figure>
This one-liner is basically the same as the previous one, except it increments the line counter $a by one in case a line matches a regular expression &#x2F;regex&#x2F;.</li>
</ol>
<p>Perl One-Liners Explained, Part III: Calculations</p>
<p>This is the third part of a seven-part article on Perl one-liners. In this part I will create various one-liners for calculations. See part one for introduction of the series.</p>
<p>Perl one-liners is my attempt to create “perl1line.txt” that is similar to “awk1line.txt” and “sed1line.txt” that have been so popular among Awk and Sed programmers.</p>
<p>The article on Perl one-liners will consist of at least seven parts:</p>
<pre><code>Part I: File spacing.
Part II: Line numbering.
Part III: Calculations (this part).
Part IV: String creation. Array creation.
Part V: Text conversion and substitution.
Part VI: Selective printing and deleting of certain lines.
Part VII: Handy regular expressions.
Part VIII: Release of perl1line.txt.
Part IX: Release of Perl One-Liners e-book.
</code></pre>
<p>After I’m done explaining all these one-liners, I’ll publish an ebook. Subscribe to my blog to know when that happens!</p>
<p>The one-liners will make heavy use of Perl special variables. A few years ago I compiled all the Perl special variables in a single file and called it Perl special variable cheat-sheet. Even tho it’s mostly copied out of perldoc perlvar, it’s still handy to have in front of you, so print it.</p>
<p>Awesome news: I have written an e-book based on this article series. Check it out:<br>Perl book</p>
<p>And here are today’s one-liners:<br>Calculations</p>
<ol start="21">
<li>Check if a number is a prime.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -lne &#x27;(1x$_) !~ /^1?$|^(11+?)\1+$/ &amp;&amp; print &quot;$_ is prime&quot;&#x27;</span><br></pre></td></tr></table></figure>
This one-liner uses an ingenious regular expression to detect if a given number is a prime or not. Don’t take it too seriously, though. I included it for its artistic value.</li>
</ol>
<p>First, the number is converted in its unary representation by “ (1x$_) “. For example, 5 gets converted into “ 1x5 “, which is “ 11111 “.</p>
<p>Next, the unary number gets tested against the ingenious regular expression. If it doesn’t match, the number is a prime, otherwise it’s a composite.</p>
<p>The regular expression works this way. It consists of two parts “ ^1?$ “ and “ ^(11+?)\1+$ “.</p>
<p>The first part matches “ 1 “ and empty string. Clearly, empty string and 1 are not prime numbers, therefore this regular expression matches, which indicated that they are not prime numbers.</p>
<p>The second part determines if two or more 1s repeatedly make up the whole number. If two or mores 1s repeatedly make up the whole number, the regex matches, which means that the number is composite. Otherwise it’s a prime.</p>
<p>Let’s look at the second regex part on numbers 5 and 6.</p>
<p>The number 5 in unary representation is “ 11111 “. The “ (11+?) “ matches first two ones “ 11 “. The back-reference “ \1 “ becomes “ 11 “ and the whole regex now becomes “ ^11(11)+$ “. It can’t match five ones, therefore it fails. But since it used “ +? “, it backtracks and matches the first three ones “ 111 “. The back-reference becomes “ 111 “ and the whole regex becomes “ ^111(111)+$ “. It doesn’t match again. This repeats for “ 1111 “ and “ 11111 “, which also don’t match, therefore the whole regex doesn’t match and the number is a prime.</p>
<p>The number 4 in unary representation is “ 1111 “. The “ (11+?) “ matches the first two ones “ 11 “. The back-reference “ \1 “ becomes “ 11 “ and the regex becomes “ ^11(11)+$ “. It matches the original string, therefore the number is not a prime.</p>
<p>The “ -lne “ command line options have been explained in parts one and two.</p>
<ol start="22">
<li>Print the sum of all the fields on a line.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MList::Util=sum -alne &#x27;print sum @F&#x27;</span><br></pre></td></tr></table></figure>
This one-liner turns on field auto-splitting with “ -a “ command line option and imports the “sum” function from “List::Util” module with “ -MList::Util&#x3D;sum “ option. The “List::Util” is in the Perl core so you don’t need to worry about installing it.</li>
</ol>
<p>As a result of auto-splitting the split fields end up in the “ @F “ array and the “ sum “ function just sums them up.</p>
<p>The -Mmodule&#x3D;arg option imports arg from module and is the same as writing:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use module qw(arg)</span><br></pre></td></tr></table></figure>
<p>This one-liner is equivalent to the following:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use List::Util qw(sum);</span><br><span class="line">while (&lt;&gt;) &#123;</span><br><span class="line">    @F = split(&amp;#39; &amp;#39;);</span><br><span class="line">    print sum @F, &amp;#34;\n&amp;#34;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="23">
<li>Print the sum of all the fields on all lines.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MList::Util=sum -alne &#x27;push @S,@F; END &#123; print sum @S &#125;&#x27;</span><br></pre></td></tr></table></figure>
This one-liner keeps pushing the split fields in “ @F “ to the “ @S “ array. Once the input is over and perl is about quit, END { } block gets called that outputs the sum of all items in @F. This sum is the sum of all fields over all lines.</li>
</ol>
<p>This solution isn’t too good - it creates a massive array @S. A better solution is to keep just the running:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MList::Util=sum -alne &#x27;$s += sum @F; END &#123; print $s &#125;&#x27;</span><br></pre></td></tr></table></figure>
<ol start="24">
<li>Shuffle all fields on a line.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MList::Util=shuffle -alne &#x27;print &quot;@&#123;[shuffle @F]&#125;&quot;&#x27;</span><br></pre></td></tr></table></figure>
This is almost the same as one-liner #22 above. Instead of summing all fields, it shuffles and prints them.</li>
</ol>
<p>The “ @{[shuffle @F]} “ construct creates an array reference to the contents of “ shuffle @F “ and “ @ { … } “ dereferences it. This is a tricky way to execute code inside quotes. It was needed to get the values of shuffled @F separated by a space when printing them out.</p>
<p>Another way to do the same is join the elements of @F by a space, but it’s longer:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MList::Util=shuffle -alne &#x27;print join &quot; &quot;, shuffle @F&#x27;</span><br></pre></td></tr></table></figure>
<ol start="25">
<li><p>Find the minimum element on a line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MList::Util=min -alne &#x27;print min @F&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the “min” function from “List::Util”. It’s similar to all the previous ones. After the line has been automatically split by “ -a “, the “min” function finds minimum element and prints it.</p>
</li>
<li><p>Find the minimum element over all the lines.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MList::Util=min -alne &#x27;@M = (@M, @F); END &#123; print min @M &#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is a combination of the previous one and the #23.</p>
</li>
</ol>
<p>The “@M &#x3D; (@M, @F)” construct is the same as “push @M, @F”. It appends the contents of @F to the array @M.</p>
<p>This one-liner stores all the data in memory. If you run it on a 10 terabyte file, it will die. Therefore it’s better to keep the running minimum element in memory and print it out at the end:</p>
<p>perl -MList::Util&#x3D;min -alne ‘$min &#x3D; min @F; $rmin &#x3D; $min unless defined $rmin &amp;&amp; $min &gt; $rmin; END { print $rmin }’</p>
<p>It finds the minimum of each line and stores in $min, then it checks if $min is smaller than the running minimum. Once the input ends, it prints the running minimum, which is the smallest value over all input.</p>
<ol start="27">
<li><p>Find the maximum element on a line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MList::Util=max -alne &#x27;print max @F&#x27;</span><br></pre></td></tr></table></figure>
<p>This is the same as #25, except “min” has been replaced with “max”.</p>
</li>
<li><p>Find the maximum element over all the lines.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MList::Util=max -alne &#x27;@M = (@M, @F); END &#123; print max @M &#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>This is the same as #26.</p>
</li>
</ol>
<p>Or:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MList::Util=max -alne &#x27;$max = max @F; $rmax = $max unless defined $rmax &amp;&amp; $max &lt; $rmax; END &#123; print $rmax &#125;&#x27;</span><br></pre></td></tr></table></figure>
<ol start="29">
<li>Replace each field with its absolute value.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -alne &#x27;print &quot;@&#123;[map &#123; abs &#125; @F]&#125;&quot;&#x27;</span><br></pre></td></tr></table></figure>
This one-liner auto-splits the line by “ -a “ command line option. The split fields, as I already explained, end up in the @F variable. Next it calls the absolute value function “abs” on each field by the help of “map” function. Finally it prints it joins all the fields by the help of array interpolation in double quotes.</li>
</ol>
<p>The “ @{ … } “ construct was explained in one-liner #24.</p>
<ol start="30">
<li><p>Find the total number of fields (words) on each line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -alne &#x27;print scalar @F&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner forces to evaluate the @F in scalar context, which in Perl means “the number of elements in @F.” Therefore this one-liner prints out the number of elements on each line.</p>
</li>
<li><p>Print the total number of fields (words) on each line followed by the line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -alne &#x27;print scalar @F, &quot; $_&quot;&#x27;</span><br></pre></td></tr></table></figure>
<p>This is exactly the same as #30, except “ $ “ is added at the end that prints out the whole line. (Remember that “ -n “ option caused each line to be put in the $ variable.)</p>
</li>
<li><p>Find the total number of fields (words) on all lines.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -alne &#x27;$t += @F; END &#123; print $t&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>Here we just keep adding the number of fields on each line to variable “ $t “, and at the end we print it out. The result is number of words on all lines.</p>
</li>
<li><p>Print the total number of fields that match a pattern.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -alne &#x27;map &#123; /regex/ &amp;&amp; $t++ &#125; @F; END &#123; print $t &#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the “ map “ function that applies some operation on each of the elements in @F array. In this case the operation checks if each element matches &#x2F;regex&#x2F; and if it does, it increments variable $t. At the end it prints this variable $t that contains the number of fields that matched &#x2F;regex&#x2F; pattern.</p>
</li>
</ol>
<p>A better way to do it is by looping:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -alne &#x27;$t += /regex/ for @F; END &#123; print $t &#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>Each element in code&gt;@F&lt;&#x2F;code is tested against regex. If it matches, &#x2F;regex&#x2F; returns 1 (true), which gets added to variable $t. This way the number of matches get counted in $t.</p>
<p>The best way is to use grep in scalar context:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -alne &#x27;$t += grep /regex/, @F; END &#123; print $t &#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>Grep in scalar context returns the number of matches. This number gets accumulated in $t.</p>
<ol start="34">
<li><p>Print the total number of lines that match a pattern.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -lne &#x27;/regex/ &amp;&amp; $t++; END &#123; print $t &#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>The &#x2F;regex&#x2F; evaluates to true if the current line of input matches this regular expression. Writing &#x2F;regex&#x2F; &amp;&amp; $t++ is the same as if ($_ &#x3D;~ &#x2F;regex&#x2F;) { $t++ }, which increments variable $t if the line matched the pattern. Finally in the END block the variable $t contains the total number of pattern matches and it gets printed out.</p>
</li>
<li><p>Print the number PI to n decimal places.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -Mbignum=bpi -le &#x27;print bpi(21)&#x27;</span><br></pre></td></tr></table></figure>
<p>The bignum package exports bpi function that calculates constant PI to wanted accuracy. This one-liner prints PI to 20 decimal places.</p>
</li>
</ol>
<p>The bignum library also exports constant PI alone to 39 decimal places:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -Mbignum=PI -le &#x27;print PI&#x27;</span><br></pre></td></tr></table></figure>
<ol start="36">
<li>Print the number E to n decimal places.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -Mbignum=bexp -le &#x27;print bexp(1,21)&#x27;</span><br></pre></td></tr></table></figure>
The bignum library also exports bexp function that takes two arguments - the power to raise e to and accuracy. This one-liner prints the constant e to 20 decimal places.</li>
</ol>
<p>You can print the value of e^2 to 30 decimal places this way:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -Mbignum=bexp -le &#x27;print bexp(2,31)&#x27;</span><br></pre></td></tr></table></figure>
<p>Just the same as with PI, bignum exports the constant e alone to 39 decimal places:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -Mbignum=e -le &#x27;print e&#x27;</span><br></pre></td></tr></table></figure>
<ol start="37">
<li><p>Print UNIX time (seconds since Jan 1, 1970, 00:00:00 UTC).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print time&#x27;</span><br></pre></td></tr></table></figure>
<p>The built-in function “time” returns seconds since the epoch.</p>
</li>
<li><p>Print GMT (Greenwich Mean Time) and local computer time.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print scalar gmtime&#x27;</span><br></pre></td></tr></table></figure>
<p>The “gmtime” function is a Perl built-in function. If used in scalar context, it prints the time localized to Greenwich time zone.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print scalar localtime&#x27;</span><br></pre></td></tr></table></figure>
<p>The “localtime” built-in function acts the same way as “gmtime”, except it prints the computer’s local time.</p>
</li>
</ol>
<p>In array context both “gmtime” and “localtime” return a 9 element list (struct tm) with the following elements.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">($second,             [0]</span><br><span class="line">$minute,              [1]</span><br><span class="line">$hour,                [2]</span><br><span class="line">$month_day,           [3]</span><br><span class="line">$month,               [4]</span><br><span class="line">$year,                [5]</span><br><span class="line">$week_day,            [6]</span><br><span class="line">$year_day,            [7]</span><br><span class="line">$is_daylight_saving   [8]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>You may slice this list, or print individual elements if you need just some part of this information.</p>
<p>For example, to print H:M:S, slice elements 2, 1 and 0 from localtime:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print join &quot;:&quot;, (localtime)[2,1,0]&#x27;</span><br></pre></td></tr></table></figure>
<ol start="39">
<li>Print yesterday’s date.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MPOSIX -le &#x27;@now = localtime; $now[3] -= 1; print scalar localtime mktime @now&#x27;</span><br></pre></td></tr></table></figure>
Remember that localtime returns a 9-list (see above) of various date elements. The 4th element in the list is current month’s day. If we subtract one from it we get yesterday. The “mktime” function constructs a Unix epoch time from this modified 9-list. And “scalar localtime” construct prints out the new date, which is yesterday.</li>
</ol>
<p>The POSIX package was needed because it exports mktime function. It’s supposed to normalize negative values.</p>
<ol start="40">
<li>Print date 14 months, 9 days and 7 seconds ago.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MPOSIX -le &#x27;@now = localtime; $now[0] -= 7; $now[4] -= 14; $now[7] -= 9; print scalar localtime mktime @now&#x27;</span><br></pre></td></tr></table></figure>
This one-liner modifies 0th, 4th, and 7th elements of @now list. The 0th is seconds, the 4th is months and 7th is days (see the table of 9 element time list above).</li>
</ol>
<p>Next, mktime creates Unix time from this new structure, and localtime, evaluated in scalar context, prints out the date that was 14 months, 9 days and 7 seconds ago.</p>
<ol start="41">
<li>Calculate factorial.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MMath::BigInt -le &#x27;print Math::BigInt-&gt;new(5)-&gt;bfac()&#x27;</span><br></pre></td></tr></table></figure>
This one-liner uses bfac() function from Math::BigInt module that is in the Perl core (no need to install).</li>
</ol>
<p>Math::BigInt-&gt;new(5) construction creates a new Math::BigInt object with value 5, then a method bfac() is called on the newly created object to calculate the factorial of 5. Change 5 to any number you want to find factorial for the value you are interested in.</p>
<p>Another way to calculate factorial is by just multiplying numbers from 1 to n together:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;$f = 1; $f *= $_ for 1..5; print $f&#x27;</span><br></pre></td></tr></table></figure>
<p>Here we initially set $f to 1. Then do a loop from 1 to 5 and multiply $f by each of the values. The result is 12345, which is the factorial of 5.</p>
<ol start="42">
<li>Calculate greatest common divisor.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MMath::BigInt=bgcd -le &#x27;print bgcd(@list_of_numbers)&#x27;</span><br></pre></td></tr></table></figure>
Math::BigInt has several other useful math functions. One of them is bgcd that calculates the greatest common divisor of a list of numbers.</li>
</ol>
<p>For example, to find gcd of (20, 60, 30), you’d execute the one-liner this way:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MMath::BigInt=bgcd -le &#x27;print bgcd(20,60,30)&#x27;</span><br></pre></td></tr></table></figure>
<p>Surely, you can also use Euclid’s algorithm. Given two numbers $n and $m, this one-liner finds the gcd of $n and $m. The result is stored in $m.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;$n = 20; $m = 35; ($m,$n) = ($n,$m%$n) while $n; print $m&#x27;</span><br></pre></td></tr></table></figure>
<ol start="43">
<li>Calculate least common multiple.</li>
</ol>
<p>Another function from Math::BigInt is lcm - the least common multiplicator. This one-liner finds lcm of (35, 20, 8):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MMath::BigInt=blcm -le &#x27;print blcm(35,20,8)&#x27;</span><br></pre></td></tr></table></figure>
<p>If you know some number theory, then you’ll recall that there is a connection between gcd and lcm. Given two numbers $n and $m, their lcm is $n*$m&#x2F;gcd($n,$m), therefore one-liner follows:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;$a = $n = 20; $b = $m = 35; ($m,$n) = ($n,$m%$n) while $n; print $a*$b/$m&#x27;</span><br></pre></td></tr></table></figure>
<ol start="44">
<li>Generate 10 random numbers between 5 and 15 (excluding 15).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;$n=10; $min=5; $max=15; $, = &quot; &quot;; print map &#123; int(rand($max-$min))+$min &#125; 1..$n&#x27;</span><br></pre></td></tr></table></figure>
You can modify this one-liner by changing variables $n, $min, $max. The variable $n stands for how many random numbers to generate, and [$min,$max) is the generation range.</li>
</ol>
<p>The variable $, gets set to a space because it’s the output field separator for print and it’s undef by default. If we didn’t set it to a space, the numbers would get printed concatenated together.</p>
<ol start="45">
<li>Find and print all permutations of a list.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MAlgorithm::Permute -le &#x27;$l = [1,2,3,4,5]; $p = Algorithm::Permute-&gt;new($l); print @r while @r = $p-&gt;next&#x27;</span><br></pre></td></tr></table></figure>
This one-liner uses the object-oriented interface of Algorithm::Permute module to find the permutations (all ways to rearrange items).</li>
</ol>
<p>The constructor of Algorithm::Permute takes an array reference to an array of elements to permute. In this particular one-liner the elements are numbers 1, 2, 3, 4, 5.</p>
<p>The next object function returns the next permutation. Calling it repeatedly iterates over all permutations. Each permutation is put in code&gt;@r&lt;&#x2F;code array and is then printed.</p>
<p>Please note that the output list gets large really quickly. There are n! permutations for a list of n elements.</p>
<p>Another way to print out all permutations is to use the exported permute subroutine:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MAlgorithm::Permute -le &#x27;@l = (1,2,3,4,5); Algorithm::Permute::permute &#123; print &quot;@l&quot; &#125; @l&#x27;</span><br></pre></td></tr></table></figure>
<ol start="46">
<li>Generate the power set.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MList::PowerSet=powerset -le &#x27;@l = (1,2,3,4,5); for (@&#123;powerset(@l)&#125;) &#123; print &quot;@$_&quot; &#125;&#x27;</span><br></pre></td></tr></table></figure>
Here I use the List::PowerSet module from CPAN.</li>
</ol>
<p>It exports the powerset function, which takes a list of elements and returns a reference to a list containing references to subset lists.</p>
<p>In the for() loop, I call the powerset function, pass it the list of elements in code&gt;@l&lt;&#x2F;code. Next I dereference the return value of powerset, which is a reference to a list of subsets. Next, I dereference each individual subset code&gt;@$_&lt;&#x2F;code and print it.</p>
<p>For a set of n elements, there are exactly 2n subsets in the powerset.</p>
<ol start="47">
<li>Convert an IP address to unsigned integer.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;$i=3; $u += ($_&lt;&lt;8*$i--) for &quot;127.0.0.1&quot; =~ /(\d+)/g; print $u&#x27;</span><br></pre></td></tr></table></figure>
This one-liner converts the IP address 127.0.0.1 into unsigned integer (which happens to be 2130706433).</li>
</ol>
<p>It does it by first doing a global match of (\d+) on the IP address. Doing a for loop over a global match iterates over all the matches. These matches are the four parts of the IP address.</p>
<p>Next the matches are added together in the $u variable, with first being bit shifted 83 &#x3D; 24 places, the second being shifted 82 &#x3D; 16 places, the third 8 places and the last just getting added to $u.</p>
<p>But this one-liner doesn’t do any error checking on the format of an IP address. You may use a more sophisticated regular expression to add checking, such as &#x2F;^(\d+).(\d+).(\d+).(\d+)$&#x2F;g.</p>
<p>I had a discussion about this with a friend and we came up with several more one-liner:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;$ip=&quot;127.0.0.1&quot;; $ip =~ s/(\d+)\.?/sprintf(&quot;%02x&quot;, $1)/ge; print hex($ip)&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner utilizes the fact that 127.0.0.1 can be easily converted to hex as 7f000001 and then converted to decimal from hex by the hex Perl function.</p>
<p>Another way is to use unpack:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print unpack(&quot;N&quot;, 127.0.0.1)&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is probably as short as it can get. It uses the vstring literals (version strings) to express the IP address. A vstring forms a string literal composed of characters with the specified ordinal values. Next, the newly formed string literal is unpacked into a number from a string in Network byte order (Big-Endian order) and it gets printed.</p>
<p>If you have a string with an IP (and not a vstring), then you first have to convert the string with the function inet_aton to byte form:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MSocket -le &#x27;print unpack(&quot;N&quot;, inet_aton(&quot;127.0.0.1&quot;))&#x27;</span><br></pre></td></tr></table></figure>
<p>Here inet_aton converts the string “ 127.0.0.1 “ to the byte form (which is the same as pure vstring 127.0.0.1) and next it unpacks it as the same was as in previous one-liner.</p>
<p>If you want a reference of pack and unpack templates (such as “N” for Network order), get my Perl pack&#x2F;unpack cheat sheet!</p>
<ol start="48">
<li>Convert an unsigned integer to an IP address.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MSocket -le &#x27;print inet_ntoa(pack(&quot;N&quot;, 2130706433))&#x27;</span><br></pre></td></tr></table></figure>
Here the integer 2130706433 first gets packed into a number in Big-Endian and then it gets passed to inet_ntoa function that converts a number back to an IP address.</li>
</ol>
<p>Another way to do it is by bit shifting and printing one byte at a time:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;$ip = 2130706433; print join &quot;.&quot;, map &#123; (($ip&gt;&gt;8*($_))&amp;0xFF) &#125; reverse 0..3&#x27;</span><br></pre></td></tr></table></figure>
<p>And by the way, join “.” can be replaced by the special variable $, that acts as a value separator for print statement:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;$ip = 2130706433; $, = &quot;.&quot;; print map &#123; (($ip&gt;&gt;8*($_))&amp;0xFF) &#125; reverse 0..3&#x27;</span><br></pre></td></tr></table></figure>
<p>See my Perl special variable cheat sheet for the list of all variables.</p>
<p>Perl One-Liners Explained, Part IV: String and Array Creation</p>
<p>This is the fourth part of a nine-part article on Perl one-liners. In this part I will create various one-liners for string and array creation. See part one for introduction of the series.</p>
<p>Perl one-liners is my attempt to create “perl1line.txt” that is similar to “awk1line.txt” and “sed1line.txt” that have been so popular among Awk and Sed programmers.</p>
<p>The article on Perl one-liners will consist of nine parts:</p>
<pre><code>Part I: File spacing.
Part II: Line numbering.
Part III: Calculations.
Part IV: String creation and array creation (this part).
Part V: Text conversion and substitution.
Part VI: Selective printing and deleting of certain lines.
Part VII: Handy regular expressions.
Part VIII: Release of perl1line.txt.
Part IX: Release of Perl One-Liners e-book.
</code></pre>
<p>I decided that there will be two new parts in this series. The most powerful feature in Perl is its regular expressions, therefore I will write a part on “Handy Perl regular expressions.” I also decided to publish an e-book after I am done with the series, so that will be the last part of this series. Subscribe to my blog to know when that happens!</p>
<p>Awesome news: I have written an e-book based on this article series. Check it out:<br>Perl book</p>
<p>I also updated the previous part on calculations with 14 new one-liners on finding values of constants pi and e, doing date calculations, finding factorial, greatest common divisor, least common multiple, generating random numbers, generating permutations, finding power sets and doing some IP address conversions.</p>
<p>Here are today’s one-liners:<br>String Creation and Array Creation</p>
<ol start="49">
<li>Generate and print the alphabet.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print a..z&#x27;</span><br></pre></td></tr></table></figure>
This one-liner prints all the letters from a to z as abcdefghijklmnopqrstuvwxyz. The letters are generated by the range operator … The range operator, when used in the list context (which is forced here by print) on strings, uses the magical auto-increment algorithm that advances the string to the next character. So in this one-liner the auto-increment algorithm on the range a..z produces all the letters from a to z.</li>
</ol>
<p>I really golfed this one-liner. If you used strict it would not work because of barewords a and z. Semantically more correct version is this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print (&quot;a&quot;..&quot;z&quot;)&#x27;</span><br></pre></td></tr></table></figure>
<p>Remember that the range operator .. produced a list of values. If you want, you may print them comma separated by setting the $, special variable:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;$, = &quot;,&quot;; print (&quot;a&quot;..&quot;z&quot;)&#x27;</span><br></pre></td></tr></table></figure>
<p>There are many more special variables. Take a look at my special variable cheat sheet for a complete listing.</p>
<p>Syntactically more appealing is to use join to separate the list with a comma:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print join &quot;,&quot;, (&quot;a&quot;..&quot;z&quot;)&#x27;</span><br></pre></td></tr></table></figure>
<p>Here the list a..z gets joined by a comma before printing.</p>
<ol start="50">
<li>Generate and print all the strings from “a” to “zz”.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print (&quot;a&quot;..&quot;zz&quot;)&#x27;</span><br></pre></td></tr></table></figure>
Here the range operator .. is used again. This time it does not stop at “z” as in the previous one-liner, but advances z by one-character producing “aa”, then it keeps going, producing “ab”, “ac”, …, until it hits “az”. At this point it advances the string to “ba”, continues with “bb”, “bc”, …, until it reaches “zz”.</li>
</ol>
<p>Similarly, you may generate all strings from “aa” to “zz” by:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print &quot;aa&quot;..&quot;zz&quot;&#x27;</span><br></pre></td></tr></table></figure>
<p>Here it goes like “aa”, “ab”, …, “az”, “ba”, “bb”, …, “bz”, “ca”, … “zz”.</p>
<ol start="51">
<li>Create a hex lookup table.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@hex = (0..9, &quot;a&quot;..&quot;f&quot;)</span><br></pre></td></tr></table></figure>
Here the array code&gt;@hex&lt;&#x2F;code gets filled with values 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 and letters a, b, c, d, e, f.</li>
</ol>
<p>You may use this array to convert a number (in variable $num) from decimal to hex using base conversion formula:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;$num = 255; @hex = (0..9, &quot;a&quot;..&quot;f&quot;); while ($num) &#123; $s = $hex[($num%16)&amp;15].$s; $num = int $num/16 &#125; print $s&#x27;</span><br></pre></td></tr></table></figure>
<p>Surely, much easier way to convert a number to hex is just using the printf function (or sprintf function) with %x format specifier. (The example above just illustrates a use of a hex lookup table that we created by using the range operator.)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;$hex = sprintf(&quot;%x&quot;, 255); print $hex&#x27;</span><br></pre></td></tr></table></figure>
<p>(See my Perl printf and sprintf format cheat sheet for all the format specifiers.)</p>
<p>To convert the number back from hex to dec use the hex function:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;$num = &quot;ff&quot;; print hex $num&#x27;</span><br></pre></td></tr></table></figure>
<p>The hex function takes a hex string (beginning with or without “0x”) and converts it to decimal.</p>
<ol start="52">
<li>Generate a random 8 character password.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print map &#123; (&quot;a&quot;..&quot;z&quot;)[rand 26] &#125; 1..8&#x27;</span><br></pre></td></tr></table></figure>
Here the map function executes (“a”..”z”)[rand 26] code 8 times (because it iterates over the dummy range 1..8). In each iteration the code chooses a random letter from the alphabet. When map is done iterating, it returns the generated list of characters and print function prints it out by concatenating all the characters together.</li>
</ol>
<p>If you also want to include numbers in the password, add 0..9 to the list of characters to choose from and change 26 to 36 as there are 36 different characters to choose from:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print map &#123; (&quot;a&quot;..&quot;z&quot;, 0..9)[rand 36] &#125; 1..8&#x27;</span><br></pre></td></tr></table></figure>
<p>If you need a longer password, change 1..8 to 1..20 to generate a 20 character long password.</p>
<ol start="53">
<li>Create a string of specific length.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print &quot;a&quot;x50&#x27;</span><br></pre></td></tr></table></figure>
Operator x is the repetition operator. This one-liner creates a string of 50 letters “a” and prints it.</li>
</ol>
<p>If the repetition operator is used in list context, it creates a list (instead of scalar) with the given elements repeated:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;@list = (1,2)x20; print &quot;@list&quot;&#x27;</span><br></pre></td></tr></table></figure>
<p>This one liner creates a list of twenty repetitions of (1, 2) (it looks like (1, 2, 1, 2, 1, 2, …)).</p>
<ol start="54">
<li>Create an array from a string.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@months = split &#x27; &#x27;, &quot;Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec&quot;</span><br></pre></td></tr></table></figure>
Here the code&gt;@months&lt;&#x2F;code gets filled with values from the string containing month names. As each month name is separated by a space, the split function splits them and puts them in code&gt;@months&lt;&#x2F;code. This way $months[0] contains “Jan”, $months[1] contains “Feb”, …, and $months[11] contains “Dec”.</li>
</ol>
<p>Another way to do the same is by using qw&#x2F;&#x2F; operator:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@months = qw/Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/</span><br></pre></td></tr></table></figure>
<p>The qw&#x2F;&#x2F; operator takes a space separated string and creates an array with each word being an array element.</p>
<ol start="55">
<li><p>Create a string from an array.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@stuff = (&quot;hello&quot;, 0..9, &quot;world&quot;); $string = join &#x27;-&#x27;, @stuff</span><br></pre></td></tr></table></figure>
<p>Here the values in array code&gt;@stuff&lt;&#x2F;code get turned in a string $string that has them separated by a hyphen. Turning an array in a string was done by the join function that takes a separator and a list, and concatenates the items in the list in a single string, separated by the separator.</p>
</li>
<li><p>Find the numeric values for characters in the string.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print join &quot;, &quot;, map &#123; ord &#125; split //, &quot;hello world&quot;&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner takes the string “hello world”, splits it into a list of characters by split &#x2F;&#x2F;, “hello world”, then it maps the ord function onto each of the characters, which returns the numeric, native 8-bit encoding (like ASCII or EBCDIC) of the character. Finally all the numeric values get joined together by a comma and get printed out.</p>
</li>
</ol>
<p>Another way to do the same is use the unpack function and specify C as the unpacking template (C means unsigned character and means as many characters there are):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print join &quot;, &quot;, unpack(&quot;C*&quot;, &quot;hello world&quot;)&#x27;</span><br></pre></td></tr></table></figure>
<ol start="57">
<li>Convert a list of numeric ASCII values into a string.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;@ascii = (99, 111, 100, 105, 110, 103); print pack(&quot;C*&quot;, @ascii)&#x27;</span><br></pre></td></tr></table></figure>
Just as we unpacked a string into a list of values with the C* template in the one-liner above, we can pack them back into a string.</li>
</ol>
<p>Another way to do the same is use the chr function that takes the code point value and returns the corresponding character:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;@ascii = (99, 111, 100, 105, 110, 103); print map &#123; chr &#125; @ascii&#x27;</span><br></pre></td></tr></table></figure>
<p>Similar to one-liner #55 above, function chr gets mapped onto each value in the code&gt;@ascii&lt;&#x2F;code producing the characters.</p>
<ol start="58">
<li>Generate an array with odd numbers from 1 to 100.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;@odd = grep &#123;$_ % 2 == 1&#125; 1..100; print &quot;@odd&quot;&#x27;</span><br></pre></td></tr></table></figure>
This one-liner generates an array of odd numbers from 1 to 99 (as 1, 3, 5, 7, 9, 11, …, 99). It uses the grep function that evaluates the given code $_ % 2 &#x3D;&#x3D; 1 for each element in the given list 1..100 and returns only the elements that had the code evaluate to true. In this case the code tests if the reminder of the number is 1. If it is, the number is odd and it has to be put in the code&gt;@odd&lt;&#x2F;code array.</li>
</ol>
<p>Another way to write is by remembering that odd numbers have the low-bit set and testing this fact:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;@odd = grep &#123; $_ &amp; 1 &#125; 1..100; print &quot;@odd&quot;&#x27;</span><br></pre></td></tr></table></figure>
<p>Expression $_ &amp; 1 isolates the low-bit, and grep selects only the numbers with low-bit set (odd numbers).</p>
<p>See my explanation of bit-hacks for full explanation and other related bit-hacks.</p>
<ol start="59">
<li><p>Generate an array with even numbers from 1 to 100.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;@even = grep &#123;$_ % 2 == 0&#125; 1..100; print &quot;@even&quot;&#x27;</span><br></pre></td></tr></table></figure>
<p>This is almost the same as the previous one-liner, except the condition grep tests for is “is the number even (reminder dividing by 2 is zero)?”</p>
</li>
<li><p>Find the length of the string.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print length &quot;one-liners are great&quot;&#x27;</span><br></pre></td></tr></table></figure>
<p>Just for completeness, the length subroutine finds the length of the string.</p>
</li>
<li><p>Find the number of elements in an array.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;@array = (&quot;a&quot;..&quot;z&quot;); print scalar @array&#x27;</span><br></pre></td></tr></table></figure>
<p>Evaluating an array in a scalar context returns the number of elements in it.</p>
</li>
</ol>
<p>Another way to do the same is by adding one to the last index of the array:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;@array = (&quot;a&quot;..&quot;z&quot;); print $#array + 1&#x27;</span><br></pre></td></tr></table></figure>
<p>Here $#array returns the last index in array code&gt;@array&lt;&#x2F;code. Since it’s a number one less than the number of elements, we add 1 to the result to find the total number of elements in the array.</p>
<p>Perl One-Liners Explained, Part V: Text conversion and substitution</p>
<p>This is the fifth part of a nine-part article on Perl one-liners. In this part I will create various one-liners for text conversion and substitution. See part one for introduction of the series.</p>
<p>Perl one-liners is my attempt to create “perl1line.txt” that is similar to “awk1line.txt” and “sed1line.txt” that have been so popular among Awk and Sed programmers.</p>
<p>The article on Perl one-liners will consist of nine parts:</p>
<pre><code>Part I: File spacing.
Part II: Line numbering.
Part III: Calculations.
Part IV: String creation and array creation.
Part V: Text conversion and substitution (this part).
Part VI: Selective printing and deleting of certain lines.
Part VII: Handy regular expressions.
Part VIII: Release of perl1line.txt.
Part IX: Release of Perl One-Liners e-book.
</code></pre>
<p>After I’m done with explaining the one-liners, I’ll release an ebook. Subscribe to my blog to know when that happens!</p>
<p>Awesome news: I have written an e-book based on this article series. Check it out:<br>Perl book</p>
<p>Alright then, here are today’s one-liners:<br>Text conversion and substitution</p>
<ol start="62">
<li>ROT13 a string.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;y/A-Za-z/N-ZA-Mn-za-m/&#x27;</span><br></pre></td></tr></table></figure>
This one-liner uses the y operator (also known as tr operator) to do ROT13. Operators y and tr do string transliteration. Given y&#x2F;SEARCH&#x2F;REPLACE&#x2F;, the operator transliterates all occurrences of the characters found in SEARCH list with the corresponding (position-wise) characters in REPLACE list.</li>
</ol>
<p>In this one-liner A-Za-z creates the following list of characters:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure>
<p>And N-ZA-Mn-za-m creates this list:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm</span><br></pre></td></tr></table></figure>
<p>If you look closely you’ll notice that the second list is actually the first list offset by 13 characters. Now the y operator translates each character in the first list to a character in the second list, thus performing the ROT13 operation.</p>
<p>If you want to ROT13 the whole file then do this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -lpe &#x27;y/A-Za-z/N-ZA-Mn-za-m/&#x27; file</span><br></pre></td></tr></table></figure>
<p>The -p argument puts each of file’s line in the $ variable, the y does ROT13, and -p prints the $ out. The -l appends a newline to the output.</p>
<p>Note: remember that applying ROT13 twice produces the same string, i.e., ROT13(ROT13(string)) &#x3D;&#x3D; string.</p>
<ol start="63">
<li>Base64 encode a string.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MMIME::Base64 -e &#x27;print encode_base64(&quot;string&quot;)&#x27;</span><br></pre></td></tr></table></figure>
This one-liner uses the MIME::Base64 module that is in the core (no need to install it, it comes with Perl). This module exports the encode_base64 function that takes a string and returns base64 encoded version of it.</li>
</ol>
<p>To base64 encode the whole file do the following:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MMIME::Base64 -0777 -ne &#x27;print encode_base64($_)&#x27; file</span><br></pre></td></tr></table></figure>
<p>Here the -0777 argument together with -n causes Perl to slurp the whole file into the $_ variable. Then the file gets base64 encoded and printed out, just like the string example above.</p>
<p>If we didn’t slurp the file and encoded it line-by-line we’d get a mess.</p>
<ol start="64">
<li>Base64 decode a string.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MMIME::Base64 -le &#x27;print decode_base64(&quot;base64string&quot;)&#x27;</span><br></pre></td></tr></table></figure>

<p>The MIME::Base64 module also exports decode_base64 function that takes a base64-encoded string and decodes it.</p>
<p>The whole file can be similarly decoded by:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MMIME::Base64 -ne &#x27;print decode_base64($_)&#x27; file</span><br></pre></td></tr></table></figure>
<p>There is no need to slurp the whole file into $_ because each line of a base64 encoded file is exactly 76 characters and decodes nicely.</p>
<ol start="65">
<li><p>URL-escape a string.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MURI::Escape -le &#x27;print uri_escape($string)&#x27;</span><br></pre></td></tr></table></figure>
<p>You’ll need to install the URI::Escape module as it doesn’t come with Perl. The module exports two functions - uri_escape and uri_unescape. The first one does URL-escaping (sometimes also referred to as URL encoding), and the other does URL-unescaping (URL decoding).</p>
</li>
<li><p>URL-unescape a string.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MURI::Escape -le &#x27;print uri_unescape($string)&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the uri_unescape function from URI::Escape module to do URL-unescaping.</p>
</li>
<li><p>HTML-encode a string.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MHTML::Entities -le &#x27;print encode_entities($string)&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the encode_entities function from HTML::Entities module. This function encodes HTML entities. For example, &lt; and &gt; get turned into &lt; and &gt;.</p>
</li>
<li><p>HTML-decode a string.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MHTML::Entities -le &#x27;print decode_entities($string)&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the decode_entities function from HTML::Entities module.</p>
</li>
<li><p>Convert all text to uppercase.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -nle &#x27;print uc&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the uc function, which by default operates on the $_ variable and returns an uppercase version of it.</p>
</li>
</ol>
<p>Another way to do the same is to use -p command line option that enables automatic printing of $_ variable and modify it in-place:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ple &#x27;$_=uc&#x27;</span><br></pre></td></tr></table></figure>
<p>The same can also be also achieved by applying the \U escape sequence to string interpolation:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -nle &#x27;print &quot;\U$_&quot;&#x27;</span><br></pre></td></tr></table></figure>
<p>It causes anything after it (or until the first occurrence of \E) to be upper-cased.</p>
<ol start="70">
<li>Convert all text to lowercase.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -nle &#x27;print lc&#x27;</span><br></pre></td></tr></table></figure>
This one-liner is very similar to the previous. Here the lc function is used that converts the contents of $_ to lowercase.</li>
</ol>
<p>Or, using escape sequence \L and string interpolation:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -nle &#x27;print &quot;\L$_&quot;&#x27;</span><br></pre></td></tr></table></figure>
<p>Here \L causes everything after it (until the first occurrence of \E) to be lower-cased.</p>
<ol start="71">
<li>Uppercase only the first word of each line.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -nle &#x27;print ucfirst lc&#x27;</span><br></pre></td></tr></table></figure>
The one-liner first applies the lc function to the input that makes it lower case and then uses the ucfirst function that upper-cases only the first character.</li>
</ol>
<p>It can also be done via escape codes and string interpolation:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -nle &#x27;print &quot;\u\L$_&quot;&#x27;</span><br></pre></td></tr></table></figure>
<p>First the \L lower-cases the whole line, then \u upper-cases the first character.</p>
<ol start="72">
<li><p>Invert the letter case.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ple &#x27;y/A-Za-z/a-zA-Z/&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner does transliterates capital letters A-Z to lowercase letters a-z, and lowercase letters to uppercase letters, thus switching the case.</p>
</li>
<li><p>Camel case each line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ple &#x27;s/(\w+)/\u$1/g&#x27;</span><br></pre></td></tr></table></figure>
<p>This is a lousy Camel Casing one-liner. It takes each word and upper-cases the first letter of it. It fails on possessive forms like “friend’s car”. It turns them into “Friend’S Car”.</p>
</li>
</ol>
<p>An improvement is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s/(?&amp;lt;![&#x27;])(\w+)/\u\1/g</span><br></pre></td></tr></table></figure>
<p>Which checks if the character before the word is not single quote ‘. But I am sure it still fails on some more exotic examples.</p>
<ol start="74">
<li>Strip leading whitespace (spaces, tabs) from the beginning of each line.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ple &#x27;s/^[ \t]+//&#x27;</span><br></pre></td></tr></table></figure>
This one-liner deletes all whitespace from the beginning of each line. It uses the substitution operator s. Given s&#x2F;REGEX&#x2F;REPLACE&#x2F; it replaces the matched REGEX by the REPLACE string. In this case the REGEX is ^[ \t]+, which means “match one or more space or tab at the beginning of the string” and REPLACE is nothing, meaning, replace the matched part with empty string.</li>
</ol>
<p>The regex class [ \t] can actually be replaced by \s+ that matches any whitespace (including tabs and spaces):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ple &#x27;s/^\s+//&#x27;</span><br></pre></td></tr></table></figure>
<ol start="75">
<li>Strip trailing whitespace (space, tabs) from the end of each line.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ple &#x27;s/[ \t]+$//&#x27;</span><br></pre></td></tr></table></figure>
This one-liner deletes all whitespace from the end of each line.</li>
</ol>
<p>Here the REGEX of the s operator says “match one or more space or tab at the end of the string.” The REPLACE part is empty again, which means to erase the matched whitespace.</p>
<ol start="76">
<li><p>Strip whitespace from the beginning and end of each line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ple &#x27;s/^[ \t]+|[ \t]+$//g&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner combines the previous two. Notice that it specifies the global &#x2F;g flag to the s operator. It’s necessary because we want it to delete whitespace at the beginning AND end of the string. If we didn’t specify it, it would only delete whitespace at the beginning (assuming it exists) and not at the end.</p>
</li>
<li><p>Convert UNIX newlines to DOS&#x2F;Windows newlines.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;s|\n|\r\n|&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner substitutes the Unix newline \n LF with Windows newline \r\n CRLF on each line. Remember that the s operator can use anything for delimiters. In this one-liner it uses vertical pipes to delimit REGEX from REPLACE to improve readibility.</p>
</li>
<li><p>Convert DOS&#x2F;Windows newlines to UNIX newlines.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;s|\r\n|\n|&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner does the opposite of the previous one. It takes Windows newlines CRLF and converts them to Unix newlines LF.</p>
</li>
<li><p>Convert UNIX newlines to Mac newlines.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;s|\n|\r|&#x27;</span><br></pre></td></tr></table></figure>
<p>Apple Macintoshes used to use \r CR as newlines. This one-liner converts UNIX’s \n to Mac’s \r.</p>
</li>
<li><p>Substitute (find and replace) “foo” with “bar” on each line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;s/foo/bar/&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the s&#x2F;REGEX&#x2F;REPLACE&#x2F; command to substitute “foo” with “bar” on each line.</p>
</li>
</ol>
<p>To replace all “foos” with “bars”, add the global &#x2F;g flag:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;s/foo/bar/g&#x27;</span><br></pre></td></tr></table></figure>
<ol start="81">
<li>Substitute (find and replace) “foo” with “bar” on lines that match “baz”.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;/baz/ &amp;&amp; s/foo/bar/&#x27;</span><br></pre></td></tr></table></figure>
This one-liner is equivalent to:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (defined($line = &amp;lt;&amp;gt;)) &#123;</span><br><span class="line">  if ($line =~ /baz/) &#123;</span><br><span class="line">    $line =~ s/foo/bar/</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
It puts each line in variable $line, then checks if line matches “baz”, and if it does, it replaces “foo” with “bar” in it.</li>
</ol>
<p>Perl One-Liners Explained, Part VI: Selective printing and deleting of lines</p>
<p>This is the sixth part of a nine-part article on Perl one-liners. In this part I will create various one-liners for selective printing and deleting of certain lines. See part one for introduction of the series.</p>
<p>Perl one-liners is my attempt to create “perl1line.txt” that is similar to “awk1line.txt” and “sed1line.txt” that have been so popular among Awk and Sed programmers and Linux sysadmins.</p>
<p>The article on Perl one-liners will consist of nine parts:</p>
<pre><code>Part I: File spacing.
Part II: Line numbering.
Part III: Calculations.
Part IV: String creation and array creation.
Part V: Text conversion and substitution.
Part VI: Selective printing and deleting of certain lines (this part).
Part VII: Handy regular expressions.
Part VIII: Release of perl1line.txt.
Part IX: Release of Perl One-Liners e-book.
</code></pre>
<p>The selective printing and selective deleting of certain lines is actually the same process. If you want to delete certain lines, you just print the lines you’re interested in. Or the other way around! For example, to delete all lines with even line numbers, print the odd lines, and to delete odd lines print the even lines.</p>
<p>After I am done with the 8 parts of the article, I will release the whole article series as a pdf e-book! Please subscribe to my blog to be the first to get it!</p>
<p>Awesome news: I have written an e-book based on this article series. Check it out:<br>Perl book</p>
<p>Here are today’s one-liners:</p>
<ol start="82">
<li><p>Print the first line of a file (emulate head -1).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print; exit&#x27;</span><br></pre></td></tr></table></figure>
<p>This is the simplest one-liner so far. Here Perl reads in the first line into $ variable thanks to -n option, then it calls print statement that prints the contents of the $ variable. And then it just exists. That’s it. The first line got printed and that’s all we wanted.</p>
</li>
<li><p>Print the first 10 lines of a file (emulate head -10).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if $. &lt;= 10&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the $. special variable. This variable stands for “current line number.” Each time Perl reads in the next line, it increments $. by one. Therefore it’s very simple to understand what this one-liner does, it prints the line if the line number is equal to or less than 10.</p>
</li>
</ol>
<p>This one liner can also be written the other way around without use of if statement,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;$. &lt;= 10 &amp;&amp; print&#x27;</span><br></pre></td></tr></table></figure>
<p>Here the print statement gets called only if $. &lt;&#x3D; 10 boolean expression is true, and it’s true only if current line number is less than or equal to 10.</p>
<ol start="84">
<li>Print the last line of a file (emulate tail -1).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;$last = $_; END &#123; print $last &#125;&#x27;</span><br></pre></td></tr></table></figure>
Printing the last line of the file is a bit tricker, because you always have to maintain the previous line in memory. In this one-liner we always save the current line in $_ to $last variable. When Perl program ends, it always executes code in the END block. Now just before exiting it read in the last line, so when it quits, we print $last that prints the last line.</li>
</ol>
<p>Another way to do the same is,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if eof&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the eof function that returns 1 if the next read will return end of file. Since the next read after the last line in the file will really return eof, this one-liner does what it’s supposed to do.</p>
<ol start="85">
<li>Print the last 10 lines of a file (emulate tail -10).<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;push @a, $_; @a = @a[@a-10..$#a]; END &#123; print @a &#125;&#x27;</span><br></pre></td></tr></table></figure>
Now this is tricky. Here we push each line to the code&gt;@a&lt;&#x2F;code array, and then we replace with a slice of itself. We do @a &#x3D; @a[@a-10..$#a], which means, replace code&gt;@a&lt;&#x2F;code with last 10 elements of a. code&gt;@a-10&lt;&#x2F;code is evaluated in scalar context here and it returns number of elements in the array minus 10. #$a is the last index in the code&gt;@a&lt;&#x2F;code array. And code&gt;@a[@a-10..$#a]&lt;&#x2F;code takes the last 10 elements of the array, so code&gt;@a&lt;&#x2F;code always contains just 10 last elements.</li>
</ol>
<p>Here is an example. Suppose code&gt;@a&lt;&#x2F;code contains (“line1”, “line2”, “line3”, “line4”). And let’s say we want to print last 4 lines of the file. Now when we read the 5th line, the array becomes (“line1”, “line2”, “line3”, “line4”, “line5”). At this moment code&gt;@a-4&lt;&#x2F;code is 1, because code&gt;@a&lt;&#x2F;code in scalar context is 5. The $#a however is 4 because that’s the last index in the array. Now taking the slice, code&gt;@a[@a-4..$#a]&lt;&#x2F;code is code&gt;@a[1..4]&lt;&#x2F;code, which drops the front element from the array and the code&gt;@a&lt;&#x2F;code array becomes (“line2”, “line3”, “line4”, “line5”).</p>
<ol start="86">
<li><p>Print only lines that match a regular expression.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;/regex/ &amp;&amp; print&#x27;</span><br></pre></td></tr></table></figure>
<p>Here &#x2F;regex&#x2F; is short for $ &#x3D;~ &#x2F;regex&#x2F;. Since the -n operator puts every line in $ variable the &#x2F;regex&#x2F; returns true on all lines that matched the regex. If that happened, print prints the line.</p>
</li>
<li><p>Print only lines that do not match a regular expression.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;!/regex/ &amp;&amp; print&#x27;</span><br></pre></td></tr></table></figure>
<p>This is the same as the previous one-liner, except the regular expression match has been negated. So all the lines that don’t match the regex get printed.</p>
</li>
<li><p>Print the line before a line that matches a regular expression.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;/regex/ &amp;&amp; $last &amp;&amp; print $last; $last = $_&#x27;</span><br></pre></td></tr></table></figure>
<p>In this one-liner every line gets saved to $last variable. Now when the next line matches &#x2F;regex&#x2F; and there has been a previous line $last, then it print $last prints the last line, and then it assigns the current line to the last line variable via $last &#x3D; $_.</p>
</li>
<li><p>Print the line after a line that matches a regular expression.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;if ($p) &#123; print; $p = 0 &#125; $p++ if /regex/&#x27;</span><br></pre></td></tr></table></figure>
<p>Here we set the variable $p if the line matches a regex. It indicates that the next line should be printed. Now when the next line is read in and $p is set, then that line gets printed and $p gets set to 0 again to reset the state.</p>
</li>
<li><p>Print lines that match regex AAA and regex BBB in any order.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;/AAA/ &amp;&amp; /BBB/ &amp;&amp; print&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is basically the same as one-liner #86 above. Here we test if a line matches two regular expressions instead of line. If a line matches both regexes, then it gets printed.</p>
</li>
<li><p>Print lines that don’t match match regexes AAA and BBB.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;!/AAA/ &amp;&amp; !/BBB/ &amp;&amp; print&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is almost the same as one-liner #87. Here we test if a line doesn’t match two regular expressions in any order. If it doesn’t match &#x2F;AAA&#x2F; and it doesn’t match &#x2F;BBB&#x2F;, then we print it.</p>
</li>
<li><p>Print lines that match regex AAA followed by regex BBB followed by CCC.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;/AAA.*BBB.*CCC/ &amp;&amp; print&#x27;</span><br></pre></td></tr></table></figure>
<p>Here we simply chain regexes AAA, BBB and CCC with .*, which stands for match anything or nothing at all. If AAA is followed by BBB and that is followed by CCC then we print the line. It also matches AAABBBCCC with nothing in between the regexes.</p>
</li>
<li><p>Print lines that are 80 chars or longer.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if length &gt;= 80&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner prints all lines that are 80 chars or longer. In Perl you can sometimes omit the brackets () for function calls. In this one we omitted brackets for length function call. In fact, length, length() and length($_) are the same.</p>
</li>
<li><p>Print lines that are less than 80 chars in length.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if length &amp;lt; 80&#x27;</span><br></pre></td></tr></table></figure>
<p>This is the opposite of previous one-liner. It checks if the length of a line is less than 80 characters.</p>
</li>
<li><p>Print only line 13.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;$. == 13 &amp;&amp; print &amp;&amp; exit&#x27;</span><br></pre></td></tr></table></figure>
<p>As I explained in one-liner #83, the $. special variable stands for “current line number”. So if $. has value 13, then we print the line and exit.</p>
</li>
<li><p>Print all lines except line 27.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;$. != 27 &amp;&amp; print&#x27;</span><br></pre></td></tr></table></figure>
<p>Just like in previous one-liner, we check if the current line is line 27, if it’s not then we print it, otherwise we skip it.</p>
</li>
</ol>
<p>Another way to write the same is to reverse print and $. !&#x3D; 27 and use if statement,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if $. != 27&#x27;</span><br></pre></td></tr></table></figure>
<ol start="97">
<li><p>Print only lines 13, 19 and 67.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if $. == 13 || $. == 19 || $. == 67&#x27;</span><br></pre></td></tr></table></figure>
<p>If you have Perl 5.10 or later then you can use the ~~ smart match operator,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if int($.) ~~ (13, 19, 67)&#x27; </span><br></pre></td></tr></table></figure>
<p>The smart matching operator ~~ appeared only in Perl 5.10. You can do all kinds of smart matching with it, for example, check if two arrays are the same, if an array contains an element, and many other use cases (see perldoc perlsyn). In this particular one-liner we use int($.) ~~ (13, 19, 67) that determines if numeric value $. is in the list (13, 19, 69). It’s basically short for, grep { $ &#x3D;&#x3D; int($.) } (13, 19, 67). If the check succeeds the line gets printed.</p>
</li>
<li><p>Print all lines between two regexes (including lines that match regex).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if /regex1/../regex2/&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses the flip-flop operator, which becomes true when a line matches regex1 and becomes false after another line matches regex2. Therefore this one-liner prints all lines between (and including) lines that match regex1 and regex2.</p>
</li>
<li><p>Print all lines from line 17 to line 30.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if $. &gt;= 17 &amp;&amp; $. &lt;= 30&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is very simple to understand. The $. variable stands for the current line number, so it checks if the current line number is greater than or equal to 17 and less than or equal to 30.</p>
</li>
</ol>
<p>I just thought of another way to write it,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if int($.) ~~ (17..30)&#x27;</span><br></pre></td></tr></table></figure>
<p>This is one-liner uses the Perl 5.10 (and later) smart matching operator ~~. It basically says, is the current line number in the list (17, 18, 19, …, 30). If it is, the smart match succeeds and the line gets printed.</p>
<p>You can write the same idea in older Perls as following,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if grep &#123; $_ == $. &#125; 17..30&#x27;</span><br></pre></td></tr></table></figure>
<p>What happens here is grep checks if the current line number is in the list (17, 18, …, 30). If it is, it returns a list of just one element, and a list of one element is true, and the line gets printed. Otherwise grep returns the empty list, which is false, and nothing gets printed.</p>
<ol start="100">
<li><p>Print the longest line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;$l = $_ if length($_) &gt; length($l); END &#123; print $l &#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner keeps the longest line seen so far in the $l variable. In case the current line $_ exceeds the length of currently longest line, it gets replaced. Just before exiting, the END block is executed and it prints the longest line $l.</p>
</li>
<li><p>Print the shortest line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;$s = $_ if $. == 1; $s = $_ if length($_) &lt; length($s); END &#123; print $s &#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is the opposite of the previous one. But as we’re finding the minimum and $s is not defined for the first line, we have to set it to first line explicitly. Otherwise it’s the same just with the length check reversed length($_) &lt; length($s).</p>
</li>
<li><p>Print all lines that contain a number.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if /\d/&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner uses a regular expression \d that stands for “match a number” and checks if a line contains one. If it does, the check succeeds, and the line gets printed.</p>
</li>
<li><p>Find all lines that contain only a number.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if /^\d+$/&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is very similar to the previous one, but instead of matching a number anywhere on the line, it anchors the match to the beginning of the line, and to the end of the line. The regular expression ^\d+$ means “match one or more numbers that start at the beginning of line and end at the end of the line”.</p>
</li>
<li><p>Print all lines that contain only characters.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if /^[[:alpha:]]+$/</span><br></pre></td></tr></table></figure>
<p>This one-liner checks if the line contains only characters and if it does, it prints it. Here the [[:alpha:]] stands for “match all characters”. You could also write the same as [a-zA-Z] (if you live in ASCII world).</p>
</li>
<li><p>Print every second line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if $. % 2&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner prints first, third, 5th, 7th, etc, line. It does so because $. % 2 is true when the current line number is odd, and it’s false when the current line number is even.</p>
</li>
<li><p>Print every second line, starting the second line.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if $. % 2 == 0&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner is very similar to the previous one but except printing 1st, 3rd, 5th, etc, lines, it prints 2nd, 4th, 6th, etc, lines. It prints them because $. % 2 &#x3D;&#x3D; 0 is true when the current line number is 2, 4, 6, ….</p>
</li>
<li><p>Print all lines that repeat.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if ++$a&#123;$_&#125; == 2&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner keeps track of the lines it has seen so far and it also keeps the count of how many times it has seen the line before. If it sees the line the 2nd time, it prints it out because ++$a{$_} &#x3D;&#x3D; 2 is true. If it sees the line more than 2 times, it just does nothing because the count for this line has gone beyond 2 and the result of the print check is false.</p>
</li>
<li><p>Print all unique lines.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print unless $a&#123;$_&#125;++&#x27;</span><br></pre></td></tr></table></figure>
<p>Here the lines get printed only if the hash value $a{$_} for the line is 0. Every time Perl reads in a line, it increments the value for the line and that makes sure that only never before seen lines get printed.</p>
</li>
</ol>
<p>Perl One-Liners Explained, Part VII: Handy Regular Expressions</p>
<p>This is the seventh part of a nine-part article on Perl one-liners. Perl is not Perl without regular expressions, therefore in this part I will come up with and explain various Perl regular expressions. Please see part one for the introduction of the series.</p>
<p>Perl one-liners is my attempt to create “perl1line.txt” that is similar to “awk1line.txt” and “sed1line.txt” that have been so popular among Awk and Sed programmers, and Unix sysadmins. I will release the perl1line.txt in the next part of the series.</p>
<p>The article on Perl one-liners consists of nine parts:</p>
<pre><code>Part I: File spacing.
Part II: Line numbering.
Part III: Calculations.
Part IV: String creation and array creation.
Part V: Text conversion and substitution.
Part VI: Selective printing and deleting of certain lines.
Part VII: Handy regular expressions (this part).
Part VIII: Release of perl1line.txt.
Part IX: Release of Perl One-Liners e-book.
</code></pre>
<p>After I am done with the next part of the article, I will release the whole article series as a pdf e-book! Please subscribe to my blog to be the first to get it. You can also follow me on Twitter.</p>
<p>Awesome news: I have written an e-book based on this article series. Check it out:<br>Perl book</p>
<p>And here are today’s one-liners:</p>
<ol start="109">
<li>Match something that looks like an IP address.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;$/</span><br></pre></td></tr></table></figure>
This regex doesn’t guarantee that the thing that got matched is in fact a valid IP. All it does is match something that looks like an IP. It matches a number followed by a dot four times. For example, it matches a valid IP 81.198.240.140 and it also matches an invalid IP such as 923.844.1.999.</li>
</ol>
<p>Here is how it works. The ^ at the beginning of regex is an anchor that matches the beginning of string. Next \d{1,3} matches one, two or three consecutive digits. The . matches a dot. The $ at the end is an anchor that matches the end of the string. It’s important to use both ^ and $ anchors, otherwise strings like foo213.3.1.2bar would also match.</p>
<p>This regex can be simplified by grouping the first three repeated \d{1,3}. expressions:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^(\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;$/</span><br></pre></td></tr></table></figure>
<ol start="110">
<li><p>Test if a number is in range 0-255.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/</span><br></pre></td></tr></table></figure>
<p>Here is how it works. A number can either be one digit, two digit or three digit. If it’s a one digit number then we allow it to be anything [0-9]. If it’s two digit, we also allow it to be any combination of [0-9][0-9]. However if it’s a three digit number, it has to be either one hundred-something or two-hundred something. If it’e one hundred-something, then 1[0-9][0-9] matches it. If it’s two hundred-something then it’s either something up to 249, which is matched by 2[0-4][0-9] or it’s 250-255, which is matched by 25[0-5].</p>
</li>
<li><p>Match an IP address.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my $ip_part = qr|([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|;</span><br><span class="line">if ($ip =~ /^($ip_part\.)&#123;3&#125;$ip_part$/) &#123;</span><br><span class="line"> say &quot;valid ip&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This regexp combines the previous two. It uses the my $ip_part &#x3D; qr&#x2F;…&#x2F; operator compiles the regular expression and puts it in $ip_part variable. Then the $ip_part is used to match the four parts of the IP address.</p>
</li>
<li><p>Check if the string looks like an email address.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/.+@.+\..+/</span><br></pre></td></tr></table></figure>
<p>This regex makes sure that the string looks like an email address. Notice that I say “looks like”. It doesn’t guarantee it is an email address. Here is how it works - first it matches something up to the code&gt;@&lt;&#x2F;code symbol, then it matches as much as possible until it finds a dot, and then it matches some more. If this succeeds, then it it’s something that at least looks like email address with the code&gt;@&lt;&#x2F;code symbol and a dot in it.</p>
</li>
</ol>
<p>For example, code&gt;<a href="mailto:&#99;&#97;&#x74;&#115;&#x40;&#99;&#97;&#x74;&#x6f;&#110;&#x6d;&#97;&#x74;&#x2e;&#110;&#101;&#x74;">&#99;&#97;&#x74;&#115;&#x40;&#99;&#97;&#x74;&#x6f;&#110;&#x6d;&#97;&#x74;&#x2e;&#110;&#101;&#x74;</a>&lt;&#x2F;code matches but code&gt;cats@catonmat&lt;&#x2F;code doesn’t because the regex can’t match the dot . that is necessary.</p>
<p>Much more robust way to check if a string is a valid email would be to use Email::Valid module:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use Email::Valid;</span><br><span class="line">print (Email::Valid-&gt;address(&#x27;john@example.com&#x27;) ? &#x27;valid email&#x27; : &#x27;invalid email&#x27;);</span><br></pre></td></tr></table></figure>
<ol start="113">
<li>Check if the string is a decimal number.</li>
</ol>
<p>Checking if the string is a number is really difficult. I based my regex and explanation on the one in Perl Cookbook.</p>
<p>Perl offers \d that matches digits 0-9. So we can start with:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^\d+$/</span><br></pre></td></tr></table></figure>
<p>This regex matches one or more digits \d starting at the beginning of the string ^ and ending at the end of the string $. However this doesn’t match numbers such as +3 and -3. Let’s modify the regex to match them:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^[+-]?\d+$/</span><br></pre></td></tr></table></figure>
<p>Here the [+-]? means match an optional plus or a minus before the digits. This now matches +3 and -3 but it doesn’t match -0.3. Let’s add that:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^[+-]?\d+\.?\d*$/</span><br></pre></td></tr></table></figure>
<p>Now we have expanded the previous regex by adding .?\d*, which matches an optional dot followed by zero or more numbers. Now we’re in business and this regex also matches numbers like -0.3 and 0.3.</p>
<p>Much better way to match a decimal number is to use Regexp::Common module that offers various useful regexes. For example, to match an integer you can use $RE{num}{int} from Regexp::Common.</p>
<p>How about positive hexadecimal numbers? Here is how:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^0x[0-9a-f]+$/i</span><br></pre></td></tr></table></figure>
<p>This matches the hex prefix 0x followed by hex number itself. The &#x2F;i flag at the end makes sure that the match is case insensitive. For example, 0x5af matches, 0X5Fa matches but 97 doesn’t, cause it’s just a decimal number.</p>
<p>It’s better to use $RE{num}{hex} because it supports negative numbers, decimal places and number grouping.</p>
<p>Now how about octal? Here is how:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^0[0-7]+$/</span><br></pre></td></tr></table></figure>
<p>Octal numbers are prefixed by 0, which is followed by octal digits 0-7. For example, 013 matches but 09 doesn’t, cause it’s not a valid octal number.</p>
<p>It’s better to use $RE{num}{oct} because of the same reasons as above.</p>
<p>Finally binary:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^[01]+$/</span><br></pre></td></tr></table></figure>
<p>Binary base consists of just 0s and 1s. For example, 010101 matches but 210101 doesn’t, because 2 is not a valid binary digit.</p>
<p>It’s better to use $RE{num}{bin} because of the same reasons as above.</p>
<ol start="114">
<li>Check if a word appears twice in the string.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/(word).*\1/</span><br></pre></td></tr></table></figure>
This regex matches word followed by something or nothing at all, followed by the same word. Here the (word) captures the word in group 1 and \1 refers to contents of group 1, therefore it’s almost the same as writing &#x2F;(word).*word&#x2F;</li>
</ol>
<p>For example, silly things are silly matches &#x2F;(silly).*\1&#x2F;, but silly things are boring doesn’t, because silly is not repeated in the string.</p>
<ol start="115">
<li>Increase all numbers by one in the string.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$str =~ s/(\d+)/$1+1/ge</span><br></pre></td></tr></table></figure>
Here we use the substitution operator s&#x2F;&#x2F;&#x2F;. It matches all integers (\d+), puts them in capture group 1, then it replaces them with their value incremented by one $1+1. The g flag makes sure it finds all the numbers in the string, and the e flag evaluates $1+1 as a Perl expression.</li>
</ol>
<p>For example, this 1234 is awesome 444 gets turned into this 1235 is awesome 445.</p>
<ol start="116">
<li>Extract HTTP User-Agent string from the HTTP headers.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^User-Agent: (.+)$/</span><br></pre></td></tr></table></figure>
HTTP headers are formatted as Key: Value pairs. It’s very easy to parse such strings, you just instruct the regex engine to save the Value part in $1 group variable.</li>
</ol>
<p>For example, if the HTTP headers contain,</p>
<p>Host: localhost:8000<br>Connection: keep-alive<br>User-Agent: Mozilla&#x2F;5.0 (Macintosh; U; Intel Mac OS X 10_0_0; en-US)<br>Accept: application&#x2F;xml,application&#x2F;xhtml+xml,text&#x2F;html;q&#x3D;0.9,text&#x2F;plain;q&#x3D;0.8,image&#x2F;png,<em>&#x2F;</em>;q&#x3D;0.5<br>Accept-Encoding: gzip,deflate,sdch<br>Accept-Language: en-US,en;q&#x3D;0.8<br>Accept-Charset: ISO-8859-1,utf-8;q&#x3D;0.7,*;q&#x3D;0.3</p>
<p>Then the regular expression will extract the Mozilla&#x2F;5.0 (Macintosh; U; Intel Mac OS X 10_0_0; en-US) string.</p>
<ol start="117">
<li>Match printable ASCII characters.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[ -~]/</span><br></pre></td></tr></table></figure>
This is really tricky and smart. To understand it, take a look at man ascii. You’ll see that space starts at value 0x20 and the ~ character is 0x7e. All the characters between a space and ~ are printable. This regular expression matches exactly that. The [ -~] defines a range of characters from space till ~. This is my favorite regexp of all time.</li>
</ol>
<p>You can invert the match by placing ^ as the first character in the group:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[^ -~]/</span><br></pre></td></tr></table></figure>
<p>This matches the opposite of [ -~].</p>
<ol start="118">
<li>Match text between two HTML tags.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m|&lt;strong&gt;([^&lt;]*)&lt;/strong&gt;|</span><br></pre></td></tr></table></figure>
This regex matches everything between <strong>…</strong> HTML tags. The trick here is the ([^&lt;]*), which matches as much as possible until it finds a &lt; character, which starts the next tag.</li>
</ol>
<p>Alternatively you can write:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m|&lt;strong&gt;(.*?)&lt;/strong&gt;|</span><br></pre></td></tr></table></figure>
<p>But this is a little different. For example, if the HTML is <strong><em>hello</em></strong> then the first regex doesn’t match anything because the &lt; follows <strong> and ([^&lt;]) matches as little as possible. The second regex matches <em>hello</em> because the (.?)</strong> matches as little as possible until it finds </strong>, which happens to be <em>hello</em>.</p>
<p>However don’t use regular expressions for matching and parsing HTML. Use modules like HTML::TreeBuilder to accomplish the task cleaner.</p>
<ol start="119">
<li><p>Replace all <b> tags with <strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$html =~ s|&lt;(/)?b&gt;|&lt;$1strong&gt;|g</span><br></pre></td></tr></table></figure>
<p>Here I assume that the HTML is in variable $html. Next the &lt;(&#x2F;)?b&gt; matches the opening and closing <b> tags, captures the optional closing tag slash in group $1 and then replaces the matched tag with either <strong> or </strong>, depending on if it was an opening or closing tag.</p>
</li>
<li><p>Extract all matches from a regular expression.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my @matches = $text =~ /regex/g;</span><br></pre></td></tr></table></figure>
<p>Here the regular expression gets evaluated in the list context that makes it return all the matches. The matches get put in the code&gt;@matches&lt;&#x2F;code variable.</p>
</li>
</ol>
<p>For example, the following regex extracts all numbers from a string:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my $t = &quot;10 hello 25 moo 31 foo&quot;;</span><br><span class="line">my @nums = $text =~ /\d+/g;</span><br></pre></td></tr></table></figure>
<p>code&gt;@nums&lt;&#x2F;code now contains (10, 25, 30).</p>
<p>Announcing perl1line.txt – A Collection of Handy Perl Scripts</p>
<p>The ultimate goal of the Perl One-Liners Explained article series was to release the perl1line.txt file. Last week I finished the series and today I am happy to announce perl1line.txt – a collection of handy Perl one-liner scripts.</p>
<p>Perl1line.txt file contains over a hundred short Perl one-line scripts for various text processing tasks. These tasks include – changing file spacing, numbering lines, doing calculations, creating strings and arrays, converting and substituting text, selective printing and deleting of certain lines, and modifying text with regular expressions.</p>
<p>The latest version of perl1line.txt is always at:</p>
<p><a target="_blank" rel="noopener" href="https://catonmat.net/ftp/perl1line.txt">https://catonmat.net/ftp/perl1line.txt</a></p>
<p>Here is the full table of contents of perl1line.txt.</p>
<pre><code>File Spacing.
Line Numbering.
Calculations.
String Creation and Array Creation.
Text Conversion and Substitution.
Selective Printing and Deleting of Certain Lines.
Handy Regular Expressions.
</code></pre>
<p>You can send me bug fixes and updates via GitHub. I put the file in its own perl1line.txt repository. I also accept translations. Send them in!</p>
<p>Awesome news: I have written an e-book based on the one-liners in this file. Check it out:<br>Perl book</p>
<p>Here is the whole file of perl1line.txt at version 1.0:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br></pre></td><td class="code"><pre><span class="line">Useful One-Line Scripts for Perl                                   version 1.0</span><br><span class="line">--------------------------------                                   -----------</span><br><span class="line"></span><br><span class="line">Compiled by Peteris Krumins (peter@catonmat.net, @pkrumins on Twitter)</span><br><span class="line">https://catonmat.net -- good coders code, great reuse</span><br><span class="line"></span><br><span class="line">Latest version of this file is always at:</span><br><span class="line"></span><br><span class="line">    https://catonmat.net/ftp/perl1line.txt</span><br><span class="line"></span><br><span class="line">This file is also available in other languages:</span><br><span class="line">    (None at the moment.)</span><br><span class="line">    Please email me peter@catonmat.net if you want to translate it.</span><br><span class="line"></span><br><span class="line">I am also writing &quot;Perl One-Liners Explained&quot; ebook that&#x27;s based on</span><br><span class="line">this file. It explains all the one-liners here. Get it soon at:</span><br><span class="line"></span><br><span class="line">    https://catonmat.net/perl-book/</span><br><span class="line"></span><br><span class="line">These one-liners work both on UNIX systems and Windows. Most likely your</span><br><span class="line">UNIX system already has Perl. For Windows get the Strawberry Perl at:</span><br><span class="line"></span><br><span class="line">    http://www.strawberryperl.com/</span><br><span class="line"></span><br><span class="line">Table of contents:</span><br><span class="line"></span><br><span class="line">    1. File Spacing</span><br><span class="line">    2. Line Numbering</span><br><span class="line">    3. Calculations</span><br><span class="line">    4. String Creation and Array Creation</span><br><span class="line">    5. Text Conversion and Substitution</span><br><span class="line">    6. Selective Printing and Deleting of Certain Lines    </span><br><span class="line">    7. Handy Regular Expressions</span><br><span class="line"></span><br><span class="line">FILE SPACING </span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line"># Double space a file</span><br><span class="line">perl -pe &#x27;$\=&quot;\n&quot;&#x27;</span><br><span class="line">perl -pe &#x27;BEGIN &#123; $\=&quot;\n&quot; &#125;&#x27;</span><br><span class="line">perl -pe &#x27;$_ .= &quot;\n&quot;&#x27;</span><br><span class="line">perl -pe &#x27;s/$/\n/&#x27;</span><br><span class="line"></span><br><span class="line"># Double space a file, except the blank lines</span><br><span class="line">perl -pe &#x27;$_ .= &quot;\n&quot; unless /^$/&#x27;</span><br><span class="line">perl -pe &#x27;$_ .= &quot;\n&quot; if /\S/&#x27;</span><br><span class="line"></span><br><span class="line"># Triple space a file</span><br><span class="line">perl -pe &#x27;$\=&quot;\n\n&quot;&#x27;</span><br><span class="line">perl -pe &#x27;$_.=&quot;\n\n&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># N-space a file</span><br><span class="line">perl -pe &#x27;$_.=&quot;\n&quot;x7&#x27;</span><br><span class="line"></span><br><span class="line"># Add a blank line before every line</span><br><span class="line">perl -pe &#x27;s//\n/&#x27;</span><br><span class="line"></span><br><span class="line"># Remove all blank lines</span><br><span class="line">perl -ne &#x27;print unless /^$/&#x27;</span><br><span class="line">perl -lne &#x27;print if length&#x27;</span><br><span class="line">perl -ne &#x27;print if /\S/&#x27;</span><br><span class="line"></span><br><span class="line"># Remove all consecutive blank lines, leaving just one</span><br><span class="line">perl -00 -pe &#x27;&#x27;</span><br><span class="line">perl -00pe0</span><br><span class="line"></span><br><span class="line"># Compress/expand all blank lines into N consecutive ones</span><br><span class="line">perl -00 -pe &#x27;$_.=&quot;\n&quot;x4&#x27;</span><br><span class="line"></span><br><span class="line">LINE NUMBERING</span><br><span class="line">--------------</span><br><span class="line"></span><br><span class="line"># Number all lines in a file</span><br><span class="line">perl -pe &#x27;$_ = &quot;$. $_&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># Number only non-empty lines in a file</span><br><span class="line">perl -pe &#x27;$_ = ++$a.&quot; $_&quot; if /./&#x27;</span><br><span class="line"></span><br><span class="line"># Number and print only non-empty lines in a file (drop empty lines)</span><br><span class="line">perl -ne &#x27;print ++$a.&quot; $_&quot; if /./&#x27;</span><br><span class="line"></span><br><span class="line"># Number all lines but print line numbers only non-empty lines</span><br><span class="line">perl -pe &#x27;$_ = &quot;$. $_&quot; if /./&#x27;</span><br><span class="line"></span><br><span class="line"># Number only lines that match a pattern, print others unmodified</span><br><span class="line">perl -pe &#x27;$_ = ++$a.&quot; $_&quot; if /regex/&#x27;</span><br><span class="line"></span><br><span class="line"># Number and print only lines that match a pattern</span><br><span class="line">perl -ne &#x27;print ++$a.&quot; $_&quot; if /regex/&#x27;</span><br><span class="line"></span><br><span class="line"># Number all lines, but print line numbers only for lines that match a pattern</span><br><span class="line">perl -pe &#x27;$_ = &quot;$. $_&quot; if /regex/&#x27;</span><br><span class="line"></span><br><span class="line"># Number all lines in a file using a custom format (emulate cat -n)</span><br><span class="line">perl -ne &#x27;printf &quot;%-5d %s&quot;, $., $_&#x27;</span><br><span class="line"></span><br><span class="line"># Print the total number of lines in a file (emulate wc -l)</span><br><span class="line">perl -lne &#x27;END &#123; print $. &#125;&#x27;</span><br><span class="line">perl -le &#x27;print $n=()=&lt;&gt;&#x27;</span><br><span class="line">perl -le &#x27;print scalar(()=&lt;&gt;)&#x27;</span><br><span class="line">perl -le &#x27;print scalar(@foo=&lt;&gt;)&#x27;</span><br><span class="line">perl -ne &#x27;&#125;&#123;print $.&#x27;</span><br><span class="line"></span><br><span class="line"># Print the number of non-empty lines in a file</span><br><span class="line">perl -le &#x27;print scalar(grep&#123;/./&#125;&lt;&gt;)&#x27;</span><br><span class="line">perl -le &#x27;print ~~grep&#123;/./&#125;&lt;&gt;&#x27;</span><br><span class="line">perl -le &#x27;print~~grep/./,&lt;&gt;&#x27;</span><br><span class="line"></span><br><span class="line"># Print the number of empty lines in a file</span><br><span class="line">perl -lne &#x27;$a++ if /^$/; END &#123;print $a+0&#125;&#x27;</span><br><span class="line">perl -le &#x27;print scalar(grep&#123;/^$/&#125;&lt;&gt;)&#x27;</span><br><span class="line">perl -le &#x27;print ~~grep&#123;/^$/&#125;&lt;&gt;&#x27;</span><br><span class="line"></span><br><span class="line"># Print the number of lines in a file that match a pattern (emulate grep -c)</span><br><span class="line">perl -lne &#x27;$a++ if /regex/; END &#123;print $a+0&#125;&#x27;</span><br><span class="line"></span><br><span class="line">CALCULATIONS</span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line"># Check if a number is a prime</span><br><span class="line">perl -lne &#x27;(1x$_) !~ /^1?$|^(11+?)\1+$/ &amp;&amp; print &quot;$_ is prime&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># Print the sum of all the fields on a line</span><br><span class="line">perl -MList::Util=sum -alne &#x27;print sum @F&#x27;</span><br><span class="line"></span><br><span class="line"># Print the sum of all the fields on all lines</span><br><span class="line">perl -MList::Util=sum -alne &#x27;push @S,@F; END &#123; print sum @S &#125;&#x27;</span><br><span class="line">perl -MList::Util=sum -alne &#x27;$s += sum @F; END &#123; print $s &#125;&#x27;</span><br><span class="line"></span><br><span class="line"># Shuffle all fields on a line</span><br><span class="line">perl -MList::Util=shuffle -alne &#x27;print &quot;@&#123;[shuffle @F]&#125;&quot;&#x27;</span><br><span class="line">perl -MList::Util=shuffle -alne &#x27;print join &quot; &quot;, shuffle @F&#x27;</span><br><span class="line"></span><br><span class="line"># Find the minimum element on a line</span><br><span class="line">perl -MList::Util=min -alne &#x27;print min @F&#x27;</span><br><span class="line"></span><br><span class="line"># Find the minimum element over all the lines</span><br><span class="line">perl -MList::Util=min -alne &#x27;@M = (@M, @F); END &#123; print min @M &#125;&#x27;</span><br><span class="line">perl -MList::Util=min -alne &#x27;$min = min @F; $rmin = $min unless defined $rmin &amp;&amp; $min &gt; $rmin; END &#123; print $rmin &#125;&#x27;</span><br><span class="line"></span><br><span class="line"># Find the maximum element on a line</span><br><span class="line">perl -MList::Util=max -alne &#x27;print max @F&#x27;</span><br><span class="line"></span><br><span class="line"># Find the maximum element over all the lines</span><br><span class="line">perl -MList::Util=max -alne &#x27;@M = (@M, @F); END &#123; print max @M &#125;&#x27;</span><br><span class="line"></span><br><span class="line"># Replace each field with its absolute value</span><br><span class="line">perl -alne &#x27;print &quot;@&#123;[map &#123; abs &#125; @F]&#125;&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># Find the total number of fields (words) on each line</span><br><span class="line">perl -alne &#x27;print scalar @F&#x27;</span><br><span class="line"></span><br><span class="line"># Print the total number of fields (words) on each line followed by the line</span><br><span class="line">perl -alne &#x27;print scalar @F, &quot; $_&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># Find the total number of fields (words) on all lines</span><br><span class="line">perl -alne &#x27;$t += @F; END &#123; print $t&#125;&#x27;</span><br><span class="line"></span><br><span class="line"># Print the total number of fields that match a pattern</span><br><span class="line">perl -alne &#x27;map &#123; /regex/ &amp;&amp; $t++ &#125; @F; END &#123; print $t &#125;&#x27;</span><br><span class="line">perl -alne &#x27;$t += /regex/ for @F; END &#123; print $t &#125;&#x27;</span><br><span class="line">perl -alne &#x27;$t += grep /regex/, @F; END &#123; print $t &#125;&#x27;</span><br><span class="line"></span><br><span class="line"># Print the total number of lines that match a pattern</span><br><span class="line">perl -lne &#x27;/regex/ &amp;&amp; $t++; END &#123; print $t &#125;&#x27;</span><br><span class="line"></span><br><span class="line"># Print the number PI to n decimal places</span><br><span class="line">perl -Mbignum=bpi -le &#x27;print bpi(n)&#x27;</span><br><span class="line"></span><br><span class="line"># Print the number PI to 39 decimal places</span><br><span class="line">perl -Mbignum=PI -le &#x27;print PI&#x27;</span><br><span class="line"></span><br><span class="line"># Print the number E to n decimal places</span><br><span class="line">perl -Mbignum=bexp -le &#x27;print bexp(1,n+1)&#x27;</span><br><span class="line"></span><br><span class="line"># Print the number E to 39 decimal places</span><br><span class="line">perl -Mbignum=e -le &#x27;print e&#x27;</span><br><span class="line"></span><br><span class="line"># Print UNIX time (seconds since Jan 1, 1970, 00:00:00 UTC)</span><br><span class="line">perl -le &#x27;print time&#x27;</span><br><span class="line"></span><br><span class="line"># Print GMT (Greenwich Mean Time) and local computer time</span><br><span class="line">perl -le &#x27;print scalar gmtime&#x27;</span><br><span class="line">perl -le &#x27;print scalar localtime&#x27;</span><br><span class="line"></span><br><span class="line"># Print local computer time in H:M:S format</span><br><span class="line">perl -le &#x27;print join &quot;:&quot;, (localtime)[2,1,0]&#x27;</span><br><span class="line"></span><br><span class="line"># Print yesterday&#x27;s date</span><br><span class="line">perl -MPOSIX -le &#x27;@now = localtime; $now[3] -= 1; print scalar localtime mktime @now&#x27;</span><br><span class="line"></span><br><span class="line"># Print date 14 months, 9 days and 7 seconds ago</span><br><span class="line">perl -MPOSIX -le &#x27;@now = localtime; $now[0] -= 7; $now[4] -= 14; $now[7] -= 9; print scalar localtime mktime @now&#x27;</span><br><span class="line"></span><br><span class="line"># Calculate factorial of 5</span><br><span class="line">perl -MMath::BigInt -le &#x27;print Math::BigInt-&gt;new(5)-&gt;bfac()&#x27;</span><br><span class="line">perl -le &#x27;$f = 1; $f *= $_ for 1..5; print $f&#x27;</span><br><span class="line"></span><br><span class="line"># Calculate greatest common divisor (GCM)</span><br><span class="line">perl -MMath::BigInt=bgcd -le &#x27;print bgcd(@list_of_numbers)&#x27;</span><br><span class="line"></span><br><span class="line"># Calculate GCM of numbers 20 and 35 using Euclid&#x27;s algorithm</span><br><span class="line">perl -le &#x27;$n = 20; $m = 35; ($m,$n) = ($n,$m%$n) while $n; print $m&#x27;</span><br><span class="line"></span><br><span class="line"># Calculate least common multiple (LCM) of numbers 35, 20 and 8</span><br><span class="line">perl -MMath::BigInt=blcm -le &#x27;print blcm(35,20,8)&#x27;</span><br><span class="line"></span><br><span class="line"># Calculate LCM of 20 and 35 using Euclid&#x27;s formula: n*m/gcd(n,m)</span><br><span class="line">perl -le &#x27;$a = $n = 20; $b = $m = 35; ($m,$n) = ($n,$m%$n) while $n; print $a*$b/$m&#x27;</span><br><span class="line"></span><br><span class="line"># Generate 10 random numbers between 5 and 15 (excluding 15)</span><br><span class="line">perl -le &#x27;$n=10; $min=5; $max=15; $, = &quot; &quot;; print map &#123; int(rand($max-$min))+$min &#125; 1..$n&#x27;</span><br><span class="line"></span><br><span class="line"># Find and print all permutations of a list</span><br><span class="line">perl -MAlgorithm::Permute -le &#x27;$l = [1,2,3,4,5]; $p = Algorithm::Permute-&gt;new($l); print @r while @r = $p-&gt;next&#x27;</span><br><span class="line"></span><br><span class="line"># Generate the power set</span><br><span class="line">perl -MList::PowerSet=powerset -le &#x27;@l = (1,2,3,4,5); for (@&#123;powerset(@l)&#125;) &#123; print &quot;@$_&quot; &#125;&#x27;</span><br><span class="line"></span><br><span class="line"># Convert an IP address to unsigned integer</span><br><span class="line">perl -le &#x27;$i=3; $u += ($_&lt;&lt;8*$i--) for &quot;127.0.0.1&quot; =~ /(\d+)/g; print $u&#x27;</span><br><span class="line">perl -le &#x27;$ip=&quot;127.0.0.1&quot;; $ip =~ s/(\d+)\.?/sprintf(&quot;%02x&quot;, $1)/ge; print hex($ip)&#x27;</span><br><span class="line">perl -le &#x27;print unpack(&quot;N&quot;, 127.0.0.1)&#x27;</span><br><span class="line">perl -MSocket -le &#x27;print unpack(&quot;N&quot;, inet_aton(&quot;127.0.0.1&quot;))&#x27;</span><br><span class="line"></span><br><span class="line"># Convert an unsigned integer to an IP address</span><br><span class="line">perl -MSocket -le &#x27;print inet_ntoa(pack(&quot;N&quot;, 2130706433))&#x27;</span><br><span class="line">perl -le &#x27;$ip = 2130706433; print join &quot;.&quot;, map &#123; (($ip&gt;&gt;8*($_))&amp;0xFF) &#125; reverse 0..3&#x27;</span><br><span class="line">perl -le &#x27;$ip = 2130706433; $, = &quot;.&quot;; print map &#123; (($ip&gt;&gt;8*($_))&amp;0xFF) &#125; reverse 0..3&#x27;</span><br><span class="line"></span><br><span class="line">STRING CREATION AND ARRAY CREATION</span><br><span class="line">----------------------------------</span><br><span class="line"></span><br><span class="line"># Generate and print the alphabet</span><br><span class="line">perl -le &#x27;print a..z&#x27;</span><br><span class="line">perl -le &#x27;print (&quot;a&quot;..&quot;z&quot;)&#x27;</span><br><span class="line">perl -le &#x27;$, = &quot;,&quot;; print (&quot;a&quot;..&quot;z&quot;)&#x27;</span><br><span class="line">perl -le &#x27;print join &quot;,&quot;, (&quot;a&quot;..&quot;z&quot;)&#x27;</span><br><span class="line"></span><br><span class="line"># Generate and print all the strings from &quot;a&quot; to &quot;zz&quot;</span><br><span class="line">perl -le &#x27;print (&quot;a&quot;..&quot;zz&quot;)&#x27;</span><br><span class="line">perl -le &#x27;print &quot;aa&quot;..&quot;zz&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># Create a hex lookup table</span><br><span class="line">@hex = (0..9, &quot;a&quot;..&quot;f&quot;)</span><br><span class="line"></span><br><span class="line"># Convert a decimal number to hex using @hex lookup table</span><br><span class="line">perl -le &#x27;$num = 255; @hex = (0..9, &quot;a&quot;..&quot;f&quot;); while ($num) &#123; $s = $hex[($num%16)&amp;15].$s; $num = int $num/16 &#125; print $s&#x27;</span><br><span class="line">perl -le &#x27;$hex = sprintf(&quot;%x&quot;, 255); print $hex&#x27;</span><br><span class="line">perl -le &#x27;$num = &quot;ff&quot;; print hex $num&#x27;</span><br><span class="line"></span><br><span class="line"># Generate a random 8 character password</span><br><span class="line">perl -le &#x27;print map &#123; (&quot;a&quot;..&quot;z&quot;)[rand 26] &#125; 1..8&#x27;</span><br><span class="line">perl -le &#x27;print map &#123; (&quot;a&quot;..&quot;z&quot;, 0..9)[rand 36] &#125; 1..8&#x27;</span><br><span class="line"></span><br><span class="line"># Create a string of specific length</span><br><span class="line">perl -le &#x27;print &quot;a&quot;x50&#x27;</span><br><span class="line"></span><br><span class="line"># Create a repeated list of elements</span><br><span class="line">perl -le &#x27;@list = (1,2)x20; print &quot;@list&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># Create an array from a string</span><br><span class="line">@months = split &#x27; &#x27;, &quot;Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec&quot;</span><br><span class="line">@months = qw/Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/</span><br><span class="line"></span><br><span class="line"># Create a string from an array</span><br><span class="line">@stuff = (&quot;hello&quot;, 0..9, &quot;world&quot;); $string = join &#x27;-&#x27;, @stuff</span><br><span class="line"></span><br><span class="line"># Find the numeric values for characters in the string</span><br><span class="line">perl -le &#x27;print join &quot;, &quot;, map &#123; ord &#125; split //, &quot;hello world&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># Convert a list of numeric ASCII values into a string</span><br><span class="line">perl -le &#x27;@ascii = (99, 111, 100, 105, 110, 103); print pack(&quot;C*&quot;, @ascii)&#x27;</span><br><span class="line">perl -le &#x27;@ascii = (99, 111, 100, 105, 110, 103); print map &#123; chr &#125; @ascii&#x27;</span><br><span class="line"></span><br><span class="line"># Generate an array with odd numbers from 1 to 100</span><br><span class="line">perl -le &#x27;@odd = grep &#123;$_ % 2 == 1&#125; 1..100; print &quot;@odd&quot;&#x27;</span><br><span class="line">perl -le &#x27;@odd = grep &#123; $_ &amp; 1 &#125; 1..100; print &quot;@odd&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># Generate an array with even numbers from 1 to 100</span><br><span class="line">perl -le &#x27;@even = grep &#123;$_ % 2 == 0&#125; 1..100; print &quot;@even&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># Find the length of the string</span><br><span class="line">perl -le &#x27;print length &quot;one-liners are great&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># Find the number of elements in an array</span><br><span class="line">perl -le &#x27;@array = (&quot;a&quot;..&quot;z&quot;); print scalar @array&#x27;</span><br><span class="line">perl -le &#x27;@array = (&quot;a&quot;..&quot;z&quot;); print $#array + 1&#x27;</span><br><span class="line"></span><br><span class="line">TEXT CONVERSION AND SUBSTITUTION</span><br><span class="line">--------------------------------</span><br><span class="line"></span><br><span class="line"># ROT13 a string</span><br><span class="line">&#x27;y/A-Za-z/N-ZA-Mn-za-m/&#x27;</span><br><span class="line"></span><br><span class="line"># ROT 13 a file</span><br><span class="line">perl -lpe &#x27;y/A-Za-z/N-ZA-Mn-za-m/&#x27; file</span><br><span class="line"></span><br><span class="line"># Base64 encode a string</span><br><span class="line">perl -MMIME::Base64 -e &#x27;print encode_base64(&quot;string&quot;)&#x27;</span><br><span class="line">perl -MMIME::Base64 -0777 -ne &#x27;print encode_base64($_)&#x27; file</span><br><span class="line"></span><br><span class="line"># Base64 decode a string</span><br><span class="line">perl -MMIME::Base64 -le &#x27;print decode_base64(&quot;base64string&quot;)&#x27;</span><br><span class="line">perl -MMIME::Base64 -ne &#x27;print decode_base64($_)&#x27; file</span><br><span class="line"></span><br><span class="line"># URL-escape a string</span><br><span class="line">perl -MURI::Escape -le &#x27;print uri_escape($string)&#x27;</span><br><span class="line"></span><br><span class="line"># URL-unescape a string</span><br><span class="line">perl -MURI::Escape -le &#x27;print uri_unescape($string)&#x27;</span><br><span class="line"></span><br><span class="line"># HTML-encode a string</span><br><span class="line">perl -MHTML::Entities -le &#x27;print encode_entities($string)&#x27;</span><br><span class="line"></span><br><span class="line"># HTML-decode a string</span><br><span class="line">perl -MHTML::Entities -le &#x27;print decode_entities($string)&#x27;</span><br><span class="line"></span><br><span class="line"># Convert all text to uppercase</span><br><span class="line">perl -nle &#x27;print uc&#x27;</span><br><span class="line">perl -ple &#x27;$_=uc&#x27;</span><br><span class="line">perl -nle &#x27;print &quot;\U$_&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># Convert all text to lowercase</span><br><span class="line">perl -nle &#x27;print lc&#x27;</span><br><span class="line">perl -ple &#x27;$_=lc&#x27;</span><br><span class="line">perl -nle &#x27;print &quot;\L$_&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># Uppercase only the first word of each line</span><br><span class="line">perl -nle &#x27;print ucfirst lc&#x27;</span><br><span class="line">perl -nle &#x27;print &quot;\u\L$_&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># Invert the letter case</span><br><span class="line">perl -ple &#x27;y/A-Za-z/a-zA-Z/&#x27;</span><br><span class="line"></span><br><span class="line"># Camel case each line</span><br><span class="line">perl -ple &#x27;s/(\w+)/\u$1/g&#x27;</span><br><span class="line">perl -ple &#x27;s/(?&lt;![&#x27;])(\w+)/\u\1/g&#x27;</span><br><span class="line"></span><br><span class="line"># Strip leading whitespace (spaces, tabs) from the beginning of each line</span><br><span class="line">perl -ple &#x27;s/^[ \t]+//&#x27;</span><br><span class="line">perl -ple &#x27;s/^\s+//&#x27;</span><br><span class="line"></span><br><span class="line"># Strip trailing whitespace (space, tabs) from the end of each line</span><br><span class="line">perl -ple &#x27;s/[ \t]+$//&#x27;</span><br><span class="line"></span><br><span class="line"># Strip whitespace from the beginning and end of each line</span><br><span class="line">perl -ple &#x27;s/^[ \t]+|[ \t]+$//g&#x27;</span><br><span class="line"></span><br><span class="line"># Convert UNIX newlines to DOS/Windows newlines</span><br><span class="line">perl -pe &#x27;s|\n|\r\n|&#x27;</span><br><span class="line"></span><br><span class="line"># Convert DOS/Windows newlines to UNIX newlines</span><br><span class="line">perl -pe &#x27;s|\r\n|\n|&#x27;</span><br><span class="line"></span><br><span class="line"># Convert UNIX newlines to Mac newlines</span><br><span class="line">perl -pe &#x27;s|\n|\r|&#x27;</span><br><span class="line"></span><br><span class="line"># Substitute (find and replace) &quot;foo&quot; with &quot;bar&quot; on each line</span><br><span class="line">perl -pe &#x27;s/foo/bar/&#x27;</span><br><span class="line"></span><br><span class="line"># Substitute (find and replace) all &quot;foo&quot;s with &quot;bar&quot; on each line</span><br><span class="line">perl -pe &#x27;s/foo/bar/g&#x27;</span><br><span class="line"></span><br><span class="line"># Substitute (find and replace) &quot;foo&quot; with &quot;bar&quot; on lines that match &quot;baz&quot;</span><br><span class="line">perl -pe &#x27;/baz/ &amp;&amp; s/foo/bar/&#x27;</span><br><span class="line"></span><br><span class="line">SELECTIVE PRINTING AND DELETING OF CERTAIN LINES</span><br><span class="line">------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Print the first line of a file (emulate head -1)</span><br><span class="line">perl -ne &#x27;print; exit&#x27;</span><br><span class="line"></span><br><span class="line"># Print the first 10 lines of a file (emulate head -10)</span><br><span class="line">perl -ne &#x27;print if $. &lt;= 10&#x27;</span><br><span class="line">perl -ne &#x27;$. &lt;= 10 &amp;&amp; print&#x27;</span><br><span class="line"></span><br><span class="line"># Print the last line of a file (emulate tail -1)</span><br><span class="line">perl -ne &#x27;$last = $_; END &#123; print $last &#125;&#x27;</span><br><span class="line">perl -ne &#x27;print if eof&#x27;</span><br><span class="line"></span><br><span class="line"># Print the last 10 lines of a file (emulate tail -10)</span><br><span class="line">perl -ne &#x27;push @a, $_; @a = @a[@a-10..$#a]; END &#123; print @a &#125;&#x27;</span><br><span class="line"></span><br><span class="line"># Print only lines that match a regular expression</span><br><span class="line">perl -ne &#x27;/regex/ &amp;&amp; print&#x27;</span><br><span class="line"></span><br><span class="line"># Print only lines that do not match a regular expression</span><br><span class="line">perl -ne &#x27;!/regex/ &amp;&amp; print&#x27;</span><br><span class="line"></span><br><span class="line"># Print the line before a line that matches a regular expression</span><br><span class="line">perl -ne &#x27;/regex/ &amp;&amp; $last &amp;&amp; print $last; $last = $_&#x27;</span><br><span class="line"></span><br><span class="line"># Print the line after a line that matches a regular expression</span><br><span class="line">perl -ne &#x27;if ($p) &#123; print; $p = 0 &#125; $p++ if /regex/&#x27;</span><br><span class="line"></span><br><span class="line"># Print lines that match regex AAA and regex BBB in any order</span><br><span class="line">perl -ne &#x27;/AAA/ &amp;&amp; /BBB/ &amp;&amp; print&#x27;</span><br><span class="line"></span><br><span class="line"># Print lines that don&#x27;t match match regexes AAA and BBB</span><br><span class="line">perl -ne &#x27;!/AAA/ &amp;&amp; !/BBB/ &amp;&amp; print&#x27;</span><br><span class="line"></span><br><span class="line"># Print lines that match regex AAA followed by regex BBB followed by CCC</span><br><span class="line">perl -ne &#x27;/AAA.*BBB.*CCC/ &amp;&amp; print&#x27;</span><br><span class="line"></span><br><span class="line"># Print lines that are 80 chars or longer</span><br><span class="line">perl -ne &#x27;print if length &gt;= 80&#x27;</span><br><span class="line"></span><br><span class="line"># Print lines that are less than 80 chars in length</span><br><span class="line">perl -ne &#x27;print if length &lt; 80&#x27;</span><br><span class="line"></span><br><span class="line"># Print only line 13</span><br><span class="line">perl -ne &#x27;$. == 13 &amp;&amp; print &amp;&amp; exit&#x27;</span><br><span class="line"></span><br><span class="line"># Print all lines except line 27</span><br><span class="line">perl -ne &#x27;$. != 27 &amp;&amp; print&#x27;</span><br><span class="line">perl -ne &#x27;print if $. != 27&#x27;</span><br><span class="line"></span><br><span class="line"># Print only lines 13, 19 and 67</span><br><span class="line">perl -ne &#x27;print if $. == 13 || $. == 19 || $. == 67&#x27;</span><br><span class="line">perl -ne &#x27;print if int($.) ~~ (13, 19, 67)&#x27; </span><br><span class="line"></span><br><span class="line"># Print all lines between two regexes (including lines that match regex)</span><br><span class="line">perl -ne &#x27;print if /regex1/../regex2/&#x27;</span><br><span class="line"></span><br><span class="line"># Print all lines from line 17 to line 30</span><br><span class="line">perl -ne &#x27;print if $. &gt;= 17 &amp;&amp; $. &lt;= 30&#x27;</span><br><span class="line">perl -ne &#x27;print if int($.) ~~ (17..30)&#x27;</span><br><span class="line">perl -ne &#x27;print if grep &#123; $_ == $. &#125; 17..30&#x27;</span><br><span class="line"></span><br><span class="line"># Print the longest line</span><br><span class="line">perl -ne &#x27;$l = $_ if length($_) &gt; length($l); END &#123; print $l &#125;&#x27;</span><br><span class="line"></span><br><span class="line"># Print the shortest line</span><br><span class="line">perl -ne &#x27;$s = $_ if $. == 1; $s = $_ if length($_) &lt; length($s); END &#123; print $s &#125;&#x27;</span><br><span class="line"></span><br><span class="line"># Print all lines that contain a number</span><br><span class="line">perl -ne &#x27;print if /\d/&#x27;</span><br><span class="line"></span><br><span class="line"># Find all lines that contain only a number</span><br><span class="line">perl -ne &#x27;print if /^\d+$/&#x27;</span><br><span class="line"></span><br><span class="line"># Print all lines that contain only characters</span><br><span class="line">perl -ne &#x27;print if /^[[:alpha:]]+$/</span><br><span class="line"></span><br><span class="line"># Print every second line</span><br><span class="line">perl -ne &#x27;print if $. % 2&#x27;</span><br><span class="line"></span><br><span class="line"># Print every second line, starting the second line</span><br><span class="line">perl -ne &#x27;print if $. % 2 == 0&#x27;</span><br><span class="line"></span><br><span class="line"># Print all lines that repeat</span><br><span class="line">perl -ne &#x27;print if ++$a&#123;$_&#125; == 2&#x27;</span><br><span class="line"></span><br><span class="line"># Print all unique lines</span><br><span class="line">perl -ne &#x27;print unless $a&#123;$_&#125;++&#x27;</span><br><span class="line"></span><br><span class="line">HANDY REGULAR EXPRESSIONS</span><br><span class="line">-------------------------</span><br><span class="line"></span><br><span class="line"># Match something that looks like an IP address</span><br><span class="line">/^\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;$/</span><br><span class="line">/^(\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;$/</span><br><span class="line"></span><br><span class="line"># Test if a number is in range 0-255</span><br><span class="line">/^([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/</span><br><span class="line"></span><br><span class="line"># Match an IP address</span><br><span class="line">my $ip_part = qr|([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|;</span><br><span class="line">if ($ip =~ /^($ip_part\.)&#123;3&#125;$ip_part$/) &#123;</span><br><span class="line"> say &quot;valid ip&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Check if the string looks like an email address</span><br><span class="line">/.+@.+\..+/</span><br><span class="line"></span><br><span class="line"># Check if the string is a decimal number</span><br><span class="line">/^\d+$/</span><br><span class="line">/^[+-]?\d+$/</span><br><span class="line">/^[+-]?\d+\.?\d*$/</span><br><span class="line"></span><br><span class="line"># Check if the string is a hexadecimal number</span><br><span class="line">/^0x[0-9a-f]+$/i</span><br><span class="line"></span><br><span class="line"># Check if the string is an octal number</span><br><span class="line">/^0[0-7]+$/</span><br><span class="line"></span><br><span class="line"># Check if the string is binary</span><br><span class="line">/^[01]+$/</span><br><span class="line"></span><br><span class="line"># Check if a word appears twice in the string</span><br><span class="line">/(word).*\1/</span><br><span class="line"></span><br><span class="line"># Increase all numbers by one in the string</span><br><span class="line">$str =~ s/(\d+)/$1+1/ge</span><br><span class="line"></span><br><span class="line"># Extract HTTP User-Agent string from the HTTP headers</span><br><span class="line">/^User-Agent: (.+)$/</span><br><span class="line"></span><br><span class="line"># Match printable ASCII characters</span><br><span class="line">/[ -~]/</span><br><span class="line"></span><br><span class="line"># Match unprintable ASCII characters</span><br><span class="line">/[^ -~]/</span><br><span class="line"></span><br><span class="line"># Match text between two HTML tags</span><br><span class="line">m|&lt;strong&gt;([^&lt;]*)&lt;/strong&gt;|</span><br><span class="line">m|&lt;strong&gt;(.*?)&lt;/strong&gt;|</span><br><span class="line"></span><br><span class="line"># Replace all &lt;b&gt; tags with &lt;strong&gt;</span><br><span class="line">$html =~ s|&lt;(/)?b&gt;|&lt;$1strong&gt;|g</span><br><span class="line"></span><br><span class="line"># Extract all matches from a regular expression</span><br><span class="line">my @matches = $text =~ /regex/g;</span><br><span class="line"></span><br><span class="line">PERL ONE-LINERS EXPLAINED E-BOOK</span><br><span class="line">--------------------------------</span><br><span class="line"></span><br><span class="line">I am writing an ebook based on the one-liners in this file. If you want to</span><br><span class="line">support my work and learn more about these one-liners, you can get a copy</span><br><span class="line">of my ebook soon at:</span><br><span class="line"></span><br><span class="line">    https://catonmat.net/perl-book/</span><br><span class="line"></span><br><span class="line">The ebook is based on the 7-part article series that I wrote on my blog.</span><br><span class="line">In the ebook I reviewed all the one-liners, improved explanations and added</span><br><span class="line">new ones.</span><br><span class="line"></span><br><span class="line">You can read the original article series here:</span><br><span class="line"></span><br><span class="line">    https://catonmat.net/perl-one-liners-explained-part-one/</span><br><span class="line">    https://catonmat.net/perl-one-liners-explained-part-two/</span><br><span class="line">    https://catonmat.net/perl-one-liners-explained-part-three/</span><br><span class="line">    https://catonmat.net/perl-one-liners-explained-part-four/</span><br><span class="line">    https://catonmat.net/perl-one-liners-explained-part-five/</span><br><span class="line">    https://catonmat.net/perl-one-liners-explained-part-six/</span><br><span class="line">    https://catonmat.net/perl-one-liners-explained-part-seven/</span><br><span class="line"></span><br><span class="line">HAVE FUN</span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line">I hope you found these one-liners useful and have fun!</span><br><span class="line"></span><br><span class="line">#---end of file---</span><br></pre></td></tr></table></figure>

<p>Perl One-Liners Explained Article Series</p>
<p>If you’re curious how the one-liners work, take a look at the Perl One-Liners Explained article series. I have explained all of them in the following articles:</p>
<pre><code>Part I: File spacing.
Part II: Line numbering.
Part III: Calculations.
Part IV: String creation and array creation.
Part V: Text conversion and substitution.
Part VI: Selective printing and deleting of certain lines.
Part VII: Handy regular expressions.
</code></pre>
<p>The next, and final, thing I am doing with these one-liners is releasing Perl One-Liners Explained e-book. Stay tuned!</p>
<p>Update: I finished writing the e-book. Check it out!<br>Awk and Sed One-Liners Explained</p>
<p>I based the perl1line.txt file on the famous awk1line.txt and sed1line.txt files. That’s how I actually learned awk and sed. I studied these two files inside out and learned everything I could about sed and awk. Later I decided to contribute back to the community and explained all one-liners in these two article series:</p>
<pre><code>Awk One-Liners Explained  https://catonmat.net/awk-one-liners-explained-part-one
Sed One-Liners Explained  https://catonmat.net/sed-one-liners-explained-part-one
</code></pre>
<p>Awk posts have been read over 2,000,000 times and sed posts over 1,500,000 times.</p>
<p>Have fun writing one-liners and see you next time!<br>Read more articles →<br>Thanks for reading my post. If you enjoyed it and would like to receive my posts automatically, you can subscribe to new posts via rss feed or email.</p>
<p>Perl One-Liners Explained, Part VII: Handy Regular Expressions</p>
<p>Dnode – A Node.js Module You Should Know About<br>Secret message: Use coupon code JELLYLING to get a discount at my company Browserling!</p>
<p>Announcing my third e-book “Perl One-Liners Explained”</p>
<p>Buy it now for just $19.99</p>
<p>PayPal - The safer, easier way to pay online!</p>
<p>Hello everyone! I’m happy to announce my 3rd e-book called Perl One-Liners Explained. This book is based on the Perl One-Liners Explained article series that I wrote over the last 3 years and that has been read over 1,000,000 times!</p>
<p>I went through all the one-liners in the article series, improved explanations, fixed mistakes and typos, added a bunch of new one-liners, added an introduction to Perl one-liners and a new chapter on Perl’s special variables.<br>Table of Contents</p>
<p>The e-book explains 130 unique one-liners. Many of one-liners are presented in several different ways so the total number of one-liners in the book is over 200.</p>
<p>The e-book is divided into the following chapters:</p>
<pre><code>Preface.
1. Introduction to Perl One-Liners.
2. Spacing.
3. Numbering.
4. Calculations
5. String Creation and Array Creation.
6. Text Conversion and Substitution.
7. Selective Printing and Deleting of Lines.
8. Handy Regular Expressions.
9. perl1line.txt
Appendix A. Perl&#39;s Special Variables.
Index.
</code></pre>
<p>What are Perl One-Liners?</p>
<p>Perl one-liners are small and awesome Perl programs that fit in a single line of code and they do one thing really well. These things include changing line spacing, numbering lines, doing calculations, converting and substituting text, deleting and printing certain lines, parsing logs, editing files in-place, doing statistics, carrying out system administration tasks, updating a bunch of files at once, and many more.</p>
<p>Let’s take a look at several practical examples that you can easily do with one-liners. All these examples and many more are explained in the e-book.</p>
<p>I have also made the first chapter of the book, Introduction to Perl One-Liners, freely available. Please download the e-book preview to read it.</p>
<p>Example 1: Replace a string in multiple files at once</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -p -i.bak -e &#x27;s/Config/config/g&#x27; conf1 conf2 conf3</span><br></pre></td></tr></table></figure>
<p>Suppose you have 3 configuration files, and you discover that you made a mistake and need to replace all occurrences of Config with config. This one-liner does just that. It executes the s&#x2F;Config&#x2F;config&#x2F;g that replaces all occurrences of Config with config on all lines. And since you’re smart about it, you always do -i.bak to make backup files in case something goes wrong.</p>
<p>I explain the -i, -p, and -e arguments in the e-book in great detail.</p>
<p>Example 2: Generate a random 8 character password</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print map &#123; (&quot;a&quot;..&quot;z&quot;)[rand 26] &#125; 1..8&#x27;</span><br></pre></td></tr></table></figure>
<p>This one-liner generates and prints a random 8 character password. It uses the list range operator .. operator to produce all strings from “a” to “z”, which is the alphabet. Then a random letter is chosen by rand 26 and this operation is repeated 8 times.</p>
<p>Example 3: URL-escape a string</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MURI::Escape -lne &#x27;print uri_escape($string)&#x27;</span><br></pre></td></tr></table></figure>
<p>Here we use the URI::Escape module from CPAN. It exports the uri_escape function that does URL-escaping.</p>
<p>You can install this module from CPAN by running perl -MCPAN -e’install URI::Escape’ on the command line.</p>
<p>I have this one-liner as an alias actually for both URL-escaping and unescaping URL-escaping as it’s such a common thing to do:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">urlescape () &#123; perl -MURI::Escape -lne &#x27;print uri_escape($_)&#x27; &lt;&lt;&lt; &quot;$1&quot; &#125;</span><br><span class="line">urlunescape () &#123; perl -MURI::Escape -lne &#x27;print uri_unescape($_)&#x27; &lt;&lt;&lt; &quot;$1&quot;; &#125;</span><br></pre></td></tr></table></figure>
<p>Then I can do this in the shell:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ urlescape &quot;https://catonmat.net&quot;</span><br><span class="line">https%3A%2F%2Fcatonmat.net</span><br><span class="line"></span><br><span class="line">$ urlunescape https%3A%2F%2Fcatonmat.net</span><br><span class="line">https://catonmat.net</span><br></pre></td></tr></table></figure>
<p>Very useful!</p>
<p>Example 4: Print all lines from line 17 to line 30</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -ne &#x27;print if 17..30&#x27;</span><br></pre></td></tr></table></figure>
<p>Here we use the binary flip-flop operator .. that becomes true when the input line number is 17, stays true while the line number is less than or equal to 30, and then becomes false. Combining the flip-flop operator with print if makes it print only lines 17-30.</p>
<p>Example 5: Remove all consecutive blank lines, leaving just one</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -00pe0</span><br></pre></td></tr></table></figure>
<p>I included this one-liner here in the examples just to show you how funny and obscure one-liners can get. This one-liner deletes all repeated blank lines from the input or from the given file. It does it by enabling the paragraph slurp mode through -00 command line argument, which reads the input paragraph-by-paragraph, rather than line-by-line, and prints the paragraphs. This way any number of blank lines between the paragraphs get ignored.</p>
<p>I explain this one-liner in more details in the e-book.</p>
<p>As I hope you can see, knowing how to write one-liners is very useful. It was one of my top priority tasks through the years to become very efficient in the shell. Literally every day when I’m programming, I have to do all kinds of data processing tasks, changing files, verifying output, doing quick calculations, parsing data, etc, and knowing Perl one-liners makes it really fast to get things done.</p>
<p>Now that I have written this e-book, you can become very efficient, too. Enjoy!<br>Book Preview</p>
<p>I prepared a free book preview that contains the first 13 pages of the book. It includes the table of contents, preface, introduction to Perl one-liners and the first page of the second chapter.<br>Perl One-Liners Explained. Book Preview.<br>Buy it now!</p>
<p>The price of the e-book is $19.99 and it can be purchased via PayPal:<br>PayPal - The safer, easier way to pay online!</p>
<p>After you have made the payment, my automated e-book processing system will send you the PDF e-book in a few minutes!<br>Tweet about my book!</p>
<p>Help me spread the word about my new book. I prepared a special link that you can use to tweet about it.<br>What’s next?</p>
<p>I really love writing about programming and I have planned writing many more books. The next few are going to be a book on mastering vim, a practical guide on how to be anonymous on the web, and the catonmat book.<br>Enjoy!</p>
<p>Enjoy the book and let me know how you liked it.</p>
<p>Also if you’re interested, take a look at my other two e-books. The 1st one is called “Awk One-Liners Explained” and the 2nd one is called “Sed One-Liners Explained” They’re written in a similar style as this e-book and they teach practical Awk and Sed through many examples.</p>
<p>Finally, if you enjoy my writing, you can subscribe to my blog, follow me on Twitter or Google+.<br>Read more articles →<br>Thanks for reading my post. If you enjoyed it and would like to receive my posts automatically, you can subscribe to new posts via rss feed or email.<br>How Browserling Works [art]<br>Announcing dedicated servers for Browserling<br>Secret message: Use coupon code JELLYLING to get a discount at my company Browserling!</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://magesfc.github.io">mage</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://magesfc.github.io/mage/04947dc3d5b90a6c19672409e839d803a0aef01a/">https://magesfc.github.io/mage/04947dc3d5b90a6c19672409e839d803a0aef01a/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://magesfc.github.io" target="_blank">马哥私房菜</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/cookbook/">cookbook</a><a class="post-meta__tags" href="/tags/perl/">perl</a></div><div class="post_share"><div class="social-share" data-image="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/null" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/mage/041aeaf616293d64689343ad605f14cf73b589b0/"><img class="prev-cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Django学习之初识</div></div></a></div><div class="next-post pull-right"><a href="/mage/c17549d1cd4516fc242a8551d78cc1754d69a33e/"><img class="next-cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Ansible自动化运维工具之常用的模块</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/mage/fbdc2108c9ff66cef6915dd7b0ca474e0f1bfcab/" title="Linux学习之awk学习之cookbook技巧"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之awk学习之cookbook技巧</div></div></a></div><div><a href="/mage/a718e01bee375dd72d94fd15211e2e4f41c0a52c/" title="Linux学习之bash学习之cookbook技巧"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之bash学习之cookbook技巧</div></div></a></div><div><a href="/mage/6a323979d022165779db1cbb3367540e235cec9e/" title="Linux学习之sed学习之cookbook技巧"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之sed学习之cookbook技巧</div></div></a></div><div><a href="/mage/bead5c222ebd755a0ea0b8165ff0663545d6c700/" title="Linux学习之10个有用的链式操作符及其实例"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之10个有用的链式操作符及其实例</div></div></a></div><div><a href="/mage/16b8c6357057536aa45c505f7c99cb9d22c87038/" title="Linux学习之awk学习之Linux-awk-command系列"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之awk学习之Linux-awk-command系列</div></div></a></div><div><a href="/mage/0158e8186f0827d0b00df276735e46e876749b88/" title="Linux学习之bash学习之在bash中&#x3D;和&#x3D;~的区别"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之bash学习之在bash中&#x3D;和&#x3D;~的区别</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mage</div><div class="author-info__description"> 这里是 马哥 的个人博客 </div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">152</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">170</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mamh2021"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mamh2021" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/mage/7b14abc60e1d18cc8811745a97f263978e87e4ae/" title="Hexo个人博客搭建教程"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo个人博客搭建教程"/></a><div class="content"><a class="title" href="/mage/7b14abc60e1d18cc8811745a97f263978e87e4ae/" title="Hexo个人博客搭建教程">Hexo个人博客搭建教程</a><time datetime="2022-10-28T13:37:31.000Z" title="发表于 2022-10-28 21:37:31">2022-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/9797fe175c0183a6563e7397692d780ecf683a6f/" title="Ansible自动化运维工具之ansible-resources"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ansible自动化运维工具之ansible-resources"/></a><div class="content"><a class="title" href="/mage/9797fe175c0183a6563e7397692d780ecf683a6f/" title="Ansible自动化运维工具之ansible-resources">Ansible自动化运维工具之ansible-resources</a><time datetime="2022-10-16T09:27:39.000Z" title="发表于 2022-10-16 17:27:39">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/a0bfcc2b49b5167196ecf1ed7f20f9eb180d9a43/" title="Ansible自动化运维工具之synchronize模块学习"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ansible自动化运维工具之synchronize模块学习"/></a><div class="content"><a class="title" href="/mage/a0bfcc2b49b5167196ecf1ed7f20f9eb180d9a43/" title="Ansible自动化运维工具之synchronize模块学习">Ansible自动化运维工具之synchronize模块学习</a><time datetime="2022-10-13T03:27:35.000Z" title="发表于 2022-10-13 11:27:35">2022-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/11746f2e578549a6bef3af02d587fa65f8a9b7ab/" title="Nightingale学习之安装部署"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nightingale学习之安装部署"/></a><div class="content"><a class="title" href="/mage/11746f2e578549a6bef3af02d587fa65f8a9b7ab/" title="Nightingale学习之安装部署">Nightingale学习之安装部署</a><time datetime="2022-10-11T02:05:58.000Z" title="发表于 2022-10-11 10:05:58">2022-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/a6082cc302dc1ea3400936da1405365de03cbc7f/" title="React学习总结"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React学习总结"/></a><div class="content"><a class="title" href="/mage/a6082cc302dc1ea3400936da1405365de03cbc7f/" title="React学习总结">React学习总结</a><time datetime="2022-09-13T14:01:10.000Z" title="发表于 2022-09-13 22:01:10">2022-09-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By mage</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>