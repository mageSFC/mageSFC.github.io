<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Python学习之Primer_on_Python_Decorators | 马哥私房菜</title><meta name="author" content="mage"><meta name="copyright" content="mage"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Primer on Python Decoratorshttps:&#x2F;&#x2F;realpython.com&#x2F;primer-on-python-decorators&#x2F; Table of Contents123456789101112131415161718192021222324252627282930313233FunctionsFirst-Class ObjectsInner FunctionsRetu">
<meta property="og:type" content="article">
<meta property="og:title" content="Python学习之Primer_on_Python_Decorators">
<meta property="og:url" content="https://magesfc.github.io/mage/428e45833de1d6977f072fa67593f8a21d9a315c/">
<meta property="og:site_name" content="马哥私房菜">
<meta property="og:description" content="Primer on Python Decoratorshttps:&#x2F;&#x2F;realpython.com&#x2F;primer-on-python-decorators&#x2F; Table of Contents123456789101112131415161718192021222324252627282930313233FunctionsFirst-Class ObjectsInner FunctionsRetu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://t.mwm.moe/fj/">
<meta property="article:published_time" content="2022-02-23T09:47:21.000Z">
<meta property="article:modified_time" content="2022-02-23T09:47:21.000Z">
<meta property="article:author" content="mage">
<meta property="article:tag" content="python">
<meta property="article:tag" content="primer">
<meta property="article:tag" content="on">
<meta property="article:tag" content="decorators">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://t.mwm.moe/fj/"><link rel="shortcut icon" href="https://www.zeekrlife.com/favicon.png"><link rel="canonical" href="https://magesfc.github.io/mage/428e45833de1d6977f072fa67593f8a21d9a315c/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: mage","link":"链接: ","source":"来源: 马哥私房菜","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python学习之Primer_on_Python_Decorators',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-23 17:47:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">.card-announcement .social-button{margin:.6rem 0 0 0;text-align:center}.card-announcement .social-button a{display:block;background-color:var(--btn-bg);color:var(--btn-color);text-align:center;line-height:2.4;margin:4px 0}.card-announcement .social-button a:hover{background-color:var(--btn-hover-color)}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">216</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">231</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 精选文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> 🚀 快速开始</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/dc584b87/"><span> 📑 主题页面</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4aa8abbe/"><span> 🛠 主题配置-1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/ceeb73f/"><span> 🛠 主题配置-2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/98d20436/"><span> ❓ 主题问答</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4073eda/"><span> ⚡️ 进阶教程</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/198a4240/"><span> ✨ 更新日志</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://butterfly.js.org/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> 其他示例</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t.mwm.moe/fj/')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">马哥私房菜</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 精选文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> 🚀 快速开始</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/dc584b87/"><span> 📑 主题页面</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4aa8abbe/"><span> 🛠 主题配置-1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/ceeb73f/"><span> 🛠 主题配置-2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/98d20436/"><span> ❓ 主题问答</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4073eda/"><span> ⚡️ 进阶教程</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/198a4240/"><span> ✨ 更新日志</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://butterfly.js.org/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> 其他示例</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python学习之Primer_on_Python_Decorators</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-23T09:47:21.000Z" title="发表于 2022-02-23 17:47:21">2022-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-23T09:47:21.000Z" title="更新于 2022-02-23 17:47:21">2022-02-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python/">python</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Python学习之Primer_on_Python_Decorators"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Primer-on-Python-Decorators"><a href="#Primer-on-Python-Decorators" class="headerlink" title="Primer on Python Decorators"></a>Primer on Python Decorators</h1><p><a target="_blank" rel="noopener" href="https://realpython.com/primer-on-python-decorators/">https://realpython.com/primer-on-python-decorators/</a></p>
<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">Functions</span><br><span class="line">First-Class Objects</span><br><span class="line">Inner Functions</span><br><span class="line">Returning Functions From Functions</span><br><span class="line">Simple Decorators</span><br><span class="line">Syntactic Sugar!</span><br><span class="line">Reusing Decorators</span><br><span class="line">Decorating Functions With Arguments</span><br><span class="line">Returning Values From Decorated Functions</span><br><span class="line">Who Are You, Really?</span><br><span class="line">A Few Real World Examples</span><br><span class="line">Timing Functions</span><br><span class="line">Debugging Code</span><br><span class="line">Slowing Down Code</span><br><span class="line">Registering Plugins</span><br><span class="line">Is the User Logged In?</span><br><span class="line">Fancy Decorators</span><br><span class="line">Decorating Classes</span><br><span class="line">Nesting Decorators</span><br><span class="line">Decorators With Arguments</span><br><span class="line">Both Please, But Never Mind the Bread</span><br><span class="line">Stateful Decorators</span><br><span class="line">Classes <span class="keyword">as</span> Decorators</span><br><span class="line">More Real World Examples</span><br><span class="line">Slowing Down Code, Revisited</span><br><span class="line">Creating Singletons</span><br><span class="line">Caching Return Values</span><br><span class="line">Adding Information About Units</span><br><span class="line">Validating JSON</span><br><span class="line">Conclusion</span><br><span class="line">Further Reading</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> Watch Now This tutorial has a related video course created by the Real Python team. Watch it together with the written </span><br><span class="line"> tutorial to deepen your understanding: Python Decorators 101</span><br><span class="line"></span><br><span class="line">In this tutorial on decorators, we’ll look at what they are and how to create and use them. Decorators provide a simple </span><br><span class="line">syntax for calling higher-order functions.</span><br><span class="line"></span><br><span class="line">By definition, a decorator is a function that takes another function and extends the behavior of the latter function </span><br><span class="line">without explicitly modifying it.</span><br><span class="line"></span><br><span class="line">This sounds confusing, but it’s really not, especially after you’ve seen a few examples of how decorators work. You can </span><br><span class="line">find all the examples from this article here.</span><br><span class="line"></span><br><span class="line">Free Bonus: Click here to get access to a free &quot;The Power of Python Decorators&quot; guide that shows you 3 advanced decorator</span><br><span class="line"> patterns and techniques you can use to write to cleaner and more Pythonic programs.</span><br><span class="line"></span><br><span class="line">Decorators Cheat Sheet: Click here to get access to a free 3-page Python decorators cheat sheet that summarizes the </span><br><span class="line">techniques explained in this tutorial.</span><br><span class="line"></span><br><span class="line">Decorators Q&amp;A Transcript: Click here to get access to a 25-page chat log from our recent Python decorators Q&amp;A session</span><br><span class="line"> in the Real Python Community Slack where we discussed common decorator questions.</span><br></pre></td></tr></table></figure>

<h2 id="Updates"><a href="#Updates" class="headerlink" title="Updates:"></a>Updates:</h2><p>08&#x2F;22&#x2F;2018: Major update adding more examples and more advanced decorators<br>01&#x2F;12&#x2F;2016: Updated examples to Python 3 (v3.5.1) syntax and added a new example<br>11&#x2F;01&#x2F;2015: Added a brief explanation on the functools.wraps() decorator</p>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>Before you can understand decorators, you must first understand how functions work.<br>For our purposes, a function returns a value based on the given arguments.<br>Here is a very simple example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add_one(number):</span><br><span class="line">...     return number + 1</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; add_one(2)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>In general, functions in Python may also have side effects rather than just turning an input into an output. The print() function is a basic example of this: it returns None while having the side effect of outputting something to the console. However, to understand decorators, it is enough to think about functions as something that turns given arguments into a value.</p>
<p>Note: In functional programming, you work (almost) only with pure functions without side effects. While not a purely functional language, Python supports many of the functional programming concepts, including functions as first-class objects.</p>
<p>First-Class Objects<br>In Python, functions are first-class objects. This means that functions can be passed around and used as arguments, just like any other object (string, int, float, list, and so on). Consider the following three functions:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def say_hello(name):</span><br><span class="line">    return f&quot;Hello &#123;name&#125;&quot;</span><br><span class="line"></span><br><span class="line">def be_awesome(name):</span><br><span class="line">    return f&quot;Yo &#123;name&#125;, together we are the awesomest!&quot;</span><br><span class="line"></span><br><span class="line">def greet_bob(greeter_func):</span><br><span class="line">    return greeter_func(&quot;Bob&quot;)</span><br><span class="line">```    </span><br><span class="line">Here, say_hello() and be_awesome() are regular functions that expect a name given as a string. The greet_bob() function however, expects a function as its argument. We can, for instance, pass it the say_hello() or the be_awesome() function:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>greet_bob(say_hello)<br>‘Hello Bob’</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>greet_bob(be_awesome)<br>‘Yo Bob, together we are the awesomest!’</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Note that greet_bob(say_hello) refers to two functions, but in different ways: greet_bob() and say_hello. The say_hello function is named without parentheses. This means that only a reference to the function is passed. The function is not executed. The greet_bob() function, on the other hand, is written with parentheses, so it will be called as usual.</span><br><span class="line"></span><br><span class="line">Inner Functions</span><br><span class="line">It’s possible to define functions inside other functions. Such functions are called inner functions. Here’s an example of a function with two inner functions:</span><br></pre></td></tr></table></figure>
<p>def parent():<br>    print(“Printing from the parent() function”)</p>
<pre><code>def first_child():
    print(&quot;Printing from the first_child() function&quot;)

def second_child():
    print(&quot;Printing from the second_child() function&quot;)

second_child()
first_child()
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">What happens when you call the parent() function? Think about this for a minute. The output will be as follows:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>parent()<br>Printing from the parent() function<br>Printing from the second_child() function<br>Printing from the first_child() function</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Note that the order in which the inner functions are defined does not matter. Like with any other functions, the printing only happens when the inner functions are executed.</span><br><span class="line"></span><br><span class="line">Furthermore, the inner functions are not defined until the parent function is called. They are locally scoped to parent(): they only exist inside the parent() function as local variables. Try calling first_child(). You should get an error:</span><br></pre></td></tr></table></figure>
<p>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>NameError: name ‘first_child’ is not defined</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Whenever you call parent(), the inner functions first_child() and second_child() are also called. But because of their local scope, they aren’t available outside of the parent() function.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Remove ads</span><br><span class="line">Returning Functions From Functions</span><br><span class="line">Python also allows you to use functions as return values. The following example returns one of the inner functions from the outer parent() function:</span><br></pre></td></tr></table></figure>
<p>def parent(num):<br>    def first_child():<br>        return “Hi, I am Emma”</p>
<pre><code>def second_child():
    return &quot;Call me Liam&quot;

if num == 1:
    return first_child
else:
    return second_child
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Note that you are returning first_child without the parentheses. Recall that this means that you are returning a reference to the function first_child. In contrast first_child() with parentheses refers to the result of evaluating the function. This can be seen in the following example:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>first &#x3D; parent(1)<br>second &#x3D; parent(2)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>first<br>&lt;function parent.<locals>.first_child at 0x7f599f1e2e18&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>second<br>&lt;function parent.<locals>.second_child at 0x7f599dad5268&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The somewhat cryptic output simply means that the first variable refers to the local first_child() function inside of parent(), while second points to second_child().</span><br><span class="line"></span><br><span class="line">You can now use first and second as if they are regular functions, even though the functions they point to can’t be accessed directly:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>first()<br>‘Hi, I am Emma’</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>second()<br>‘Call me Liam’</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Finally, note that in the earlier example you executed the inner functions within the parent function, for instance first_child(). However, in this last example, you did not add parentheses to the inner functions—first_child—upon returning. That way, you got a reference to each function that you could call in the future. Make sense?</span><br><span class="line"></span><br><span class="line">Simple Decorators</span><br><span class="line">Now that you’ve seen that functions are just like any other object in Python, you’re ready to move on and see the magical beast that is the Python decorator. Let’s start with an example:</span><br></pre></td></tr></table></figure>
<p>def my_decorator(func):<br>    def wrapper():<br>        print(“Something is happening before the function is called.”)<br>        func()<br>        print(“Something is happening after the function is called.”)<br>    return wrapper</p>
<p>def say_whee():<br>    print(“Whee!”)</p>
<p>say_whee &#x3D; my_decorator(say_whee)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Can you guess what happens when you call say_whee()? Try it:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>say_whee()<br>Something is happening before the function is called.<br>Whee!<br>Something is happening after the function is called.</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">To understand what’s going on here, look back at the previous examples. We are literally just applying everything you have learned so far.</span><br><span class="line"></span><br><span class="line">The so-called decoration happens at the following line:</span><br></pre></td></tr></table></figure>
<p>say_whee &#x3D; my_decorator(say_whee)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In effect, the name say_whee now points to the wrapper() inner function. Remember that you return wrapper as a function when you call my_decorator(say_whee):</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>say_whee<br>&lt;function my_decorator.<locals>.wrapper at 0x7f3c5dfd42f0&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">However, wrapper() has a reference to the original say_whee() as func, and calls that function between the two calls to print().</span><br><span class="line"></span><br><span class="line">Put simply: decorators wrap a function, modifying its behavior.</span><br><span class="line"></span><br><span class="line">Before moving on, let’s have a look at a second example. Because wrapper() is a regular Python function, the way a </span><br><span class="line">decorator modifies a function can change dynamically. So as not to disturb your neighbors, the following example will</span><br><span class="line">only run the decorated code during the day:</span><br></pre></td></tr></table></figure>
<p>from datetime import datetime</p>
<p>def not_during_the_night(func):<br>    def wrapper():<br>        if 7 &lt;&#x3D; datetime.now().hour &lt; 22:<br>            func()<br>        else:<br>            pass  # Hush, the neighbors are asleep<br>    return wrapper</p>
<p>def say_whee():<br>    print(“Whee!”)</p>
<p>say_whee &#x3D; not_during_the_night(say_whee)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If you try to call say_whee() after bedtime, nothing will happen:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>say_whee()</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">Syntactic Sugar!</span><br><span class="line">The way you decorated say_whee() above is a little clunky. First of all, you end up typing the name say_whee three times. In addition, the decoration gets a bit hidden away below the definition of the function.</span><br><span class="line"></span><br><span class="line">Instead, Python allows you to use decorators in a simpler way with the @ symbol, sometimes called the “pie” syntax. The following example does the exact same thing as the first decorator example:</span><br></pre></td></tr></table></figure>
<p>def my_decorator(func):<br>    def wrapper():<br>        print(“Something is happening before the function is called.”)<br>        func()<br>        print(“Something is happening after the function is called.”)<br>    return wrapper</p>
<p>@my_decorator<br>def say_whee():<br>    print(“Whee!”)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">So, @my_decorator is just an easier way of saying say_whee = my_decorator(say_whee). It’s how you apply a decorator to a function.</span><br><span class="line"></span><br><span class="line">Reusing Decorators</span><br><span class="line">Recall that a decorator is just a regular Python function. All the usual tools for easy reusability are available. Let’s move the decorator to its own module that can be used in many other functions.</span><br><span class="line"></span><br><span class="line">Create a file called decorators.py with the following content:</span><br></pre></td></tr></table></figure>
<p>def do_twice(func):<br>    def wrapper_do_twice():<br>        func()<br>        func()<br>    return wrapper_do_twice</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Note: You can name your inner function whatever you want, and a generic name like wrapper() is usually okay. You’ll see a lot of decorators in this article. To keep them apart, we’ll name the inner function with the same name as the decorator but with a wrapper_ prefix.</span><br><span class="line"></span><br><span class="line">You can now use this new decorator in other files by doing a regular import:</span><br></pre></td></tr></table></figure>
<p>from decorators import do_twice</p>
<p>@do_twice<br>def say_whee():<br>    print(“Whee!”)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">When you run this example, you should see that the original say_whee() is executed twice:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>say_whee()<br>Whee!<br>Whee!</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Free Bonus: Click here to get access to a free &quot;The Power of Python Decorators&quot; guide that shows you 3 advanced decorator</span><br><span class="line"> patterns and techniques you can use to write to cleaner and more Pythonic programs.</span><br><span class="line"></span><br><span class="line">Decorating Functions With Arguments</span><br><span class="line">Say that you have a function that accepts some arguments. Can you still decorate it? Let’s try:</span><br></pre></td></tr></table></figure>
<p>from decorators import do_twice</p>
<p>@do_twice<br>def greet(name):<br>    print(f”Hello {name}”)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unfortunately, running this code raises an error:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>greet(“World”)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>TypeError: wrapper_do_twice() takes 0 positional arguments but 1 was given</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The problem is that the inner function wrapper_do_twice() does not take any arguments, but name=&quot;World&quot; was passed to it.</span><br><span class="line"> You could fix this by letting wrapper_do_twice() accept one argument, but then it would not work for the say_whee() </span><br><span class="line"> function you created earlier.</span><br><span class="line"></span><br><span class="line">The solution is to use *args and **kwargs in the inner wrapper function. Then it will accept an arbitrary number of </span><br><span class="line">positional and keyword arguments. Rewrite decorators.py as follows:</span><br></pre></td></tr></table></figure>
<p>def do_twice(func):<br>    def wrapper_do_twice(*args, **kwargs):<br>        func(*args, **kwargs)<br>        func(*args, **kwargs)<br>    return wrapper_do_twice</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The wrapper_do_twice() inner function now accepts any number of arguments and passes them on to the function it decorates. Now both your say_whee() and greet() examples works:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>say_whee()<br>Whee!<br>Whee!</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>greet(“World”)<br>Hello World<br>Hello World</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Returning Values From Decorated Functions</span><br><span class="line">What happens to the return value of decorated functions? Well, that’s up to the decorator to decide. Let’s say you decorate a simple function as follows:</span><br></pre></td></tr></table></figure>
<p>from decorators import do_twice</p>
<p>@do_twice<br>def return_greeting(name):<br>    print(“Creating greeting”)<br>    return f”Hi {name}”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Try to use it:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>hi_adam &#x3D; return_greeting(“Adam”)<br>Creating greeting<br>Creating greeting<br>print(hi_adam)<br>None</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Oops, your decorator ate the return value from the function.</span><br><span class="line"></span><br><span class="line">Because the do_twice_wrapper() doesn’t explicitly return a value, the call return_greeting(&quot;Adam&quot;) ended up returning None.</span><br><span class="line"></span><br><span class="line">To fix this, you need to make sure the wrapper function returns the return value of the decorated function. Change your decorators.py file:</span><br></pre></td></tr></table></figure>
<p>def do_twice(func):<br>    def wrapper_do_twice(*args, **kwargs):<br>        func(*args, **kwargs)<br>        return func(*args, **kwargs)<br>    return wrapper_do_twice</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The return value from the last execution of the function is returned:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>return_greeting(“Adam”)<br>Creating greeting<br>Creating greeting<br>‘Hi Adam’</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Who Are You, Really?</span><br><span class="line">A great convenience when working with Python, especially in the interactive shell, is its powerful introspection ability.</span><br><span class="line"> Introspection is the ability of an object to know about its own attributes at runtime. For instance, a function knows its</span><br><span class="line">  own name and documentation:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>print<br><built-in function print></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>print.<strong>name</strong><br>‘print’</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>help(print)<br>Help on built-in function print in module builtins:</p>
</blockquote>
</blockquote>
</blockquote>
<p>print(…)<br>    <full help message></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">The introspection works for functions you define yourself as well:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>say_whee<br>&lt;function do_twice.<locals>.wrapper_do_twice at 0x7f43700e52f0&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>say_whee.<strong>name</strong><br>‘wrapper_do_twice’</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>help(say_whee)<br>Help on function wrapper_do_twice in module decorators:</p>
</blockquote>
</blockquote>
</blockquote>
<p>wrapper_do_twice()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">However, after being decorated, say_whee() has gotten very confused about its identity. It now reports being the wrapper_do_twice() inner function inside the do_twice() decorator. Although technically true, this is not very useful information.</span><br><span class="line"></span><br><span class="line">To fix this, decorators should use the @functools.wraps decorator, which will preserve information about the original function. Update decorators.py again:</span><br></pre></td></tr></table></figure>
<p>import functools</p>
<p>def do_twice(func):<br>    @functools.wraps(func)<br>    def wrapper_do_twice(*args, **kwargs):<br>        func(*args, **kwargs)<br>        return func(*args, **kwargs)<br>    return wrapper_do_twice</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">You do not need to change anything about the decorated say_whee() function:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>say_whee<br>&lt;function say_whee at 0x7ff79a60f2f0&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>say_whee.<strong>name</strong><br>‘say_whee’</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>help(say_whee)<br>Help on function say_whee in module whee:</p>
</blockquote>
</blockquote>
</blockquote>
<p>say_whee()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Much better! Now say_whee() is still itself after decoration.</span><br><span class="line"></span><br><span class="line">Technical Detail: The @functools.wraps decorator uses the function functools.update_wrapper() to update special attributes</span><br><span class="line"> like __name__ and __doc__ that are used in the introspection.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## A Few Real World Examples</span><br><span class="line">Let’s look at a few more useful examples of decorators. You’ll notice that they’ll mainly follow the same pattern that you’ve learned so far:</span><br></pre></td></tr></table></figure>
<p>import functools</p>
<p>def decorator(func):<br>    @functools.wraps(func)<br>    def wrapper_decorator(*args, **kwargs):<br>        # Do something before<br>        value &#x3D; func(*args, **kwargs)<br>        # Do something after<br>        return value<br>    return wrapper_decorator</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">This formula is a good boilerplate template for building more complex decorators.</span><br><span class="line"></span><br><span class="line">Note: In later examples, we will assume that these decorators are saved in your decorators.py file as well. Recall that you can download all the examples in this tutorial.</span><br><span class="line"></span><br><span class="line">Timing Functions</span><br><span class="line">Let’s start by creating a @timer decorator. It will measure the time a function takes to execute and print the duration to the console. Here’s the code:</span><br></pre></td></tr></table></figure>
<p>import functools<br>import time</p>
<p>def timer(func):<br>    “””Print the runtime of the decorated function”””<br>    @functools.wraps(func)<br>    def wrapper_timer(*args, **kwargs):<br>        start_time &#x3D; time.perf_counter()    # 1<br>        value &#x3D; func(*args, **kwargs)<br>        end_time &#x3D; time.perf_counter()      # 2<br>        run_time &#x3D; end_time - start_time    # 3<br>        print(f”Finished {func.<strong>name</strong>!r} in {run_time:.4f} secs”)<br>        return value<br>    return wrapper_timer</p>
<p>@timer<br>def waste_some_time(num_times):<br>    for _ in range(num_times):<br>        sum([i**2 for i in range(10000)])</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This decorator works by storing the time just before the function starts running (at the line marked # 1) and just after the function finishes (at # 2). The time the function takes is then the difference between the two (at # 3). We use the time.perf_counter() function, which does a good job of measuring time intervals. Here are some examples of timings:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>waste_some_time(1)<br>Finished ‘waste_some_time’ in 0.0010 secs</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>waste_some_time(999)<br>Finished ‘waste_some_time’ in 0.3260 secs</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Run it yourself. Work through the code line by line. Make sure you understand how it works. Don’t worry if you don’t get it, though. Decorators are advanced beings. Try to sleep on it or make a drawing of the program flow.</span><br><span class="line"></span><br><span class="line">Note: The @timer decorator is great if you just want to get an idea about the runtime of your functions. If you want to do more precise measurements of code, you should instead consider the timeit module in the standard library. It temporarily disables garbage collection and runs multiple trials to strip out noise from quick function calls.</span><br><span class="line"></span><br><span class="line">Debugging Code</span><br><span class="line">The following @debug decorator will print the arguments a function is called with as well as its return value every time the function is called:</span><br></pre></td></tr></table></figure>
<p>import functools</p>
<p>def debug(func):<br>    “””Print the function signature and return value”””<br>    @functools.wraps(func)<br>    def wrapper_debug(*args, **kwargs):<br>        args_repr &#x3D; [repr(a) for a in args]                      # 1<br>        kwargs_repr &#x3D; [f”{k}&#x3D;{v!r}” for k, v in kwargs.items()]  # 2<br>        signature &#x3D; “, “.join(args_repr + kwargs_repr)           # 3<br>        print(f”Calling {func.<strong>name</strong>}({signature})”)<br>        value &#x3D; func(*args, **kwargs)<br>        print(f”{func.<strong>name</strong>!r} returned {value!r}”)           # 4<br>        return value<br>    return wrapper_debug</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The signature is created by joining the string representations of all the arguments. The numbers in the following list correspond to the numbered comments in the code:</span><br><span class="line"></span><br><span class="line">Create a list of the positional arguments. Use repr() to get a nice string representing each argument.</span><br><span class="line">Create a list of the keyword arguments. The f-string formats each argument as key=value where the !r specifier means that repr() is used to represent the value.</span><br><span class="line">The lists of positional and keyword arguments is joined together to one signature string with each argument separated by a comma.</span><br><span class="line">The return value is printed after the function is executed.</span><br><span class="line">Let’s see how the decorator works in practice by applying it to a simple function with one position and one keyword argument:</span><br></pre></td></tr></table></figure>
<p>@debug<br>def make_greeting(name, age&#x3D;None):<br>    if age is None:<br>        return f”Howdy {name}!”<br>    else:<br>        return f”Whoa {name}! {age} already, you are growing up!”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Note how the @debug decorator prints the signature and return value of the make_greeting() function:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>make_greeting(“Benjamin”)<br>Calling make_greeting(‘Benjamin’)<br>‘make_greeting’ returned ‘Howdy Benjamin!’<br>‘Howdy Benjamin!’</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>make_greeting(“Richard”, age&#x3D;112)<br>Calling make_greeting(‘Richard’, age&#x3D;112)<br>‘make_greeting’ returned ‘Whoa Richard! 112 already, you are growing up!’<br>‘Whoa Richard! 112 already, you are growing up!’</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>make_greeting(name&#x3D;”Dorrisile”, age&#x3D;116)<br>Calling make_greeting(name&#x3D;’Dorrisile’, age&#x3D;116)<br>‘make_greeting’ returned ‘Whoa Dorrisile! 116 already, you are growing up!’<br>‘Whoa Dorrisile! 116 already, you are growing up!’</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This example might not seem immediately useful since the @debug decorator just repeats what you just wrote. It’s more powerful when applied to small convenience functions that you don’t call directly yourself.</span><br><span class="line"></span><br><span class="line">The following example calculates an approximation to the mathematical constant e:</span><br></pre></td></tr></table></figure>
<p>import math<br>from decorators import debug</p>
<h1 id="Apply-a-decorator-to-a-standard-library-function"><a href="#Apply-a-decorator-to-a-standard-library-function" class="headerlink" title="Apply a decorator to a standard library function"></a>Apply a decorator to a standard library function</h1><p>math.factorial &#x3D; debug(math.factorial)</p>
<p>def approximate_e(terms&#x3D;18):<br>    return sum(1 &#x2F; math.factorial(n) for n in range(terms))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">This example also shows how you can apply a decorator to a function that has already been defined.</span><br><span class="line"> The approximation of e is based on the following series expansion:</span><br><span class="line"></span><br><span class="line">Series for calculating mathematical constant e</span><br><span class="line"></span><br><span class="line">When calling the approximate_e() function, you can see the @debug decorator at work:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>approximate_e(5)<br>Calling factorial(0)<br>‘factorial’ returned 1<br>Calling factorial(1)<br>‘factorial’ returned 1<br>Calling factorial(2)<br>‘factorial’ returned 2<br>Calling factorial(3)<br>‘factorial’ returned 6<br>Calling factorial(4)<br>‘factorial’ returned 24<br>2.708333333333333</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In this example, you get a decent approximation to the true value e = 2.718281828, adding only 5 terms.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Slowing Down Code</span><br><span class="line">This next example might not seem very useful. Why would you want to slow down your Python code? Probably the most common use case is that you want to rate-limit a function that continuously checks whether a resource—like a web page—has changed. The @slow_down decorator will sleep one second before it calls the decorated function:</span><br></pre></td></tr></table></figure>
<p>import functools<br>import time</p>
<p>def slow_down(func):<br>    “””Sleep 1 second before calling the function”””<br>    @functools.wraps(func)<br>    def wrapper_slow_down(*args, **kwargs):<br>        time.sleep(1)<br>        return func(*args, **kwargs)<br>    return wrapper_slow_down</p>
<p>@slow_down<br>def countdown(from_number):<br>    if from_number &lt; 1:<br>        print(“Liftoff!”)<br>    else:<br>        print(from_number)<br>        countdown(from_number - 1)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To see the effect of the @slow_down decorator, you really need to run the example yourself:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>countdown(3)<br>3<br>2<br>1<br>Liftoff!</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Note: The countdown() function is a recursive function. In other words, it’s a function calling itself. To learn more about recursive functions in Python, see our guide on Thinking Recursively in Python.</span><br><span class="line"></span><br><span class="line">The @slow_down decorator always sleeps for one second. Later, you’ll see how to control the rate by passing an argument to the decorator.</span><br><span class="line"></span><br><span class="line">Registering Plugins</span><br><span class="line">Decorators don’t have to wrap the function they’re decorating. They can also simply register that a function exists and return it unwrapped. This can be used, for instance, to create a light-weight plug-in architecture:</span><br></pre></td></tr></table></figure>
<p>import random<br>PLUGINS &#x3D; dict()</p>
<p>def register(func):<br>    “””Register a function as a plug-in”””<br>    PLUGINS[func.<strong>name</strong>] &#x3D; func<br>    return func</p>
<p>@register<br>def say_hello(name):<br>    return f”Hello {name}”</p>
<p>@register<br>def be_awesome(name):<br>    return f”Yo {name}, together we are the awesomest!”</p>
<p>def randomly_greet(name):<br>    greeter, greeter_func &#x3D; random.choice(list(PLUGINS.items()))<br>    print(f”Using {greeter!r}”)<br>    return greeter_func(name)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The @register decorator simply stores a reference to the decorated function in the global PLUGINS dict. Note that you do not have to write an inner function or use @functools.wraps in this example because you are returning the original function unmodified.</span><br><span class="line"></span><br><span class="line">The randomly_greet() function randomly chooses one of the registered functions to use. Note that the PLUGINS dictionary already contains references to each function object that is registered as a plugin:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>PLUGINS<br>{‘say_hello’: &lt;function say_hello at 0x7f768eae6730&gt;,<br> ‘be_awesome’: &lt;function be_awesome at 0x7f768eae67b8&gt;}</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>randomly_greet(“Alice”)<br>Using ‘say_hello’<br>‘Hello Alice’</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The main benefit of this simple plugin architecture is that you do not need to maintain a list of which plugins exist. That list is created when the plugins register themselves. This makes it trivial to add a new plugin: just define the function and decorate it with @register.</span><br><span class="line"></span><br><span class="line">If you are familiar with globals() in Python, you might see some similarities to how the plugin architecture works. globals() gives access to all global variables in the current scope, including your plugins:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>globals()<br>{…, # Lots of variables not shown here.<br> ‘say_hello’: &lt;function say_hello at 0x7f768eae6730&gt;,<br> ‘be_awesome’: &lt;function be_awesome at 0x7f768eae67b8&gt;,<br> ‘randomly_greet’: &lt;function randomly_greet at 0x7f768eae6840&gt;}</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Using the @register decorator, you can create your own curated list of interesting variables, effectively hand-picking some functions from globals().</span><br><span class="line"></span><br><span class="line">Is the User Logged In?</span><br><span class="line">The final example before moving on to some fancier decorators is commonly used when working with a web framework. In this example, we are using Flask to set up a /secret web page that should only be visible to users that are logged in or otherwise authenticated:</span><br></pre></td></tr></table></figure>
<p>from flask import Flask, g, request, redirect, url_for<br>import functools<br>app &#x3D; Flask(<strong>name</strong>)</p>
<p>def login_required(func):<br>    “””Make sure user is logged in before proceeding”””<br>    @functools.wraps(func)<br>    def wrapper_login_required(*args, **kwargs):<br>        if g.user is None:<br>            return redirect(url_for(“login”, next&#x3D;request.url))<br>        return func(*args, **kwargs)<br>    return wrapper_login_required</p>
<p>@app.route(“&#x2F;secret”)<br>@login_required<br>def secret():<br>    …</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">While this gives an idea about how to add authentication to your web framework, you should usually not write these types of decorators yourself. For Flask, you can use the Flask-Login extension instead, which adds more security and functionality.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Fancy Decorators</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">So far, you’ve seen how to create simple decorators. You already have a pretty good understanding of what decorators are and how they work. Feel free to take a break from this article to practice everything you’ve learned.</span><br><span class="line"></span><br><span class="line">In the second part of this tutorial, we’ll explore more advanced features, including how to use the following:</span><br><span class="line"></span><br><span class="line">    Decorators on classes</span><br><span class="line">    Several decorators on one function</span><br><span class="line">    Decorators with arguments</span><br><span class="line">    Decorators that can optionally take arguments</span><br><span class="line">    Stateful decorators</span><br><span class="line">    Classes as decorators</span><br><span class="line"></span><br><span class="line">Decorating Classes</span><br><span class="line"></span><br><span class="line">There are two different ways you can use decorators on classes. The first one is very close to what you have already done with functions: you can decorate the methods of a class. This was one of the motivations for introducing decorators back in the day.</span><br><span class="line"></span><br><span class="line">Some commonly used decorators that are even built-ins in Python are @classmethod, @staticmethod, and @property. The @classmethod and @staticmethod decorators are used to define methods inside a class namespace that are not connected to a particular instance of that class. The @property decorator is used to customize getters and setters for class attributes. Expand the box below for an example using these decorators.</span><br><span class="line"></span><br><span class="line">The following definition of a Circle class uses the @classmethod, @staticmethod, and @property decorators:</span><br><span class="line">```python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Circle:</span><br><span class="line">    def __init__(self, radius):</span><br><span class="line">        self._radius = radius</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def radius(self):</span><br><span class="line">        &quot;&quot;&quot;Get value of radius&quot;&quot;&quot;</span><br><span class="line">        return self._radius</span><br><span class="line"></span><br><span class="line">    @radius.setter</span><br><span class="line">    def radius(self, value):</span><br><span class="line">        &quot;&quot;&quot;Set radius, raise error if negative&quot;&quot;&quot;</span><br><span class="line">        if value &gt;= 0:</span><br><span class="line">            self._radius = value</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&quot;Radius must be positive&quot;)</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def area(self):</span><br><span class="line">        &quot;&quot;&quot;Calculate area inside circle&quot;&quot;&quot;</span><br><span class="line">        return self.pi() * self.radius**2</span><br><span class="line"></span><br><span class="line">    def cylinder_volume(self, height):</span><br><span class="line">        &quot;&quot;&quot;Calculate volume of cylinder with circle as base&quot;&quot;&quot;</span><br><span class="line">        return self.area * height</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def unit_circle(cls):</span><br><span class="line">        &quot;&quot;&quot;Factory method creating a circle with radius 1&quot;&quot;&quot;</span><br><span class="line">        return cls(1)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def pi():</span><br><span class="line">        &quot;&quot;&quot;Value of π, could use math.pi instead though&quot;&quot;&quot;</span><br><span class="line">        return 3.1415926535</span><br></pre></td></tr></table></figure>
<p>In this class:</p>
<pre><code>.cylinder_volume() is a regular method.
.radius is a mutable property: it can be set to a different value. However, by defining a setter method, we can do some error testing to make sure it’s not set to a nonsensical negative number. Properties are accessed as attributes without parentheses.
.area is an immutable property: properties without .setter() methods can’t be changed. Even though it is defined as a method, it can be retrieved as an attribute without parentheses.
.unit_circle() is a class method. It’s not bound to one particular instance of Circle. Class methods are often used as factory methods that can create specific instances of the class.
.pi() is a static method. It’s not really dependent on the Circle class, except that it is part of its namespace. Static methods can be called on either an instance or the class.
</code></pre>
<p>The Circle class can for example be used as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = Circle(5)</span><br><span class="line">&gt;&gt;&gt; c.radius</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; c.area</span><br><span class="line">78.5398163375</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; c.radius = 2</span><br><span class="line">&gt;&gt;&gt; c.area</span><br><span class="line">12.566370614</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; c.area = 100</span><br><span class="line">AttributeError: can&#x27;t set attribute</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; c.cylinder_volume(height=4)</span><br><span class="line">50.265482456</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; c.radius = -1</span><br><span class="line">ValueError: Radius must be positive</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; c = Circle.unit_circle()</span><br><span class="line">&gt;&gt;&gt; c.radius</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; c.pi()</span><br><span class="line">3.1415926535</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Circle.pi()</span><br><span class="line">3.1415926535</span><br></pre></td></tr></table></figure>
<p>Let’s define a class where we decorate some of its methods using the @debug and @timer decorators from earlier:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from decorators import debug, timer</span><br><span class="line"></span><br><span class="line">class TimeWaster:</span><br><span class="line">    @debug</span><br><span class="line">    def __init__(self, max_num):</span><br><span class="line">        self.max_num = max_num</span><br><span class="line"></span><br><span class="line">    @timer</span><br><span class="line">    def waste_time(self, num_times):</span><br><span class="line">        for _ in range(num_times):</span><br><span class="line">            sum([i**2 for i in range(self.max_num)])</span><br></pre></td></tr></table></figure>
<p>Using this class, you can see the effect of the decorators:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tw = TimeWaster(1000)</span><br><span class="line">Calling __init__(&lt;time_waster.TimeWaster object at 0x7efccce03908&gt;, 1000)</span><br><span class="line">&#x27;__init__&#x27; returned None</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; tw.waste_time(999)</span><br><span class="line">Finished &#x27;waste_time&#x27; in 0.3376 secs</span><br></pre></td></tr></table></figure>
<p>The other way to use decorators on classes is to decorate the whole class. This is, for example, done in the new dataclasses module in Python 3.7:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from dataclasses import dataclass</span><br><span class="line"></span><br><span class="line">@dataclass</span><br><span class="line">class PlayingCard:</span><br><span class="line">    rank: str</span><br><span class="line">    suit: str</span><br></pre></td></tr></table></figure>
<p>The meaning of the syntax is similar to the function decorators. In the example above, you could have done the decoration by writing PlayingCard &#x3D; dataclass(PlayingCard).</p>
<p>A common use of class decorators is to be a simpler alternative to some use-cases of metaclasses. In both cases, you are changing the definition of a class dynamically.</p>
<p>Writing a class decorator is very similar to writing a function decorator. The only difference is that the decorator will receive a class and not a function as an argument. In fact, all the decorators you saw above will work as class decorators. When you are using them on a class instead of a function, their effect might not be what you want. In the following example, the @timer decorator is applied to a class:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from decorators import timer</span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">class TimeWaster:</span><br><span class="line">    def __init__(self, max_num):</span><br><span class="line">        self.max_num = max_num</span><br><span class="line"></span><br><span class="line">    def waste_time(self, num_times):</span><br><span class="line">        for _ in range(num_times):</span><br><span class="line">            sum([i**2 for i in range(self.max_num)])</span><br></pre></td></tr></table></figure>
<p>Decorating a class does not decorate its methods. Recall that @timer is just shorthand for TimeWaster &#x3D; timer(TimeWaster).</p>
<p>Here, @timer only measures the time it takes to instantiate the class:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tw = TimeWaster(1000)</span><br><span class="line">Finished &#x27;TimeWaster&#x27; in 0.0000 secs</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; tw.waste_time(999)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>Later, you will see an example defining a proper class decorator, namely @singleton, which ensures that there is only one instance of a class.<br>Nesting Decorators</p>
<h2 id="Nesting-Decorators"><a href="#Nesting-Decorators" class="headerlink" title="Nesting Decorators"></a>Nesting Decorators</h2><p>You can apply several decorators to a function by stacking them on top of each other:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from decorators import debug, do_twice</span><br><span class="line"></span><br><span class="line">@debug</span><br><span class="line">@do_twice</span><br><span class="line">def greet(name):</span><br><span class="line">    print(f&quot;Hello &#123;name&#125;&quot;)</span><br></pre></td></tr></table></figure>
<p>Think about this as the decorators being executed in the order they are listed. In other words, @debug calls @do_twice, which calls greet(), or debug(do_twice(greet())):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; greet(&quot;Eva&quot;)</span><br><span class="line">Calling greet(&#x27;Eva&#x27;)</span><br><span class="line">Hello Eva</span><br><span class="line">Hello Eva</span><br><span class="line">&#x27;greet&#x27; returned None</span><br></pre></td></tr></table></figure>
<p>Observe the difference if we change the order of @debug and @do_twice:</p>
<p>from decorators import debug, do_twice</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@do_twice</span><br><span class="line">@debug</span><br><span class="line">def greet(name):</span><br><span class="line">    print(f&quot;Hello &#123;name&#125;&quot;)</span><br></pre></td></tr></table></figure>
<p>In this case, @do_twice will be applied to @debug as well:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; greet(&quot;Eva&quot;)</span><br><span class="line">Calling greet(&#x27;Eva&#x27;)</span><br><span class="line">Hello Eva</span><br><span class="line">&#x27;greet&#x27; returned None</span><br><span class="line">Calling greet(&#x27;Eva&#x27;)</span><br><span class="line">Hello Eva</span><br><span class="line">&#x27;greet&#x27; returned None</span><br></pre></td></tr></table></figure>

<p>Decorators With Arguments<br>Sometimes, it’s useful to pass arguments to your decorators. For instance, @do_twice could be extended to a @repeat(num_times) decorator. The number of times to execute the decorated function could then be given as an argument.</p>
<p>This would allow you to do something like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@repeat(num_times=4)</span><br><span class="line">def greet(name):</span><br><span class="line">    print(f&quot;Hello &#123;name&#125;&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; greet(&quot;World&quot;)</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p>Think about how you could achieve this.</p>
<p>So far, the name written after the @ has referred to a function object that can be called with another function. To be consistent, you then need repeat(num_times&#x3D;4) to return a function object that can act as a decorator. Luckily, you already know how to return functions! In general, you want something like the following:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def repeat(num_times):</span><br><span class="line">    def decorator_repeat(func):</span><br><span class="line">        ...  # Create and return a wrapper function</span><br><span class="line">    return decorator_repeat</span><br></pre></td></tr></table></figure>
<p>Typically, the decorator creates and returns an inner wrapper function, so writing the example out in full will give you an inner function within an inner function. While this might sound like the programming equivalent of the Inception movie, we’ll untangle it all in a moment:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def repeat(num_times):</span><br><span class="line">    def decorator_repeat(func):</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper_repeat(*args, **kwargs):</span><br><span class="line">            for _ in range(num_times):</span><br><span class="line">                value = func(*args, **kwargs)</span><br><span class="line">            return value</span><br><span class="line">        return wrapper_repeat</span><br><span class="line">    return decorator_repeat</span><br></pre></td></tr></table></figure>

<p>It looks a little messy, but we have only put the same decorator pattern you have seen many times by now inside one additional def that handles the arguments to the decorator. Let’s start with the innermost function:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def wrapper_repeat(*args, **kwargs):</span><br><span class="line">    for _ in range(num_times):</span><br><span class="line">        value = func(*args, **kwargs)</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure>
<p>This wrapper_repeat() function takes arbitrary arguments and returns the value of the decorated function, func(). This wrapper function also contains the loop that calls the decorated function num_times times. This is no different from the earlier wrapper functions you have seen, except that it is using the num_times parameter that must be supplied from the outside.</p>
<p>One step out, you’ll find the decorator function:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def decorator_repeat(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper_repeat(*args, **kwargs):</span><br><span class="line">        ...</span><br><span class="line">    return wrapper_repeat</span><br></pre></td></tr></table></figure>
<p>Again, decorator_repeat() looks exactly like the decorator functions you have written earlier, except that it’s named differently. That’s because we reserve the base name—repeat()—for the outermost function, which is the one the user will call.</p>
<p>As you have already seen, the outermost function returns a reference to the decorator function:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def repeat(num_times):</span><br><span class="line">    def decorator_repeat(func):</span><br><span class="line">        ...</span><br><span class="line">    return decorator_repeat</span><br></pre></td></tr></table></figure>
<p>There are a few subtle things happening in the repeat() function:</p>
<p>Defining decorator_repeat() as an inner function means that repeat() will refer to a function object—decorator_repeat. Earlier, we used repeat without parentheses to refer to the function object. The added parentheses are necessary when defining decorators that take arguments.<br>The num_times argument is seemingly not used in repeat() itself. But by passing num_times a closure is created where the value of num_times is stored until it will be used later by wrapper_repeat().<br>With everything set up, let’s see if the results are as expected:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@repeat(num_times=4)</span><br><span class="line">def greet(name):</span><br><span class="line">    print(f&quot;Hello &#123;name&#125;&quot;)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; greet(&quot;World&quot;)</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line">Just the result we were aiming for.</span><br></pre></td></tr></table></figure>


<p>Both Please, But Never Mind the Bread<br>With a little bit of care, you can also define decorators that can be used both with and without arguments. Most likely, you don’t need this, but it is nice to have the flexibility.</p>
<p>As you saw in the previous section, when a decorator uses arguments, you need to add an extra outer function. The challenge is for your code to figure out if the decorator has been called with or without arguments.</p>
<p>Since the function to decorate is only passed in directly if the decorator is called without arguments, the function must be an optional argument. This means that the decorator arguments must all be specified by keyword. You can enforce this with the special * syntax, which means that all following parameters are keyword-only:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def name(_func=None, *, kw1=val1, kw2=val2, ...):  # 1</span><br><span class="line">    def decorator_name(func):</span><br><span class="line">        ...  # Create and return a wrapper function.</span><br><span class="line"></span><br><span class="line">    if _func is None:</span><br><span class="line">        return decorator_name                      # 2</span><br><span class="line">    else:</span><br><span class="line">        return decorator_name(_func)               # 3</span><br></pre></td></tr></table></figure>

<p>Here, the _func argument acts as a marker, noting whether the decorator has been called with arguments or not:</p>
<p>If name has been called without arguments, the decorated function will be passed in as _func. If it has been called with arguments, then _func will be None, and some of the keyword arguments may have been changed from their default values. The * in the argument list means that the remaining arguments can’t be called as positional arguments.<br>In this case, the decorator was called with arguments. Return a decorator function that can read and return a function.<br>In this case, the decorator was called without arguments. Apply the decorator to the function immediately.<br>Using this boilerplate on the @repeat decorator in the previous section, you can write the following:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def repeat(_func=None, *, num_times=2):</span><br><span class="line">    def decorator_repeat(func):</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper_repeat(*args, **kwargs):</span><br><span class="line">            for _ in range(num_times):</span><br><span class="line">                value = func(*args, **kwargs)</span><br><span class="line">            return value</span><br><span class="line">        return wrapper_repeat</span><br><span class="line"></span><br><span class="line">    if _func is None:</span><br><span class="line">        return decorator_repeat</span><br><span class="line">    else:</span><br><span class="line">        return decorator_repeat(_func)</span><br></pre></td></tr></table></figure>

<p>Compare this with the original @repeat. The only changes are the added _func parameter and the if-else at the end.</p>
<p>Recipe 9.6 of the excellent Python Cookbook shows an alternative solution using functools.partial().</p>
<p>These examples show that @repeat can now be used with or without arguments:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@repeat</span><br><span class="line">def say_whee():</span><br><span class="line">    print(&quot;Whee!&quot;)</span><br><span class="line"></span><br><span class="line">@repeat(num_times=3)</span><br><span class="line">def greet(name):</span><br><span class="line">    print(f&quot;Hello &#123;name&#125;&quot;)</span><br></pre></td></tr></table></figure>
<p>Recall that the default value of num_times is 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; say_whee()</span><br><span class="line">Whee!</span><br><span class="line">Whee!</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; greet(&quot;Penny&quot;)</span><br><span class="line">Hello Penny</span><br><span class="line">Hello Penny</span><br><span class="line">Hello Penny</span><br></pre></td></tr></table></figure>


<p>Stateful Decorators</p>
<p>Sometimes, it’s useful to have a decorator that can keep track of state. As a simple example, we will create a decorator that counts the number of times a function is called.</p>
<p>Note: In the beginning of this guide, we talked about pure functions returning a value based on given arguments. Stateful decorators are quite the opposite, where the return value will depend on the current state, as well as the given arguments.</p>
<p>In the next section, you will see how to use classes to keep state. But in simple cases, you can also get away with using function attributes:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def count_calls(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper_count_calls(*args, **kwargs):</span><br><span class="line">        wrapper_count_calls.num_calls += 1</span><br><span class="line">        print(f&quot;Call &#123;wrapper_count_calls.num_calls&#125; of &#123;func.__name__!r&#125;&quot;)</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line">    wrapper_count_calls.num_calls = 0</span><br><span class="line">    return wrapper_count_calls</span><br><span class="line"></span><br><span class="line">@count_calls</span><br><span class="line">def say_whee():</span><br><span class="line">    print(&quot;Whee!&quot;)</span><br></pre></td></tr></table></figure>

<p>The state—the number of calls to the function—is stored in the function attribute .num_calls on the wrapper function. Here is the effect of using it:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; say_whee()</span><br><span class="line">Call 1 of &#x27;say_whee&#x27;</span><br><span class="line">Whee!</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; say_whee()</span><br><span class="line">Call 2 of &#x27;say_whee&#x27;</span><br><span class="line">Whee!</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; say_whee.num_calls</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="Classes-as-Decorators"><a href="#Classes-as-Decorators" class="headerlink" title="Classes as Decorators"></a>Classes as Decorators</h2><p>The typical way to maintain state is by using classes. In this section, you’ll see how to rewrite the @count_calls example from the previous section using a class as a decorator.</p>
<p>Recall that the decorator syntax @my_decorator is just an easier way of saying func &#x3D; my_decorator(func). Therefore, if my_decorator is a class, it needs to take func as an argument in its .<strong>init</strong>() method. Furthermore, the class needs to be callable so that it can stand in for the decorated function.</p>
<p>For a class to be callable, you implement the special .<strong>call</strong>() method:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Counter:</span><br><span class="line">    def __init__(self, start=0):</span><br><span class="line">        self.count = start</span><br><span class="line"></span><br><span class="line">    def __call__(self):</span><br><span class="line">        self.count += 1</span><br><span class="line">        print(f&quot;Current count is &#123;self.count&#125;&quot;)</span><br></pre></td></tr></table></figure>
<p>The .<strong>call</strong>() method is executed each time you try to call an instance of the class:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; counter = Counter()</span><br><span class="line">&gt;&gt;&gt; counter()</span><br><span class="line">Current count is 1</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; counter()</span><br><span class="line">Current count is 2</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; counter.count</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>Therefore, a typical implementation of a decorator class needs to implement .<strong>init</strong>() and .<strong>call</strong>():</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">class CountCalls:</span><br><span class="line">    def __init__(self, func):</span><br><span class="line">        functools.update_wrapper(self, func)</span><br><span class="line">        self.func = func</span><br><span class="line">        self.num_calls = 0</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        self.num_calls += 1</span><br><span class="line">        print(f&quot;Call &#123;self.num_calls&#125; of &#123;self.func.__name__!r&#125;&quot;)</span><br><span class="line">        return self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">@CountCalls</span><br><span class="line">def say_whee():</span><br><span class="line">    print(&quot;Whee!&quot;)</span><br><span class="line">```    </span><br><span class="line">The .__init__() method must store a reference to the function and can do any other necessary initialization. The .__call__() method will be called instead of the decorated function. It does essentially the same thing as the wrapper() function in our earlier examples. Note that you need to use the functools.update_wrapper() function instead of @functools.wraps.</span><br><span class="line"></span><br><span class="line">This @CountCalls decorator works the same as the one in the previous section:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>say_whee()<br>Call 1 of ‘say_whee’<br>Whee!</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>say_whee()<br>Call 2 of ‘say_whee’<br>Whee!</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>say_whee.num_calls<br>2</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## More Real World Examples</span><br><span class="line">We’ve come a far way now, having figured out how to create all kinds of decorators. Let’s wrap it up, putting our newfound knowledge into creating a few more examples that might actually be useful in the real world.</span><br><span class="line"></span><br><span class="line">Slowing Down Code, Revisited</span><br><span class="line">As noted earlier, our previous implementation of @slow_down always sleeps for one second. Now you know how to add parameters to decorators, so let’s rewrite @slow_down using an optional rate argument that controls how long it sleeps:</span><br></pre></td></tr></table></figure>
<p>import functools<br>import time</p>
<p>def slow_down(_func&#x3D;None, *, rate&#x3D;1):<br>    “””Sleep given amount of seconds before calling the function”””<br>    def decorator_slow_down(func):<br>        @functools.wraps(func)<br>        def wrapper_slow_down(*args, **kwargs):<br>            time.sleep(rate)<br>            return func(*args, **kwargs)<br>        return wrapper_slow_down</p>
<pre><code>if _func is None:
    return decorator_slow_down
else:
    return decorator_slow_down(_func)
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We’re using the boilerplate introduced in the Both Please, But Never Mind the Bread section to make @slow_down callable both with and without arguments. The same recursive countdown() function as earlier now sleeps two seconds between each count:</span><br></pre></td></tr></table></figure>
<p>@slow_down(rate&#x3D;2)<br>def countdown(from_number):<br>    if from_number &lt; 1:<br>        print(“Liftoff!”)<br>    else:<br>        print(from_number)<br>        countdown(from_number - 1)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">As before, you must run the example yourself to see the effect of the decorator:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>countdown(3)<br>3<br>2<br>1<br>Liftoff!</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">Creating Singletons</span><br><span class="line">A singleton is a class with only one instance. There are several singletons in Python that you use frequently, including None, True, and False. It is the fact that None is a singleton that allows you to compare for None using the is keyword, like you saw in the Both Please section:</span><br></pre></td></tr></table></figure>
<p>if _func is None:<br>    return decorator_name<br>else:<br>    return decorator_name(_func)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Using is returns True only for objects that are the exact same instance. The following @singleton decorator turns a class into a singleton by storing the first instance of the class as an attribute. Later attempts at creating an instance simply return the stored instance:</span><br></pre></td></tr></table></figure>
<p>import functools</p>
<p>def singleton(cls):<br>    “””Make a class a Singleton class (only one instance)”””<br>    @functools.wraps(cls)<br>    def wrapper_singleton(*args, **kwargs):<br>        if not wrapper_singleton.instance:<br>            wrapper_singleton.instance &#x3D; cls(*args, **kwargs)<br>        return wrapper_singleton.instance<br>    wrapper_singleton.instance &#x3D; None<br>    return wrapper_singleton</p>
<p>@singleton<br>class TheOne:<br>    pass</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">As you see, this class decorator follows the same template as our function decorators. The only difference is that we are using cls instead of func as the parameter name to indicate that it is meant to be a class decorator.</span><br><span class="line"></span><br><span class="line">Let’s see if it works:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>first_one &#x3D; TheOne()<br>another_one &#x3D; TheOne()</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>id(first_one)<br>140094218762280</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>id(another_one)<br>140094218762280</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>first_one is another_one<br>True</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">It seems clear that first_one is indeed the exact same instance as another_one.</span><br><span class="line"></span><br><span class="line">Note: Singleton classes are not really used as often in Python as in other languages. The effect of a singleton is usually better implemented as a global variable in a module.</span><br><span class="line"></span><br><span class="line">Caching Return Values</span><br><span class="line">Decorators can provide a nice mechanism for caching and memoization. As an example, let’s look at a recursive definition of the Fibonacci sequence:</span><br></pre></td></tr></table></figure>
<p>from decorators import count_calls</p>
<p>@count_calls<br>def fibonacci(num):<br>    if num &lt; 2:<br>        return num<br>    return fibonacci(num - 1) + fibonacci(num - 2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">While the implementation is simple, its runtime performance is terrible:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>fibonacci(10)<br><Lots of output from count_calls><br>55</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>fibonacci.num_calls<br>177</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">To calculate the tenth Fibonacci number, you should really only need to calculate the preceding Fibonacci numbers, but this implementation somehow needs a whopping 177 calculations. It gets worse quickly: 21891 calculations are needed for fibonacci(20) and almost 2.7 million calculations for the 30th number. This is because the code keeps recalculating Fibonacci numbers that are already known.</span><br><span class="line"></span><br><span class="line">The usual solution is to implement Fibonacci numbers using a for loop and a lookup table. However, simple caching of the calculations will also do the trick:</span><br></pre></td></tr></table></figure>
<p>import functools<br>from decorators import count_calls</p>
<p>def cache(func):<br>    “””Keep a cache of previous function calls”””<br>    @functools.wraps(func)<br>    def wrapper_cache(*args, **kwargs):<br>        cache_key &#x3D; args + tuple(kwargs.items())<br>        if cache_key not in wrapper_cache.cache:<br>            wrapper_cache.cache[cache_key] &#x3D; func(*args, **kwargs)<br>        return wrapper_cache.cache[cache_key]<br>    wrapper_cache.cache &#x3D; dict()<br>    return wrapper_cache</p>
<p>@cache<br>@count_calls<br>def fibonacci(num):<br>    if num &lt; 2:<br>        return num<br>    return fibonacci(num - 1) + fibonacci(num - 2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The cache works as a lookup table, so now fibonacci() only does the necessary calculations once:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>fibonacci(10)<br>Call 1 of ‘fibonacci’<br>…<br>Call 11 of ‘fibonacci’<br>55</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>fibonacci(8)<br>21</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Note that in the final call to fibonacci(8), no new calculations were needed, since the eighth Fibonacci number had already been calculated for fibonacci(10).</span><br><span class="line"></span><br><span class="line">In the standard library, a Least Recently Used (LRU) cache is available as @functools.lru_cache.</span><br><span class="line"></span><br><span class="line">This decorator has more features than the one you saw above. You should use @functools.lru_cache instead of writing your own cache decorator:</span><br></pre></td></tr></table></figure>
<p>import functools</p>
<p>@functools.lru_cache(maxsize&#x3D;4)<br>def fibonacci(num):<br>    print(f”Calculating fibonacci({num})”)<br>    if num &lt; 2:<br>        return num<br>    return fibonacci(num - 1) + fibonacci(num - 2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The maxsize parameter specifies how many recent calls are cached. The default value is 128, but you can specify maxsize=None to cache all function calls. However, be aware that this can cause memory problems if you are caching many large objects.</span><br><span class="line"></span><br><span class="line">You can use the .cache_info() method to see how the cache performs, and you can tune it if needed. In our example, we used an artificially small maxsize to see the effect of elements being removed from the cache:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>fibonacci(10)<br>Calculating fibonacci(10)<br>Calculating fibonacci(9)<br>Calculating fibonacci(8)<br>Calculating fibonacci(7)<br>Calculating fibonacci(6)<br>Calculating fibonacci(5)<br>Calculating fibonacci(4)<br>Calculating fibonacci(3)<br>Calculating fibonacci(2)<br>Calculating fibonacci(1)<br>Calculating fibonacci(0)<br>55</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>fibonacci(8)<br>21</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>fibonacci(5)<br>Calculating fibonacci(5)<br>Calculating fibonacci(4)<br>Calculating fibonacci(3)<br>Calculating fibonacci(2)<br>Calculating fibonacci(1)<br>Calculating fibonacci(0)<br>5</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>fibonacci(8)<br>Calculating fibonacci(8)<br>Calculating fibonacci(7)<br>Calculating fibonacci(6)<br>21</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>fibonacci(5)<br>5</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>fibonacci.cache_info()<br>CacheInfo(hits&#x3D;17, misses&#x3D;20, maxsize&#x3D;4, currsize&#x3D;4)</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Adding Information About Units</span><br><span class="line">The following example is somewhat similar to the Registering Plugins example from earlier, in that it does not really change the behavior of the decorated function. Instead, it simply adds unit as a function attribute:</span><br></pre></td></tr></table></figure>
<p>def set_unit(unit):<br>    “””Register a unit on a function”””<br>    def decorator_set_unit(func):<br>        func.unit &#x3D; unit<br>        return func<br>    return decorator_set_unit</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">The following example calculates the volume of a cylinder based on its radius and height in centimeters:</span><br></pre></td></tr></table></figure>
<p>import math</p>
<p>@set_unit(“cm^3”)<br>def volume(radius, height):<br>    return math.pi * radius**2 * height</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This .unit function attribute can later be accessed when needed:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>volume(3, 5)<br>141.3716694115407</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>volume.unit<br>‘cm^3’</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Note that you could have achieved something similar using function annotations:</span><br></pre></td></tr></table></figure>
<p>import math</p>
<p>def volume(radius, height) -&gt; “cm^3”:<br>    return math.pi * radius**2 * height</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">However, since annotations are used for type hints, it would be hard to combine such units as annotations with static type checking.</span><br><span class="line"></span><br><span class="line">Units become even more powerful and fun when connected with a library that can convert between units. One such library is pint. With pint installed (pip install Pint), you can for instance convert the volume to cubic inches or gallons:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>import pint<br>ureg &#x3D; pint.UnitRegistry()<br>vol &#x3D; volume(3, 5) * ureg(volume.unit)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>vol<br>&lt;Quantity(141.3716694115407, ‘centimeter ** 3’)&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>vol.to(“cubic inches”)<br>&lt;Quantity(8.627028576414954, ‘inch ** 3’)&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>vol.to(“gallons”).m  # Magnitude<br>0.0373464440537444</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">You could also modify the decorator to return a pint Quantity directly. Such a Quantity is made by multiplying a value with the unit. In pint, units must be looked up in a UnitRegistry. The registry is stored as a function attribute to avoid cluttering the namespace:</span><br></pre></td></tr></table></figure>
<p>def use_unit(unit):<br>    “””Have a function return a Quantity with given unit”””<br>    use_unit.ureg &#x3D; pint.UnitRegistry()<br>    def decorator_use_unit(func):<br>        @functools.wraps(func)<br>        def wrapper_use_unit(*args, **kwargs):<br>            value &#x3D; func(*args, **kwargs)<br>            return value * use_unit.ureg(unit)<br>        return wrapper_use_unit<br>    return decorator_use_unit</p>
<p>@use_unit(“meters per second”)<br>def average_speed(distance, duration):<br>    return distance &#x2F; duration</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">With the @use_unit decorator, converting units is practically effortless:</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>bolt &#x3D; average_speed(100, 9.58)<br>bolt<br>&lt;Quantity(10.438413361169102, ‘meter &#x2F; second’)&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>bolt.to(“km per hour”)<br>&lt;Quantity(37.578288100208766, ‘kilometer &#x2F; hour’)&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>bolt.to(“mph”).m  # Magnitude<br>23.350065679064745</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Validating JSON</span><br><span class="line">Let’s look at one last use case. Take a quick look at the following Flask route handler:</span><br></pre></td></tr></table></figure>
<p>@app.route(“&#x2F;grade”, methods&#x3D;[“POST”])<br>def update_grade():<br>    json_data &#x3D; request.get_json()<br>    if “student_id” not in json_data:<br>        abort(400)<br>    # Update database<br>    return “success!”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here we ensure that the key student_id is part of the request. Although this validation works, it really does not belong in the function itself. Plus, perhaps there are other routes that use the exact same validation. So, let’s keep it DRY and abstract out any unnecessary logic with a decorator. The following @validate_json decorator will do the job:</span><br></pre></td></tr></table></figure>
<p>from flask import Flask, request, abort<br>import functools<br>app &#x3D; Flask(<strong>name</strong>)</p>
<p>def validate_json(*expected_args):                  # 1<br>    def decorator_validate_json(func):<br>        @functools.wraps(func)<br>        def wrapper_validate_json(*args, **kwargs):<br>            json_object &#x3D; request.get_json()<br>            for expected_arg in expected_args:      # 2<br>                if expected_arg not in json_object:<br>                    abort(400)<br>            return func(*args, **kwargs)<br>        return wrapper_validate_json<br>    return decorator_validate_json</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In the above code, the decorator takes a variable length list as an argument so that we can pass in as many string arguments as necessary, each representing a key used to validate the JSON data:</span><br><span class="line"></span><br><span class="line">The list of keys that must be present in the JSON is given as arguments to the decorator.</span><br><span class="line">The wrapper function validates that each expected key is present in the JSON data.</span><br><span class="line">The route handler can then focus on its real job—updating grades—as it can safely assume that JSON data are valid:</span><br></pre></td></tr></table></figure>
<p>@app.route(“&#x2F;grade”, methods&#x3D;[“POST”])<br>@validate_json(“student_id”)<br>def update_grade():<br>    json_data &#x3D; request.get_json()<br>    # Update database.<br>    return “success!”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Conclusion</span><br><span class="line">This has been quite a journey! You started this tutorial by looking a little closer at functions,</span><br><span class="line"> particularly how they can be defined inside other functions and passed around just like any other Python object. Then</span><br><span class="line">  you learned about decorators and how to write them such that:</span><br><span class="line"></span><br><span class="line">They can be reused.</span><br><span class="line">They can decorate functions with arguments and return values.</span><br><span class="line">They can use @functools.wraps to look more like the decorated function.</span><br><span class="line">In the second part of the tutorial, you saw more advanced decorators and learned how to:</span><br><span class="line"></span><br><span class="line">Decorate classes</span><br><span class="line">Nest decorators</span><br><span class="line">Add arguments to decorators</span><br><span class="line">Keep state within decorators</span><br><span class="line">Use classes as decorators</span><br><span class="line">You saw that, to define a decorator, you typically define a function returning a wrapper function. The wrapper function</span><br><span class="line"> uses *args and **kwargs to pass on arguments to the decorated function. If you want your decorator to also take arguments,</span><br><span class="line">  you need to nest the wrapper function inside another function. In this case, you usually end up with three return statements.</span><br><span class="line"></span><br><span class="line">You can find the code from this tutorial online.</span><br><span class="line"></span><br><span class="line">Further Reading</span><br><span class="line">If you are still looking for more, our book Python Tricks has a section on decorators, as does the Python Cookbook </span><br><span class="line">by David Beazley and Brian K. Jones.</span><br><span class="line"></span><br><span class="line">For a deep dive into the historical discussion on how decorators should be implemented in Python, see PEP 318 as well</span><br><span class="line"> as the Python Decorator Wiki. More examples of decorators can be found in the Python Decorator Library. The decorator</span><br><span class="line">  module can simplify creating your own decorators, and its documentation contains further decorator examples.</span><br><span class="line"></span><br><span class="line">Also, we’ve put together a short &amp; sweet Python decorators cheat sheet for you:</span><br><span class="line"></span><br><span class="line">Decorators Cheat Sheet: Click here to get access to a free 3-page Python decorators cheat sheet that summarizes the </span><br><span class="line">techniques explained in this tutorial.</span><br><span class="line"></span><br><span class="line"> Watch Now This tutorial has a related video course created by the Real Python team. Watch it together with the written </span><br><span class="line"> tutorial to deepen your understanding: Python Decorators 101</span><br><span class="line"></span><br><span class="line">🐍 Python Tricks 💌</span><br><span class="line"></span><br><span class="line">Get a short &amp; sweet Python Trick delivered to your inbox every couple of days. No spam ever. Unsubscribe any time. </span><br><span class="line">Curated by the Real Python team.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">About Geir Arne Hjelle</span><br></pre></td></tr></table></figure>


<p>Geir Arne is an avid Pythonista and a member of the Real Python tutorial team.</p>
<p>More about Geir Arne <a target="_blank" rel="noopener" href="https://realpython.com/team/gahjelle/">https://realpython.com/team/gahjelle/</a><br><a target="_blank" rel="noopener" href="https://github.com/gahjelle">https://github.com/gahjelle</a></p>
<pre><code>




</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://magesfc.github.io">mage</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://magesfc.github.io/mage/428e45833de1d6977f072fa67593f8a21d9a315c/">https://magesfc.github.io/mage/428e45833de1d6977f072fa67593f8a21d9a315c/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://magesfc.github.io" target="_blank">马哥私房菜</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a><a class="post-meta__tags" href="/tags/primer/">primer</a><a class="post-meta__tags" href="/tags/on/">on</a><a class="post-meta__tags" href="/tags/decorators/">decorators</a></div><div class="post_share"><div class="social-share" data-image="https://t.mwm.moe/fj/" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/null" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/mage/a718e01bee375dd72d94fd15211e2e4f41c0a52c/"><img class="prev-cover" src= "/img/loading.gif" data-lazy-src="https://t.mwm.moe/fj/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux学习之bash学习之cookbook技巧</div></div></a></div><div class="next-post pull-right"><a href="/mage/6a323979d022165779db1cbb3367540e235cec9e/"><img class="next-cover" src= "/img/loading.gif" data-lazy-src="https://t.mwm.moe/fj/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux学习之sed学习之cookbook技巧</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/mage/4365346bbe7d22f2241ba92830713b35dfebb981/" title="Python学习之and-or使用技巧"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://t.mwm.moe/fj/" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Python学习之and-or使用技巧</div></div></a></div><div><a href="/mage/a1021b21fe6312615846549c978e5cc8fa7a10d9/" title="Python学习之matplotlib之plot"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://t.mwm.moe/fj/" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Python学习之matplotlib之plot</div></div></a></div><div><a href="/mage/c3129a83ae38feb3fb61a31d9ae128cf5a3e2e73/" title="Python学习之numpy之高斯分布"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://t.mwm.moe/fj/" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Python学习之numpy之高斯分布</div></div></a></div><div><a href="/mage/38a3cc327d9c3efd909b2c1aac95f37bd0181955/" title="Python学习之命令行参数解析之argparse和optparse"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://t.mwm.moe/fj/" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Python学习之命令行参数解析之argparse和optparse</div></div></a></div><div><a href="/mage/5b96c3ed08ce6300577a1a8cd7169200600b4b1d/" title="Python学习之Anaconda学习笔记总结"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://t.mwm.moe/fj/" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Python学习之Anaconda学习笔记总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mage</div><div class="author-info__description"> 这里是 马哥 的个人博客 </div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">216</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">231</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mamh2021"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mamh2021" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Primer-on-Python-Decorators"><span class="toc-number">1.</span> <span class="toc-text">Primer on Python Decorators</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Table-of-Contents"><span class="toc-number">1.1.</span> <span class="toc-text">Table of Contents</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Updates"><span class="toc-number">1.2.</span> <span class="toc-text">Updates:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functions"><span class="toc-number">1.3.</span> <span class="toc-text">Functions</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Apply-a-decorator-to-a-standard-library-function"><span class="toc-number">2.</span> <span class="toc-text">Apply a decorator to a standard library function</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Nesting-Decorators"><span class="toc-number">2.1.</span> <span class="toc-text">Nesting Decorators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Classes-as-Decorators"><span class="toc-number">2.2.</span> <span class="toc-text">Classes as Decorators</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/mage/edbed262a0a32c8f4fd97861532b8e9753584e2b/" title="Docker源码学习之docker-version命令"><img src= "/img/loading.gif" data-lazy-src="https://t.mwm.moe/fj/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker源码学习之docker-version命令"/></a><div class="content"><a class="title" href="/mage/edbed262a0a32c8f4fd97861532b8e9753584e2b/" title="Docker源码学习之docker-version命令">Docker源码学习之docker-version命令</a><time datetime="2023-09-28T00:03:49.000Z" title="更新于 2023-09-28 08:03:49">2023-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/eee219318da0b6a390e2e2d9c27459533c760b0c/" title="Docker源码学习之docker-run命令"><img src= "/img/loading.gif" data-lazy-src="https://t.mwm.moe/fj/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker源码学习之docker-run命令"/></a><div class="content"><a class="title" href="/mage/eee219318da0b6a390e2e2d9c27459533c760b0c/" title="Docker源码学习之docker-run命令">Docker源码学习之docker-run命令</a><time datetime="2023-09-27T23:25:21.000Z" title="更新于 2023-09-28 07:25:21">2023-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/3b60ed21ee8f255c62e0e848435d5648d347b465/" title="Docker源码学习之如何源码编译docker"><img src= "/img/loading.gif" data-lazy-src="https://t.mwm.moe/fj/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker源码学习之如何源码编译docker"/></a><div class="content"><a class="title" href="/mage/3b60ed21ee8f255c62e0e848435d5648d347b465/" title="Docker源码学习之如何源码编译docker">Docker源码学习之如何源码编译docker</a><time datetime="2023-09-27T22:57:30.000Z" title="更新于 2023-09-28 06:57:30">2023-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/b4b2fa67751f76c0312672abefffd8eb6e41c702/" title="Docker源码学习之docker-names-generator"><img src= "/img/loading.gif" data-lazy-src="https://t.mwm.moe/fj/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker源码学习之docker-names-generator"/></a><div class="content"><a class="title" href="/mage/b4b2fa67751f76c0312672abefffd8eb6e41c702/" title="Docker源码学习之docker-names-generator">Docker源码学习之docker-names-generator</a><time datetime="2023-09-27T14:01:38.000Z" title="更新于 2023-09-27 22:01:38">2023-09-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/145f51d0e22fead4fc7b2a02f114a5766064789d/" title="Docker源码学习之容器的随机的名字怎么来的y"><img src= "/img/loading.gif" data-lazy-src="https://t.mwm.moe/fj/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker源码学习之容器的随机的名字怎么来的y"/></a><div class="content"><a class="title" href="/mage/145f51d0e22fead4fc7b2a02f114a5766064789d/" title="Docker源码学习之容器的随机的名字怎么来的y">Docker源码学习之容器的随机的名字怎么来的y</a><time datetime="2023-09-26T14:32:47.000Z" title="更新于 2023-09-26 22:32:47">2023-09-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://t.mwm.moe/fj/')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By mage</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>