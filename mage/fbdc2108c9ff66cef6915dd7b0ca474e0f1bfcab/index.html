<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux学习之awk学习之cookbook技巧 | 马哥私房菜</title><meta name="author" content="mage"><meta name="copyright" content="mage"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="awk学习之cookbook技巧.md Part 1: File Spacing, Numbering and Calculations##1.Line Spacing 1.每行后面都加上一个空行 1awk &amp;#x27;1; &amp;#123; print &quot;&quot; &amp;#125;&amp;#x27;       #  awk 程序包含一系列的 parttern-action（模式-动作）的语句。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux学习之awk学习之cookbook技巧">
<meta property="og:url" content="https://magesfc.github.io/mage/fbdc2108c9ff66cef6915dd7b0ca474e0f1bfcab/">
<meta property="og:site_name" content="马哥私房菜">
<meta property="og:description" content="awk学习之cookbook技巧.md Part 1: File Spacing, Numbering and Calculations##1.Line Spacing 1.每行后面都加上一个空行 1awk &amp;#x27;1; &amp;#123; print &quot;&quot; &amp;#125;&amp;#x27;       #  awk 程序包含一系列的 parttern-action（模式-动作）的语句。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg">
<meta property="article:published_time" content="2022-02-23T09:47:21.000Z">
<meta property="article:modified_time" content="2022-02-23T09:47:21.000Z">
<meta property="article:author" content="mage">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="awk">
<meta property="article:tag" content="cookbook">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg"><link rel="shortcut icon" href="http://www.blackshark.com/favicon.ico"><link rel="canonical" href="https://magesfc.github.io/mage/fbdc2108c9ff66cef6915dd7b0ca474e0f1bfcab/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: mage","link":"链接: ","source":"来源: 马哥私房菜","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux学习之awk学习之cookbook技巧',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-23 17:47:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">.card-announcement .social-button{margin:.6rem 0 0 0;text-align:center}.card-announcement .social-button a{display:block;background-color:var(--btn-bg);color:var(--btn-color);text-align:center;line-height:2.4;margin:4px 0}.card-announcement .social-button a:hover{background-color:var(--btn-hover-color)}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">173</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">194</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 精选文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> 🚀 快速开始</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/dc584b87/"><span> 📑 主题页面</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4aa8abbe/"><span> 🛠 主题配置-1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/ceeb73f/"><span> 🛠 主题配置-2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/98d20436/"><span> ❓ 主题问答</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4073eda/"><span> ⚡️ 进阶教程</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/198a4240/"><span> ✨ 更新日志</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://butterfly.js.org/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> 其他示例</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">马哥私房菜</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 精选文档</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> 🚀 快速开始</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/dc584b87/"><span> 📑 主题页面</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4aa8abbe/"><span> 🛠 主题配置-1</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/ceeb73f/"><span> 🛠 主题配置-2</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/98d20436/"><span> ❓ 主题问答</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/4073eda/"><span> ⚡️ 进阶教程</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/198a4240/"><span> ✨ 更新日志</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://butterfly.js.org/link/"><i class="fa-fw fas fa-thumbs-up"></i><span> 其他示例</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux学习之awk学习之cookbook技巧</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-23T09:47:21.000Z" title="发表于 2022-02-23 17:47:21">2022-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-23T09:47:21.000Z" title="更新于 2022-02-23 17:47:21">2022-02-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/">linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux学习之awk学习之cookbook技巧"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>awk学习之cookbook技巧.md</p>
<h1 id="Part-1-File-Spacing-Numbering-and-Calculations"><a href="#Part-1-File-Spacing-Numbering-and-Calculations" class="headerlink" title="Part 1: File Spacing, Numbering and Calculations"></a>Part 1: File Spacing, Numbering and Calculations</h1><p>##1.Line Spacing</p>
<p>1.每行后面都加上一个空行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;1; &#123; print &quot;&quot; &#125;&#x27;</span>       <span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>awk 程序包含一系列的 parttern-action（模式-动作）的语句。类似这样‘pattern{action}’的结构。<br>这个例子中包含了2个语句，一个是 “1”，另一个是“{print “” }”，模式和动作都可以省略的其中一个的。<br>如果模式省略了，默认是对所有的输入内容按行来出来的。如果是动作省略的默认是“{print }”。</p>
<p>注意awk程序是面向行的。</p>
<p>上面的等同于下面这个程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;1 &#123; print &#125; &#123; print &quot;&quot; &#125;&#x27;</span>     <span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>动作只有在模式匹配的情况下才执行。这里例子中的模式是“1”，这个模式总是true，也就是每一行都会匹配，<br>每一行也都会执行动作的。所以也等价于下面的代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; print &#125; &#123; print &quot;&quot; &#125;&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>awk的print语句总是会在最后打印一个ORS（output record separator）变量的，这个值模式是换行，<br>也就是\n  #<br>这里例子中的第一个print语句后面没有接任何参数，所有默认等于<code>print $0</code>，也就是打印整行内容，<br>$0代表的是整行内容。    #<br>例子中的第二个print 打印一个空字符串，也是上面都不输出，打上print会在最后加上一个换行，所以呢<br>这里就打印出来了一个空行了。#</p>
<p>2.另外一个给每行后面加上空行的技巧</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123; ORS=&quot;\n\n&quot; &#125;; 1&#x27;</span> <span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>BEGIN是一个特殊的模式，表示在读取内容之前无条件执行后面的动作。<br>这个技巧中是在动作语句中对ORS变量重新赋值了，将一个换行变成两个换行了。<br>后面 的1 等价于 {print} ，这样就达到了每行后面都加上新的空行的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN &#123; ORS=&quot;\n\n&quot; &#125;; 1&#x27; /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line"></span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line"></span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.在每个非空的行后面添加空行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;NF &#123; print $0 &quot;\n&quot; &#125;&#x27;</span> <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">这个技巧用到了awk中的另外一个特殊变量NF（number of fields）。这个表示每行被awk分割为多少个字段，</span><br><span class="line">也就是多少列，默认是安装空格分割的。例如“this is a <span class="built_in">test</span>”这行会被分割为4个字段。</span><br><span class="line">如果是空行，是不会分割的，也就是NF的值是0。<span class="comment">#</span></span><br><span class="line">这里使用NF作为模式，只有NF值大于0条件才是真，后面的动作才执行。 </span><br><span class="line">后面的动作是<span class="built_in">print</span> <span class="variable">$0</span>，也就是打印整行内容，<span class="built_in">print</span>第二个参数是个换行，也就是后面加个新的空行。</span><br><span class="line"></span><br><span class="line">4、在每行后添加两个空行</span><br><span class="line">```bash</span><br><span class="line">awk <span class="string">&#x27;1; &#123; print &quot;\n&quot; &#125;&#x27;</span> <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1是等于{print}的，所以上面的可以等价于下面这个  #</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; print; print &quot;\n&quot; &#125;&#x27;</span>  <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先是打印一整行内容，然后再打印一个换行。 #</p>
<p>##2.Numbering and Calculations</p>
<p>5、为每个文件的内容添加行号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; print FNR &quot;\t&quot; $0 &#125;&#x27;</span> <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这则技巧是在没一行的开头加上FNR（file line number行号）然后是一个\t（ tab键），最后是整行内容。<br>FNR变量记录了当前的行号。FNR会每次重置为0的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;&#123; print FNR &quot;\t&quot; $0 &#125;&#x27;</span> ffmpeg.sh  </span><br><span class="line">1	<span class="comment">#!/bin/bash #</span></span><br><span class="line">2	</span><br><span class="line">3	INPUT_FILE=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">4	ffmpeg -y -i <span class="string">&quot;<span class="variable">$INPUT_FILE</span>&quot;</span> -vf drawtext=<span class="string">&quot;fontfile=fonts/simsun.ttc: text=&#x27;欢迎光临 马哥的店&lt;马哥私房菜&gt; 地址是：shop592330910.taobao.com&#x27;:fontcolor=red:fontsize=40:box=1:boxcolor=black@0:x=if(eq(mod(t\,3)\,0)\,rand(0\,(w-text_w))\,x):y=h-text_h&quot;</span> -codec:a copy <span class="string">&quot;new.<span class="variable">$&#123;INPUT_FILE&#125;</span>&quot;</span></span><br><span class="line">$ </span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">6、为所有文件的所有行统一添加行号</span><br><span class="line">```bash</span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; print NR &quot;\t&quot; $0 &#125;&#x27;</span>      <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个和上面的那个例子类似，只是这里使用NR（line number）变量了，这个不会重置为0的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ awk <span class="string">&#x27;&#123; print FNR &quot;\t&quot; $0 &#125;&#x27;</span> ffmpeg.sh ffmpeg.sh                                                                                                           </span><br><span class="line">1	<span class="comment">#!/bin/bash  #</span></span><br><span class="line">2	</span><br><span class="line">3	INPUT_FILE=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">4	ffmpeg -y -i <span class="string">&quot;<span class="variable">$INPUT_FILE</span>&quot;</span> -vf drawtext=<span class="string">&quot;fontfile=fonts/simsun.ttc: text=&#x27;欢迎光临 马哥的店&lt;马哥私房菜&gt; 地址是：shop592330910.taobao.com&#x27;:fontcolor=red:fontsize=40:box=1:boxcolor=black@0:x=if(eq(mod(t\,3)\,0)\,rand(0\,(w-text_w))\,x):y=h-text_h&quot;</span> -codec:a copy <span class="string">&quot;new.<span class="variable">$&#123;INPUT_FILE&#125;</span>&quot;</span></span><br><span class="line">1	<span class="comment">#!/bin/bash   #</span></span><br><span class="line">2	</span><br><span class="line">3	INPUT_FILE=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">4	ffmpeg -y -i <span class="string">&quot;<span class="variable">$INPUT_FILE</span>&quot;</span> -vf drawtext=<span class="string">&quot;fontfile=fonts/simsun.ttc: text=&#x27;欢迎光临 马哥的店&lt;马哥私房菜&gt; 地址是：shop592330910.taobao.com&#x27;:fontcolor=red:fontsize=40:box=1:boxcolor=black@0:x=if(eq(mod(t\,3)\,0)\,rand(0\,(w-text_w))\,x):y=h-text_h&quot;</span> -codec:a copy <span class="string">&quot;new.<span class="variable">$&#123;INPUT_FILE&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                                                                                                                                            </span><br><span class="line">$ awk <span class="string">&#x27;&#123; print NR &quot;\t&quot; $0 &#125;&#x27;</span> ffmpeg.sh ffmpeg.sh                                                                                                             </span><br><span class="line">1	<span class="comment">#!/bin/bash  #</span></span><br><span class="line">2	</span><br><span class="line">3	INPUT_FILE=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">4	ffmpeg -y -i <span class="string">&quot;<span class="variable">$INPUT_FILE</span>&quot;</span> -vf drawtext=<span class="string">&quot;fontfile=fonts/simsun.ttc: text=&#x27;欢迎光临 马哥的店&lt;马哥私房菜&gt; 地址是：shop592330910.taobao.com&#x27;:fontcolor=red:fontsize=40:box=1:boxcolor=black@0:x=if(eq(mod(t\,3)\,0)\,rand(0\,(w-text_w))\,x):y=h-text_h&quot;</span> -codec:a copy <span class="string">&quot;new.<span class="variable">$&#123;INPUT_FILE&#125;</span>&quot;</span></span><br><span class="line">5	<span class="comment">#!/bin/bash  #</span></span><br><span class="line">6	</span><br><span class="line">7	INPUT_FILE=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">8	ffmpeg -y -i <span class="string">&quot;<span class="variable">$INPUT_FILE</span>&quot;</span> -vf drawtext=<span class="string">&quot;fontfile=fonts/simsun.ttc: text=&#x27;欢迎光临 马哥的店&lt;马哥私房菜&gt; 地址是：shop592330910.taobao.com&#x27;:fontcolor=red:fontsize=40:box=1:boxcolor=black@0:x=if(eq(mod(t\,3)\,0)\,rand(0\,(w-text_w))\,x):y=h-text_h&quot;</span> -codec:a copy <span class="string">&quot;new.<span class="variable">$&#123;INPUT_FILE&#125;</span>&quot;</span></span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到当作用到2个文件来显示行号的时候 FNR是会在第二个文件重置为0 的。<br>NR变量则不会重置为0 的。</p>
<p>7、 格式化行号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; printf(&quot;%5d : %s\n&quot;, NR, $0) &#125;&#x27;</span>  <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个例子使用到了printf 函数，这个类似bash&#x2F;c语言中的printf（）函数。这个函数是不会在每行结尾追加打印ORS，也就是不会打印换行的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ awk <span class="string">&#x27;&#123; printf(&quot;%5d : %s\n&quot;, NR, $0) &#125;&#x27;</span> ffmpeg.sh ffmpeg.sh      <span class="comment">#</span></span><br><span class="line">    1 : <span class="comment">#!/bin/bash #</span></span><br><span class="line">    2 : </span><br><span class="line">    3 : INPUT_FILE=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">    4 : ffmpeg -y -i <span class="string">&quot;<span class="variable">$INPUT_FILE</span>&quot;</span> -vf drawtext=<span class="string">&quot;fontfile=fonts/simsun.ttc: text=&#x27;欢迎光临 马哥的店&lt;马哥私房菜&gt; 地址是：shop592330910.taobao.com&#x27;:fontcolor=red:fontsize=40:box=1:boxcolor=black@0:x=if(eq(mod(t\,3)\,0)\,rand(0\,(w-text_w))\,x):y=h-text_h&quot;</span> -codec:a copy <span class="string">&quot;new.<span class="variable">$&#123;INPUT_FILE&#125;</span>&quot;</span></span><br><span class="line">    5 : <span class="comment">#!/bin/bash #</span></span><br><span class="line">    6 : </span><br><span class="line">    7 : INPUT_FILE=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">    8 : ffmpeg -y -i <span class="string">&quot;<span class="variable">$INPUT_FILE</span>&quot;</span> -vf drawtext=<span class="string">&quot;fontfile=fonts/simsun.ttc: text=&#x27;欢迎光临 马哥的店&lt;马哥私房菜&gt; 地址是：shop592330910.taobao.com&#x27;:fontcolor=red:fontsize=40:box=1:boxcolor=black@0:x=if(eq(mod(t\,3)\,0)\,rand(0\,(w-text_w))\,x):y=h-text_h&quot;</span> -codec:a copy <span class="string">&quot;new.<span class="variable">$&#123;INPUT_FILE&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>8.非空行前面添加行号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;NF &#123; $0=++a &quot; :&quot; $0 &#125;; &#123; print &#125;&#x27;</span> <span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>awk中是可以使用变量的，当然也可以使用自定义的变量，和bash是类似的，不需要先定义在使用，可以直接使用的。<br>之前我们用到的那些个变量都是awk自己定义的。#</p>
<p>这个例子怎么理解呢？<br>首先 这里是2个模式动作语句。第一个是 <code>NF &#123; $0=++a &quot; :&quot; $0 &#125;</code> ，第二个是<code>&#123; print &#125;</code><br>第一个里面 ++a是定义了一个变量a，这里初始就是0（数字零），而不是什么空或者空字符串。<br>为啥是数字也是因为这个++操作符是作用到数字上面的。#<br>然后执行++操作（类似c语言里面的前置++）a第一次执行就会变为1了。<br>什么时候第一次执行呢也就是第一个不是空行的时候才是首次执行。因为NF模式匹配非空行。上面有个例子讲过。</p>
<p>然后是<code> ++a  “ ：” $0</code> 这3个值按照字符串拼接那样拼接起来，然后一起重新复制给变量$0了，$0表示整行内容，<br>这里就实现了给非空行重新设置行号的目的了。注意拼接字符串不能使用加号，加号只能作用到数字上面。</p>
<p>第一个模式动作语句是不打印内容的。#</p>
<p>然后是第二个模式动作语句，里面只有一个print，默认就是打印$0，默认就是打印整行内容。<br>这里不管是空行，还是非空行都统统的打印出来，非空行因为是之前在第一个模式动作中重新被<br>赋值了，这里也就实现了打印非空行行号的目的了。#</p>
<p>同时我们可以看到这个awk程序作用到2个文件的时候，变量a是不会被重置的。#</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ awk <span class="string">&#x27;NF &#123; $0=++a &quot; :&quot; $0 &#125;; &#123; print &#125;&#x27;</span> ffmpeg.sh ffmpeg.sh     <span class="comment">#</span></span><br><span class="line">1 :<span class="comment">#!/bin/bash #</span></span><br><span class="line"></span><br><span class="line">2 :INPUT_FILE=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">3 :ffmpeg -y -i <span class="string">&quot;<span class="variable">$INPUT_FILE</span>&quot;</span> -vf drawtext=<span class="string">&quot;fontfile=fonts/simsun.ttc: text=&#x27;欢迎光临 马哥的店&lt;马哥私房菜&gt; 地址是：shop592330910.taobao.com&#x27;:fontcolor=red:fontsize=40:box=1:boxcolor=black@0:x=if(eq(mod(t\,3)\,0)\,rand(0\,(w-text_w))\,x):y=h-text_h&quot;</span> -codec:a copy <span class="string">&quot;new.<span class="variable">$&#123;INPUT_FILE&#125;</span>&quot;</span></span><br><span class="line">4 :<span class="comment">#!/bin/bash #</span></span><br><span class="line"></span><br><span class="line">5 :INPUT_FILE=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">6 :ffmpeg -y -i <span class="string">&quot;<span class="variable">$INPUT_FILE</span>&quot;</span> -vf drawtext=<span class="string">&quot;fontfile=fonts/simsun.ttc: text=&#x27;欢迎光临 马哥的店&lt;马哥私房菜&gt; 地址是：shop592330910.taobao.com&#x27;:fontcolor=red:fontsize=40:box=1:boxcolor=black@0:x=if(eq(mod(t\,3)\,0)\,rand(0\,(w-text_w))\,x):y=h-text_h&quot;</span> -codec:a copy <span class="string">&quot;new.<span class="variable">$&#123;INPUT_FILE&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>9.计算文件行数（模拟 wc -l 命令）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;END &#123; print NR &#125;&#x27;</span>  <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里又用到了一个特殊的模式END，这个表示所有行处理完，最后在执行这个模式后面的动作。<br>这个例子就是打印NR的值，也就是最终的行数。 #</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;END &#123; print NR &#125;&#x27;</span> ffmpeg.sh  <span class="comment">#</span></span><br><span class="line">11</span><br><span class="line"></span><br><span class="line">$ awk <span class="string">&#x27;END &#123; print NR &#125;&#x27;</span> ffmpeg.sh ffmpeg.sh ffmpeg.sh     <span class="comment">#</span></span><br><span class="line">33</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>10、对每行的所有的列求和</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; s = 0; for (i = 1; i &lt;= NF; i++) s = s+$i; print s &#125;&#x27;</span>  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或分开多行书写：</span></span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123;  #</span></span><br><span class="line"><span class="string">s = 0; </span></span><br><span class="line"><span class="string">for (i = 1; i &lt;= NF; i++) </span></span><br><span class="line"><span class="string">    s = s+$i; </span></span><br><span class="line"><span class="string">print s </span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个例子使用到了awk编程中的for循环，这个和c语言的for循环类似。<br>这个例子是把每行的所有列都加到一起 复制给变量s，然后打印总和。<br>每次计算一行的总和，然后就输出。而不是把所有行加起来。下面例子11才是把所有行加起来的。<br>特别注意这里是<code>s + $i</code> ，要特别注意那个美元符，这里是需要美元符号的，有<br>美元符号表示的列的值，没有的表示的循环变量 i的值，i的值会是1,2,3,4,5,6等。但是列的值可不一定是这样的。</p>
<p>下面我们看执行结果，直接复制代码执行后面不跟文件，会停留等待用户输入，这个时候你可以输入一行数字，<br>每个数字可以空格分割，每输入一行（按完回车键）就会执行一次计算，然后打印。<br>结束输入可以按ctrl+D键。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ awk <span class="string">&#x27;&#123;  #</span></span><br><span class="line"><span class="string">s = 0;</span></span><br><span class="line"><span class="string">for (i = 1; i &lt;= NF; i++)</span></span><br><span class="line"><span class="string">    s = s+$i;</span></span><br><span class="line"><span class="string">print s</span></span><br><span class="line"><span class="string">&#125;&#x27;</span>          </span><br><span class="line">1 2 3 4 5              <span class="comment"># 这行是输入内容</span></span><br><span class="line">15</span><br><span class="line">1 2 3 4 5 6 7 8 9 10   <span class="comment"># 这行是输入内容</span></span><br><span class="line">55</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>11.对所有的行所有的列求和</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; for (i = 1; i &lt;= NF; i++) s = s+$i &#125;; END &#123; print s+0 &#125;&#x27;</span>  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或分开多行书写： #</span></span><br><span class="line">awk <span class="string">&#x27;&#123; </span></span><br><span class="line"><span class="string">for (i = 1; i &lt;= NF; i++) </span></span><br><span class="line"><span class="string">    s = s+$i </span></span><br><span class="line"><span class="string">&#125;; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">END &#123; print s+0 &#125;&#x27;</span> <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意这个例子11和例子10的区别，例子10 有个 s &#x3D; 0的语句，使得每次计算新的一行都会重新初始化为0.<br>这个例子与上一个基本一致，除了输出的是所有行所有字段的和。由于变量会被自动定义，s只需要定义一次，<br>故而不需要把s定义成0。另外需要注意的是，最后在END模式里面它输出{print s+0}而非{print s}，<br>这是因为如果文件为空，s不会被定义就不会有任何输出了，输出s+0可以保证在这种情况下也会输出更有意义的0。<br>或者我们可以写一个BEGIN{s &#x3D; 0 }，来一个s初始值的设置。这样最后可以不用打印s + 0啦。</p>
<p>下面我们看执行结果，直接复制代码执行后面不跟文件，会停留等待用户输入，这个时候你可以输入一行数字，<br>每个数字可以空格分割，每输入一行就会执行一次计算&#x2F;或打印，这个例子是最后才打印结果。<br>结束输入可以按ctrl+D键。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ awk <span class="string">&#x27;&#123;    #</span></span><br><span class="line"><span class="string">for (i = 1; i &lt;= NF; i++)</span></span><br><span class="line"><span class="string">    s = s+$i</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">END &#123; print s &#125;&#x27;</span> <span class="comment"># </span></span><br><span class="line">1 2 3 4 5 6  <span class="comment"># 这行是输入内容</span></span><br><span class="line">21</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ awk <span class="string">&#x27;&#123;   #</span></span><br><span class="line"><span class="string">for (i = 1; i &lt;= NF; i++)</span></span><br><span class="line"><span class="string">    s = s+$i</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">END &#123; print s &#125;&#x27;</span> <span class="comment">#</span></span><br><span class="line">10 9 8 7 6      <span class="comment"># 这行是输入内容</span></span><br><span class="line">5 4 3 2 1 0     <span class="comment"># 这行是输入内容</span></span><br><span class="line">-1 -2 -3 -4 -5  <span class="comment"># 这行是输入内容   </span></span><br><span class="line">40</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>12、将所有字段替换为其绝对值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; for (i = 1; i &lt;= NF; i++) if ($i &lt; 0) $i = -$i; print &#125;&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123;     #</span></span><br><span class="line"><span class="string">  for (i = 1; i &lt;= NF; i++) &#123;</span></span><br><span class="line"><span class="string">    if ($i &lt; 0) &#123;</span></span><br><span class="line"><span class="string">      $i = -$i;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  print</span></span><br><span class="line"><span class="string">&#125;&#x27;</span>    <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这条语句用了if语句，和C语言类似。<br>它对每一行检查，检查每个字段的值是否小于0，如果值小于0，则将其改为正数，然后重新赋值给这个字段。<br>字段名可以间接地用变量的形式引用，如i&#x3D;5;$i&#x3D;’hello’会将第5个字段的内容置为hello。</p>
<p>13、计算文件中的总字段（单词）数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; total = total + NF &#125;; END &#123; print total+0 &#125;&#x27;</span> <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个例子是对每行的NF（NF就是字段数，列数，或者说是单词个数）值进行累加，最后打印输出<br>这里最后为什么是<code>print total+0</code> 可以参考例子11的说明。</p>
<p>14、输出含有单词“马哥私房菜”的行的数目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;/马哥私房菜/ &#123; n++ &#125;; END &#123; print n+0 &#125;&#x27;</span> <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个例子含有两个语句。第一句找出匹配&#x2F;马哥私房菜&#x2F;的行，并对变量n进行累加。在&#x2F;…&#x2F;之间的内容为正则表达式，<br>&#x2F;马哥私房菜&#x2F;匹配所有含有“马哥私房菜”的单词。<br>第二句在文件处理完成后输出n的数值。这里用n+0是为了让n为空的情况下输出0而不是一个空行。</p>
<p>15、寻找第一个字段为数字且最大的行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;$1 &gt; max &#123; max=$1; maxline=$0 &#125;; END &#123; print max, maxline &#125;&#x27;</span> <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个例子用变量max记录第一个字段的最大值，并把第一个字段最大的行的内容存在变量maxline中。<br>在循环终止后，输出max和maxline的内容。</p>
<p>注意：如果在数字都为负数的情况下，这个例子就不能用了，下面的是修改过的版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;NR == 1 &#123; max = $1; maxline = $0; next; &#125; $1 &gt; max &#123; max=$1; maxline=$0 &#125;; END &#123; print max, maxline &#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>16、在每一行前添加该行的字段数，并打印</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; print NF &quot;:&quot; $0 &#125; &#x27;</span> <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个例子仅仅是在逐行输出字段数NF，一个冒号，以及该行的内容。</p>
<p>17、输出每行的最后一个字段</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; print $NF &#125;&#x27;</span> <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>awk里面的字段可以用变量的形式引用。这一句输出第NF个字段的内容，而NF就是该行的字段数。</p>
<p>18、打印最后一行的最后一个字段</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; field = $NF &#125;; END &#123; print field &#125;&#x27;</span> <span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>这个例子用field记录最后一个字段的内容，并在循环后输出field的内容。</p>
<p>这里是一个更好的版本。它更常用、更简洁也更高效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;END &#123;print $NF&#125;&#x27;</span> <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>19、输出所有字段数大于4的行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;NF &gt; 4&#x27;</span>         <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;NF &gt; 4&#123;print&#125;&#x27;</span>  <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子省略了要执行的动作。如前所述，省略动作等价于{print}。</p>
<p>20、输出所有最后一个字段大于4的行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;$NF &gt; 4&#x27;</span>  <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个例子用$NF引用最后一个字段，如果它的数值大于4，那么就输出。</p>
<h1 id="Part-2-Text-Conversion-and-Substitution"><a href="#Part-2-Text-Conversion-and-Substitution" class="headerlink" title="Part 2: Text Conversion and Substitution"></a>Part 2: Text Conversion and Substitution</h1><p>##3. Text Conversion and Substitution</p>
<p>21.将Windows&#x2F;dos格式的换行(CRLF)转成Unix格式(LF)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; sub(/\r$/,&quot;&quot;); print &#125;&#x27;</span>      <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这条语句使用了sub(regex,repl,[string])函数。此函数将匹配regex的string替换成repl，<br>如果没有提供string参数，  则$0将会被默认使用。$0的含义在上一篇已经介绍过，代表整行。<br>这句话其实是将行结尾的‘\r’删除，然后打印，print语句会在行后自动添加一个ORS，也就是\n。</p>
<p>22.将Unix格式的换行(LF)换成Windows&#x2F;dos格式(CRLF)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; sub(/$/,&quot;\r&quot;); print &#125;&#x27;</span>   <span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>这个技巧也是使用了sub(regex, repl, [string]) 函数，这个和上面那个刚好是相反的。<br>这次是替换行结尾$替换成\r，也就是CR。然后打印，print语句会在行后自动添加一个ORS，也就是\n。<br>这样就使得每行都以\r\n结尾了。</p>
<p>23.在Windows下，将Unix格式的换行换成Windows&#x2F;dos格式的换行符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk 1           <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这条语句不是在所有情况下都可以用，要视使用的awk版本是不是能识别Unix格式的换行而定。<br>如果能，那么它会读出每个句子，然后输出并用CRLF结束。1其实就是{ print }的简写形式。</p>
<p>24.在Windows下，将Windows&#x2F;dos格式的换行换成unix格式的换行符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gawk -v BINMODE=<span class="string">&quot;w&quot;</span> <span class="string">&#x27;1&#x27;</span>      <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>理论上来说,在DOS系统下面这一行程序应该转换CRLFs 为 LFs。<br>标准的GUN文档中提到：在DOS下，awk(和许多其他文本程序)默认将行尾”\r\n“f翻译为”\n”在input时候，将”\n”翻译为”\r\n”在output时候。<br>一个特别的变量”BINMODE”可以控制这个输出。</p>
<p>我的测试结果显示这个转换并不能完成，所以我认为BINMODE模式并不一定是正确的。所以使用tr更保险一些。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tr</span> -d \r       <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>tr程序可以转换一个设定的字符为另外一个。 使用-d选项是删除所有字符并且不做任何转换。<br>在上面的用法用， ‘\r’ (CR)字符将被删除。 CRLFs 成将会转换为LFs。</p>
<p>25.删除行首的空白字符（空格和制表符）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; sub(/^[ \t]+/, &quot;&quot;); print &#125;&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里也使用了sub函数，他是把’ ^[ \t]+ ‘ 都替换为空，这个正则表达式匹配开头的空格&#x2F;制表符一次或多次。</p>
<p>26.删除行首和行末的空格</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; gsub(/^[ \t]+|[ \t]+$/, &quot;&quot;); print &#125;&#x27;</span>  <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里使用了一个新的函数gsub（），这个是全局替换，就是会替换多次，只要有匹配上就会替换。</p>
<p>如果仅仅是要删除字段间的空格，你可以这样 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; $1=$1; print &#125;&#x27;</span>     <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是条很取巧的语句，看起来是什么也没作，其实不是这样的。<br>awk会在给字段重新赋值的时候对$0重新进行构建，用OFS也就是单个空格分隔所有字段，这样以来所有的多余的空格就消失了。 </p>
<p>28.在每行首加5个空格</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; sub(/^/, &quot;     &quot;); print &#125;&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个很简单，就是使用sub函数把每行的开头^替换为5个空格。这样就达到了行首插入5个空格的效果。</p>
<p>29.让内容在79个字符宽的页面上右对齐</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; printf &quot;%79s\n&quot;, $0 &#125;&#x27;</span>     <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里使用了printf函数，格式化输出，这里打印$0代表整行，长度不够79的会在左边补齐空格的。左边补齐就达到了右对齐的效果。</p>
<p>30.让内容在79个字符宽的页面上居中对齐</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; l=length(); s=int((79-l)/2); printf &quot;%&quot;(s+l)&quot;s\n&quot;, $0 &#125;&#x27;</span>     <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里使用length函数计算行的长度，然后算出中间   #</p>
<p>31.替换每行的 “foo” 为 “bar”</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; sub(/foo/,&quot;bar&quot;); print &#125;&#x27;</span>     <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个用到了sub()函数，需要注意的是，这个函数只会替换第一次出现匹配的。需要全部都替换用gsub()函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; gsub(/foo/,&quot;bar&quot;); print &#125;&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实还有一个函数gensub()也有替换的功能的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gawk <span class="string">&#x27;&#123; $0 = gensub(/foo/,&quot;bar&quot;,4); print &#125;&#x27;</span>    <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个只会替换第四次出现foo的地方。这个函数原型是gensub(regex, s, h[, t])，<br>他将字符串t中的第h个regex匹配的替换成s。如果没有提供t参数，那么默认t就是$0，就是整行内容。<br>这个函数和sub()和gsub()不一样，这个函数是返回修改t之后的值。<br>那2个是直接在原来的基础上修改。所以这里它最后有重新赋值给变量$0了。</p>
<p>这个技巧里面regex &#x3D; “&#x2F;foo&#x2F;“, s &#x3D; “bar”, h &#x3D; 4,  t &#x3D; $0，它替换了第四次出现foo的地方为bar，最后把替换过的字符串重新赋值给$0，也就相当于赋值给整行了，相当于修改了整行。</p>
<p>32.替换包含baz的行里面的foo为bar</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;/baz/ &#123; gsub(/foo/, &quot;bar&quot;) &#125;; &#123; print &#125;&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每个awk的都包含一个pattern-action这样的组合语句的。写法类似”pattern { action statements }”。<br>每个action都作用到匹配pattern的行上。<br>这个用法用pattern是&#x2F;baz&#x2F;，就是哪个行里面包含了字符串baz就会成功匹配上。<br>匹配上就会执行action，这里的动作是一个替换操作，执行gsub()函数，替换foo为bar。</p>
<p>32.替换不包含baz的行里面的foo为bar</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;!/baz/ &#123; gsub(/foo/, &quot;bar&quot;) &#125;; &#123; print &#125;&#x27;</span> <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这用法正好和上个是相反的。!&#x2F;baz&#x2F;表示不包含baz的行。!让搜到baz的返回为假</p>
<p>34.把”scarlet” 或者 “ruby” 或者 “puce” 替换为 “red”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; gsub(/scarlet|ruby|puce/, &quot;red&quot;); print&#125;&#x27;</span>  <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个用法没上面特别的，还是用到了gsub()函数，这里用sub()就不对了，这里主要的就是<br>正则里面的的写法&#x2F;scarlet|ruby|puce&#x2F;。|竖线用来分割多个匹配，类似or。</p>
<p>35.反转打印文件的行(类似命令”tac”).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; a[i++] = $0 &#125; END &#123; for (j=i-1; j&gt;=0;) print a[j--] &#125;&#x27;</span> <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个就是倒着打印文件的每一行，类似命令tac。<br>这里首先在 { a[i++] &#x3D; $0 }里面把每一行的内容保存到数组a中。<br>最后在END动作里面倒序循环打印a数组。这样就做到了倒着打印文件每行了。</p>
<p>36.把以反斜线 \ 结束的行和下面一行链接到一行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;/\\$/ &#123; sub(/\\$/,&quot;&quot;); getline t; print $0 t; next &#125;; 1&#x27;</span>  <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在某些编程语言中，行太长 可以拆成2行的，就是以反斜线来表示的。反斜线表示链接这一行和下一行内容。<br>这用法中&#x2F;\$&#x2F; 就是匹配反斜线结尾的行，然后是用sub()替换删除这个反斜线。<br>然后getline函数获取下一行的内容并保存到变量t中。<br>然后是print 打印当前行$0,（这个行已经移除结尾的反斜线了）和变量t的内容。<br>然后是next跳过下一行。<br>上面的一切都是在满足匹配&#x2F;\$&#x2F;的情况下才会执行花括号里面的动作的。<br>如果不满足匹配，也就是不是反斜线结尾的行 就会直接执行1，也就是打印整行内容。</p>
<p>不过这不能作用到2个以上连续行都有反斜线的情况。</p>
<p>37.打印，排序登陆的所有用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">&quot;:&quot;</span> <span class="string">&#x27;&#123; print $1 | &quot;sort&quot; &#125;&#x27;</span> /etc/passwd      <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里我们用到了awk的-F选项，这个是设置内部字段分隔符，也就每行按照那个字符来分割，<br>这里是按照冒号分割。应为&#x2F;etc&#x2F;passwd这个文件每行都是以冒号隔开的一个一个字段的。<br>awk -F “:”等价于awk ‘BEGIN { FS&#x3D;”:” }’</p>
<p>38.打印第二个字段，然后是第一个字段</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; print $2, $1 &#125;&#x27;</span> file     <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个没什么讲的，很简单的。</p>
<p>39.交换第一个字段和第二个字段，然后是打印每行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; temp = $1; $1 = $2; $2 = temp; print &#125;&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>40.删除第二个字段，然后打印每行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; $2 = &quot;&quot;; print &#125;&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>41.逆序一行的所有字段，然后打印整行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; for (i=NF; i&gt;0; i--) printf(&quot;%s &quot;, $i); printf (&quot;\n&quot;) &#125;&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意这个这倒着打印文件不一样，这个是倒序每一行的所有字段的。<br>变量NF是整行的字段总数。我们只有倒着变量这个数字就像。先打印$NF,然后是$(NF-1),$(NF-2),最后是$1.</p>
<p>42.删除重复行 (类似 “uniq”)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;a != $0; &#123; a = $0 &#125;&#x27;</span>   <span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>注意这个a !&#x3D; $0;是省略了action的，其实是a !&#x3D; $0 { print };<br>开始第一行肯定不满足条件 a !&#x3D; $0的，所以执行后面的 把第一行内容先赋值给变量a。<br>然后执行下面的行判断下面的每一行和先前的变量a是否相等。相等就会重新赋值变量a。<br>不想等才会打印当前行。</p>
<p>43.删除重复不连续的行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;!a[$0]++&#x27;</span>      <span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>把每一行保存到索引数组a中，第一次a[]++整个会是0的。但是a[]此时已经是1了。<br>下次再有同样的行a[]++就会非0值啦。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;!($0 in a) &#123; a[$0]; print &#125;&#x27;</span>  <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>44.把每5行用逗号相连.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;ORS=NR%5?&quot;,&quot;:&quot;\n&quot;&#x27;</span>    <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果行号NR能被5整除，重新赋值ORS的值</p>
<h1 id="Part-3-Selective-Printing-and-Deleting-of-Certain-Lines"><a href="#Part-3-Selective-Printing-and-Deleting-of-Certain-Lines" class="headerlink" title="Part 3: Selective Printing and Deleting of Certain Lines"></a>Part 3: Selective Printing and Deleting of Certain Lines</h1><p>##4. Selective Printing of Certain Lines</p>
<p>45.打印文件前10行(模拟命令”head -10”).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;NR &lt; 11&#x27;</span>      <span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>NR是行号，这里pattern是 ‘NR &lt; 11’ 表示行号小于11，也就是小于等于10行的行都会打印。<br>这里省略了action，省略了就是{print}</p>
<p>上面这个有一点不好的就是超过10行的行还会继续循环下去，只是什么都不做而已。下面给个更好的解决方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;1; NR == 10 &#123; exit &#125;&#x27;</span>  <span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>这就是当行号等于10行就exit，退出了。</p>
<p>46.打印文件第一行(模拟命令 “head -1”).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;NR &gt; 1 &#123; exit &#125;; 1&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>47.打印文件最后2行 (模拟命令 “tail -2”).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123; y=x &quot;\n&quot; $0; x=$0 &#125;; END &#123; print y &#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>这一句看起来确实有些别扭。第一句总是把一个在当前行前面再加上变量x的内容赋值给y，然后用x记录当前行内容。<br>这样的效果是y的内容始终是上一行加上当前行的内容。<br>在最后END模式中输出y的内容。<br>如果仔细看的话，不难发现这个写法是很不高效的，因为它不停的进行赋值和字符串连接，只为了找到最后一行！所以，如果你想要输出文件的最后两行，tail -n 2是最好的选择。</p>
<p>48.打印文件最后1行 (模拟命令 “tail -1”)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;END &#123; print &#125;&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个可能工作，也可能不工作，这在有些版本的awk上不是我们想用的结果。这个取决于变量$0是否在输入结束后被重置。</p>
<p>兼容的写法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; rec=$0 &#125; END&#123; print rec &#125;&#x27;</span>  <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个也有效率的问题，使用tail -1是最好的选择</p>
<p>49.打印匹配正则表达式的某行 “&#x2F;regex&#x2F;“ (模拟命令 “grep”).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;/regex/&#x27;</span>      <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里使用’&#x2F;regex&#x2F;‘作为pattern，省略了action，如果当前行匹配这个正则表达式，结果是true，就会执行后面的<br>action，就是{print}，相当于打印整行内容。</p>
<ol start="50">
<li>打印不匹配正则表达式的某行 “&#x2F;regex&#x2F;“ (模拟命令 “grep -v”).<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;!/regex/&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
！这个感叹号会把结果置为相反的。这里就是表示不匹配。</li>
</ol>
<p>51.打印匹配模式的行的上一行，而非当前行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;/regex/ &#123; print x &#125;; &#123; x=$0 &#125;&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个类似grep -B 1</p>
<p>这里有2个 pattern-action，<br>{ x&#x3D;$0 } 这一组是总是会执行的，总是把当前行内容保存到变量x中<br>&#x2F;regex&#x2F; { print x } 这一组是只有在匹配到regex时候才会执行后面的action的，<br>这里是打印x变量内容。x变量此时保存的还是上次的结果，也就是当前匹配行的上一行的内容。</p>
<p>如果是第一行就匹配了，直接执行{ print x }，但是此时x还是空值的。</p>
<p>如果是第一行不匹配，然后接着执行 { x&#x3D;$0 } ，这个时候x保存第一行内容。<br>然后是第二行，如果匹配，就执行{ print x }，也就是打印了第一行的内容。其他的依次类推。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;/regex/ &#123; print (x==&quot;&quot; ? &quot;match on line 1&quot; : x) &#125;; &#123; x=$0 &#125;&#x27;</span>  <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个无非就是加了个判断x是不是空值，因为第一行就匹配的时候x是空的。</p>
<p>52.打印匹配模式的下一行.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;/regex/ &#123; getline; print &#125;&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里使用了getline函数取得下一行的内容并输出。getline的作用是将$0的内容置为下一行的内容，<br>并同时更新NR，NF，FNR变量。如果匹配的是最后一行，getline会出错，$0不会被更新，最后一行会被打印。</p>
<p>这个类似grep -A 1</p>
<p>53.打印匹配AAA或者BBB或者CCC的行.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;/AAA|BBB|CCC/&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里用到竖线 | 符号，类似or的意思</p>
<p>54.打印包含”AAA”  “BBB”,  “CCC” 先后顺序要对.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;/AAA.*BBB.*CCC/&#x27;</span> <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>55.打印行长度大于64的行.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;length &gt; 64&#x27;</span>   <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>56.打印行长度小于64的行.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;length &lt; 64&#x27;</span>   <span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>57.打印匹配regex的行开始到文件结尾的之间的行.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;/regex/,0&#x27;</span>    <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里用到了’pattern1, pattern2’  这样的模式匹配，表示一个区间的。熟悉vim的都知道。<br>这个两个模式区间都是闭区间的。也就是包括pattern1的行，结束也是包括pattern2的行的。</p>
<p>58.打印 第8到第12行(包括).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;NR==8,NR==12&#x27;</span>  <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>NR表示行号，使用&#x3D;&#x3D;来判断相等，</p>
<p>59.打印第52行.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;NR==52&#x27;</span>     <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样会影响效率，52行之后的照样会循环一下，但是上面都不做。<br>好的做法是52行后之间退出循环。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;NR==52 &#123; print; exit &#125;&#x27;</span>  <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>60.打印连个正则表达式匹配的行之间的行(包括).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;/Iowa/,/Montana/&#x27;</span>     <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里再次用到了区间匹配模式”pattern1,pattern2”</p>
<p>##5. Selective Deletion of Certain Lines</p>
<p>这里只有一个技巧</p>
<p>61.删除所有空白行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk NF         <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里用到了特殊变量NF，表示当前行的字段数<br>字段数如果是0表明是空行呗，0表示false，所有后面省略的action就不会执行啦。<br>字段数如果不是0就表明整行有内容。就打印。</p>
<p>还有另外一个实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;/./&#x27;</span>     <span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>模式&#x2F;.&#x2F;会匹配一个字符，空行当然是不会被匹配上的啦。   #</p>
<h1 id="Part-4-String-and-Array-Creation"><a href="#Part-4-String-and-Array-Creation" class="headerlink" title="Part 4: String and Array Creation"></a>Part 4: String and Array Creation</h1><h2 id="String-Creation"><a href="#String-Creation" class="headerlink" title="String Creation"></a>String Creation</h2><p>1.创建一个固定长度的字符串.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123; while (a++&lt;513) s=s &quot;x&quot;; print s &#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个段程序用BEGIN这个特殊的匹配模式让后面的代码在awk试图读入任何东西前就执行。在里面是一个被执行了513次的循环，每次循环中“x”都被添加到变量s的最后。循环结束后，s的内容被输出。因为这段代码只有这一句，所以awk在执行完BEGIN模式语句后就退出了。<br>这段循环代码不仅仅可用在BEGIN中，你可以在awk的任何代码段里面使用，包括END。</p>
<p>很不幸这段代码不是最有效率的，这是一个线性的解决方案</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function rep(str, num,     remain, result) &#123;</span><br><span class="line">    if (num &lt; 2) &#123;</span><br><span class="line">        remain = (num == 1)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        remain = (num % 2 == 1)</span><br><span class="line">        result = rep(str, (num - remain) / 2)</span><br><span class="line">    &#125;</span><br><span class="line">    return result result (remain ? str  : &quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数同样用到三元运算a?b:c，而定义的该函数的内部又不停的调用函数本身，达到循环的目的。而前面的if……else语句主要用业说明remain是一个奇数。而通过下面的语句调用该函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123; s = rep(&quot;x&quot;, 513) &#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Another way to make n copies of a string s:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> repeat(n, s      , str)</span><br><span class="line">&#123;</span><br><span class="line">   str = sprintf(<span class="string">&quot;%*s&quot;</span>, n, <span class="string">&quot; &quot;</span>); <span class="comment"># make n spaces</span></span><br><span class="line">   gsub(/ /, s, str); <span class="comment"># replace space with s</span></span><br><span class="line">   <span class="built_in">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#Another idiom I sometimes use is this to make a string of &quot;-&quot; to underline another string:</span></span><br><span class="line"></span><br><span class="line">ul = str; <span class="comment"># copy the string</span></span><br><span class="line">gsub(/./, <span class="string">&quot;-&quot;</span>, ul); <span class="comment"># replace each char with &quot;-&quot;</span></span><br><span class="line"><span class="built_in">print</span> str; <span class="comment"># print the string</span></span><br><span class="line"><span class="built_in">print</span> ul; <span class="comment"># underline it</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.在某个位置插入指定长度的字符串</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gawk --re-interval <span class="string">&#x27;BEGIN&#123; while(a++&lt;49) s=s &quot;x&quot; &#125;; &#123; sub(/^.&#123;6&#125;/,&quot;&amp;&quot; s) &#125;; 1&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码只能在gawk下使用，因为它用到了interval expression，即这里的{6}，作用是让前一个字符.匹配多次。.{6}便可以匹配6个任意字符。gawk使用interval expression需要用到参数-re-interval。</p>
<p>同前一例一样，首先在BEGIN段里面，建立了一个49个字符长的字符串放在变量s里。接下来是对每一行，进行替换，&amp;这里代表的是匹配的字符串部分，所以sub的结果是将每一行第7个字符开始的内容替换成了s。然后是逐行输出。</p>
<p>如果不是gawk，需要这样写</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123; while(a++&lt;49) s=s &quot;x&quot; &#125;; &#123; sub(/^....../,&quot;&amp;&quot; s) &#125;; 1</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>其输出结果为从每行的第六个字符开始，连续输出49个x，然后再接着输出原来的行第七个字符及其以后的内容。如果每行不足七个字符时，该行输出的值不变。</p>
<p>注意：上面语句中的点并不是点本身的意思，而是代码任意一个字符，有点类似于bash脚本中用到字段?所代表的意思</p>
<h2 id="Array-Creation"><a href="#Array-Creation" class="headerlink" title="Array Creation"></a>Array Creation</h2><p>3.利用一个字符串创建一个数组.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span>(<span class="string">&quot;Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec&quot;</span>, month, <span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>4.建立一个索引数组.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=1; i&lt;=12; i++) mdigit[month[i]] = i</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5.打印第5个字段是 “abc123” 的那一行.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;$5 == &quot;abc123&quot;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; if ($5 == &quot;abc123&quot;) &#123; print $0 &#125; &#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.打印第5个字段不等于 “abc123”的行.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;$5 != &quot;abc123&quot;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; if ($5 != &quot;abc123&quot;) &#123; print $0 &#125; &#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;!($5 == &quot;abc123&quot;)&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>7.打印第7个字段匹配某个正则表达式的行.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;$7  ~ /^[a-f]/&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里用到了～波浪符号，这里表示$7 是否匹配 后面的正则表达式&#x2F;^[a-f]&#x2F;‘</p>
<p>下面这表示不匹配</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;$7 !~ /^[a-f]/&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;$7 ~ /^[^a-f]/&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="10-Awk-Tips-Tricks-and-Pitfalls"><a href="#10-Awk-Tips-Tricks-and-Pitfalls" class="headerlink" title="10 Awk Tips, Tricks and Pitfalls"></a>10 Awk Tips, Tricks and Pitfalls</h1><h2 id="Be-idiomatic"><a href="#Be-idiomatic" class="headerlink" title="Be idiomatic!"></a>Be idiomatic!</h2><p>假设想打印某些匹配的行，一般会这样写awk代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;if ($0 ~ /pattern/) print $0&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不过这里有几点需要注意的，这个结构和我们平常使用awk结构是不一样的，我通常的结构是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition &#123; actions &#125;</span><br></pre></td></tr></table></figure>
<p>所以上面的可以很清楚的改写为下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;$0 ~ /pattern/ &#123;print $0&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>&#x2F;pattern&#x2F; 是和这个等价的 $0 ~ &#x2F;pattern&#x2F;<br>print是和print $0语句一个意思的。默认省略了$0.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;/pattern/&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果是这样的没有action的，默认是print $0的。</p>
<p>如果你只是想按照某些条件来打印文件的某行可以像下面这样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;(NR%2 &amp;&amp; /pattern/) || (!(NR%2) &amp;&amp; /anotherpattern/)&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这里省略了action部分，除非你想要的action不是print $0，你就要明确的给出action了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk 1</span><br><span class="line">awk <span class="string">&#x27;&quot;a&quot;&#x27;</span>   <span class="comment"># single quotes are important!</span></span><br></pre></td></tr></table></figure>
<p>上面这2个都是打印源文件的每一行，每一行都没有做任何改变的。</p>
<p>如果你想操作修改输出的某些行，但是你还想打印出所有的行，你可以像这样 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;sub(/pattern/,&quot;foobar&quot;)&#125;1&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;NR % 6&#x27;</span>            <span class="comment"># prints all lines except those divisible by 6</span></span><br><span class="line">awk <span class="string">&#x27;NR &gt; 5&#x27;</span>            <span class="comment"># prints from line 6 onwards (like tail -n +6, or sed &#x27;1,5d&#x27;)</span></span><br><span class="line">awk <span class="string">&#x27;$2 == &quot;foo&quot;&#x27;</span>       <span class="comment"># prints lines where the second field is &quot;foo&quot;</span></span><br><span class="line">awk <span class="string">&#x27;NF &gt;= 6&#x27;</span>           <span class="comment"># prints lines with 6 or more fields</span></span><br><span class="line">awk <span class="string">&#x27;/foo/ &amp;&amp; /bar/&#x27;</span>    <span class="comment"># prints lines that match /foo/ and /bar/, in any order</span></span><br><span class="line">awk <span class="string">&#x27;/foo/ &amp;&amp; !/bar/&#x27;</span>   <span class="comment"># prints lines that match /foo/ but not /bar/</span></span><br><span class="line">awk <span class="string">&#x27;/foo/ || /bar/&#x27;</span>    <span class="comment"># prints lines that match /foo/ or /bar/ (like grep -e &#x27;foo&#x27; -e &#x27;bar&#x27;)</span></span><br><span class="line">awk <span class="string">&#x27;/foo/,/bar/&#x27;</span>       <span class="comment"># prints from line matching /foo/ to line matching /bar/, inclusive</span></span><br><span class="line">awk <span class="string">&#x27;NF&#x27;</span>                <span class="comment"># prints only nonempty lines (or: removes empty lines, where NF==0)</span></span><br><span class="line">awk <span class="string">&#x27;NF--&#x27;</span>              <span class="comment"># removes last field and prints the line</span></span><br><span class="line">awk <span class="string">&#x27;$0 = NR&quot; &quot;$0&#x27;</span>      <span class="comment"># prepends line numbers (assignments are valid in conditions)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;NR==FNR &#123; # some actions; next&#125; # other condition &#123;# other actions&#125;&#x27;</span> file1 file2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prints lines that are both in file1 and file2 (intersection)</span></span><br><span class="line">awk <span class="string">&#x27;NR==FNR&#123;a[$0];next&#125; $0 in a&#x27;</span> file1 file2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># use information from a map file to modify a data file</span></span><br><span class="line">awk <span class="string">&#x27;NR==FNR&#123;a[$1]=$2;next&#125; &#123;$3=a[$3]&#125;1&#x27;</span> <span class="built_in">mapfile</span> datafile</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># replace each number with its difference from the maximum</span></span><br><span class="line">awk <span class="string">&#x27;NR==FNR&#123;if($0&gt;max) max=$0;next&#125; &#123;$0=max-$0&#125;1&#x27;</span> file file</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Pitfall-shorten-pipelines"><a href="#Pitfall-shorten-pipelines" class="headerlink" title="Pitfall: shorten pipelines"></a>Pitfall: shorten pipelines</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">somecommand | <span class="built_in">head</span> -n +1 | grep foo | sed <span class="string">&#x27;s/foo/bar/&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;[a-z]&#x27;</span> <span class="string">&#x27;[A-Z]&#x27;</span> | <span class="built_in">cut</span> -d <span class="string">&#x27; &#x27;</span> -f 2</span><br><span class="line"></span><br><span class="line">somecommand | awk <span class="string">&#x27;NR&gt;1 &amp;&amp; /foo/&#123;sub(/foo/,&quot;bar&quot;); print toupper($2)&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Print-lines-using-ranges"><a href="#Print-lines-using-ranges" class="headerlink" title="Print lines using ranges"></a>Print lines using ranges</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prints lines from /beginpat/ to /endpat/, inclusive</span></span><br><span class="line">awk <span class="string">&#x27;/beginpat/,/endpat/&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有时候我们像打印匹配某2个条件之间的某些行，不包括匹配的那个行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prints lines from /beginpat/ to /endpat/, not inclusive</span></span><br><span class="line">awk <span class="string">&#x27;/beginpat/,/endpat/&#123;if (!/beginpat/&amp;&amp;!/endpat/)print&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># prints lines from /beginpat/ to /endpat/, not including /beginpat/</span></span><br><span class="line">awk <span class="string">&#x27;/beginpat/,/endpat/&#123;if (!/beginpat/)print&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prints lines from /beginpat/ to /endpat/, not inclusive</span></span><br><span class="line">awk <span class="string">&#x27;/endpat/&#123;p=0&#125;;p;/beginpat/&#123;p=1&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># prints lines from /beginpat/ to /endpat/, excluding /endpat/</span></span><br><span class="line">awk <span class="string">&#x27;/endpat/&#123;p=0&#125; /beginpat/&#123;p=1&#125; p&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># prints lines from /beginpat/ to /endpat/, excluding /beginpat/</span></span><br><span class="line">awk <span class="string">&#x27;p; /endpat/&#123;p=0&#125; /beginpat/&#123;p=1&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># prints lines from /beginpat/ to /endpat/, inclusive</span></span><br><span class="line">awk <span class="string">&#x27;/beginpat/&#123;p=1&#125;;p;/endpat/&#123;p=0&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子都是在遇到&#x2F;beginpat&#x2F;的行的时候把p设置为1.遇到&#x2F;endpat&#x2F;的行的时候把p设置为0.</p>
<h2 id="Split-file-on-patterns"><a href="#Split-file-on-patterns" class="headerlink" title="Split file on patterns"></a>Split file on patterns</h2><p>有个文件内容如下，我们想把匹配&#x2F;^FOO&#x2F;的行找出来，然后创建一些文件，out1，out2.<br>out1里面保存前4行。out2里面保存line5，line6这2行。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br><span class="line">line4</span><br><span class="line">FOO1</span><br><span class="line">line5</span><br><span class="line">line6</span><br><span class="line">FOO2</span><br><span class="line">line7</span><br><span class="line">line8</span><br><span class="line">FOO3</span><br><span class="line">line9</span><br><span class="line">line10</span><br><span class="line">line11</span><br><span class="line">FOO4</span><br><span class="line">line12</span><br><span class="line">FOO5</span><br><span class="line">line13</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># first way, works with all versions of awk</span></span><br><span class="line">awk -v n=1 <span class="string">&#x27;/^FOO[0-9]*/&#123;close(&quot;out&quot;n);n++;next&#125; &#123;print &gt; &quot;out&quot;n&#125;&#x27;</span> file</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>“-v n&#x3D;1” 是告诉awk把变量n初始值为1.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># another way, needs GNU awk</span></span><br><span class="line">LC_ALL=C gawk -v RS=<span class="string">&#x27;FOO[0-9]*\n&#x27;</span> -v ORS= <span class="string">&#x27;&#123;print &gt; &quot;out&quot;NR&#125;&#x27;</span> file</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Locale-based-pitfalls"><a href="#Locale-based-pitfalls" class="headerlink" title="Locale-based pitfalls"></a>Locale-based pitfalls</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 waldner users 46592 2003-09-12 09:41 file1</span><br><span class="line">-rw-r--r-- 1 waldner users 11509 2008-10-07 17:42 file2</span><br><span class="line">-rw-r--r-- 1 waldner users 11193 2008-10-07 17:41 file3</span><br><span class="line">-rw-r--r-- 1 waldner users 19073 2008-10-07 17:45 file4</span><br><span class="line">-rw-r--r-- 1 waldner users 36332 2008-10-07 17:03 file5</span><br><span class="line">-rw-r--r-- 1 waldner users 33395 2008-10-07 16:53 file6</span><br><span class="line">-rw-r--r-- 1 waldner users 54272 2008-09-18 16:20 file7</span><br><span class="line">-rw-r--r-- 1 waldner users 20573 2008-10-07 17:50 file8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ LC_ALL=en_US.utf8 awk --re-interval <span class="string">&#x27;&#123;sub(/^([^[:space:]]+[[:space:]]+)&#123;3&#125;/,&quot;&quot;)&#125;1&#x27;</span> file</span><br><span class="line">-rw-r--r-- 1 waldner <span class="built_in">users</span> 46592 2003-09-12 09:41 file1</span><br><span class="line">-rw-r--r-- 1 waldner <span class="built_in">users</span> 11509 2008-10-07 17:42 file2</span><br><span class="line">-rw-r--r-- 1 waldner <span class="built_in">users</span> 11193 2008-10-07 17:41 file3</span><br><span class="line">-rw-r--r-- 1 waldner <span class="built_in">users</span> 19073 2008-10-07 17:45 file4</span><br><span class="line">-rw-r--r-- 1 waldner <span class="built_in">users</span> 36332 2008-10-07 17:03 file5</span><br><span class="line">-rw-r--r-- 1 waldner <span class="built_in">users</span> 33395 2008-10-07 16:53 file6</span><br><span class="line">-rw-r--r-- 1 waldner <span class="built_in">users</span> 54272 2008-09-18 16:20 file7</span><br><span class="line">-rw-r--r-- 1 waldner <span class="built_in">users</span> 20573 2008-10-07 17:50 file8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ LC_ALL=C awk --re-interval <span class="string">&#x27;&#123;sub(/^([^[:space:]]+[[:space:]]+)&#123;3&#125;/,&quot;&quot;)&#125;1&#x27;</span> file</span><br><span class="line"><span class="built_in">users</span> 46592 2003-09-12 09:41 file1</span><br><span class="line"><span class="built_in">users</span> 11509 2008-10-07 17:42 file2</span><br><span class="line"><span class="built_in">users</span> 11193 2008-10-07 17:41 file3</span><br><span class="line"><span class="built_in">users</span> 19073 2008-10-07 17:45 file4</span><br><span class="line"><span class="built_in">users</span> 36332 2008-10-07 17:03 file5</span><br><span class="line"><span class="built_in">users</span> 33395 2008-10-07 16:53 file6</span><br><span class="line"><span class="built_in">users</span> 54272 2008-09-18 16:20 file7</span><br><span class="line"><span class="built_in">users</span> 20573 2008-10-07 17:50 file8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;èòàù&#x27;</span> | LC_ALL=en_US.utf8 awk <span class="string">&#x27;/[a-z]/&#x27;</span></span><br><span class="line">èòàù</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Parse-CSV"><a href="#Parse-CSV" class="headerlink" title="Parse CSV"></a>Parse CSV</h2><p>解析csv格式文件，这种格式文件都是逗号分割的一个一个字段，我们可以设置FS&#x3D;’,’，字段的前后可能会有空格<br>，这些空格是我们不需要的，最后需要去掉这些空格。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">field1  ,   field2   , field3   , field4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>变量 FS 可以是一个正则表达式,例如 FS&#x3D;’^ *| *, *| *$’. 但是呢这个有可能有问题的:</p>
<ul>
<li>实际的分割后的数据可能对应 字段1 … 字段NF 或者 字段2 … 字段NF, 这取决于这一行开头是否有空格;</li>
<li>出于某种原因把FS赋值为正则的，如果字段中包含了空格可能导致不确定的结果。</li>
</ul>
<p>变量FS是field-separator，字段分隔符的意思。</p>
<p>对于这个例子，我们最好的做法是设置FS&#x3D;”,”，然后移除字段前后的空格。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FS=&#x27;,&#x27;</span></span><br><span class="line"><span class="keyword">for</span>(i=1;i&lt;=NF;i++)&#123;</span><br><span class="line">  gsub(/^ *| *$/,<span class="string">&quot;&quot;</span>,<span class="variable">$i</span>);</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Field &quot;</span> i <span class="string">&quot; is &quot;</span> <span class="variable">$i</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外一种格式的csv文件：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;field1&quot;,&quot;field2&quot;,&quot;field3&quot;,&quot;field4&quot;</span><br></pre></td></tr></table></figure>
<p>这个是每个字段都包含了双引号。这个我们可以简单的设置FS&#x3D;’^”|”,”|”$’ (或者 FS&#x3D;’”,”|”‘)<br>这个需要注意的是我们最后取的字段的位置是2, 3 … NF-1.</p>
<p>我们还可以扩展FS，让他可以处理到空格的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;field1&quot;  , &quot;field2&quot;,   &quot;field3&quot; , &quot;field4&quot;</span><br></pre></td></tr></table></figure>
<p>FS可以设置为：FS&#x3D;’^ *”|” *, *”|” *$’，注意字段的位置我们这里是2 … NF-1 是我们需要的。<br>当然你也可以把FS设置为：FS&#x3D;’,’,然后手动处理多余的空格和双引号等字符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># FS=&#x27;,&#x27;</span></span><br><span class="line"><span class="keyword">for</span>(i=1;i&lt;=NF;i++)&#123;</span><br><span class="line">  gsub(/^ *<span class="string">&quot;|&quot;</span> *$/,<span class="string">&quot;&quot;</span>,<span class="variable">$i</span>);</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;Field &quot;</span> i <span class="string">&quot; is &quot;</span> <span class="variable">$i</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外一种特别的格式的csv文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">field1, <span class="string">&quot;field2,with,commas&quot;</span>  ,  field3  ,  <span class="string">&quot;field4,foo&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个是有的字段有双引号，有的字段没有，而且中间可能有空格。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$0</span>=<span class="variable">$0</span><span class="string">&quot;,&quot;</span>;                                  <span class="comment"># yes, cheating</span></span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$0</span>) &#123;</span><br><span class="line">  match(<span class="variable">$0</span>,/[^,]*,| *<span class="string">&quot;[^&quot;</span>]*<span class="string">&quot; *,/);            </span></span><br><span class="line"><span class="string">  sf=f=substr(<span class="variable">$0</span>,RSTART,RLENGTH);          # save what matched in sf</span></span><br><span class="line"><span class="string">  gsub(/^ *&quot;</span>?|<span class="string">&quot;? *,$/,&quot;</span><span class="string">&quot;,f);               # remove extra stuff</span></span><br><span class="line"><span class="string">  print &quot;</span>Field <span class="string">&quot; ++c &quot;</span> is <span class="string">&quot; f;</span></span><br><span class="line"><span class="string">  sub(sf,&quot;</span><span class="string">&quot;);                              # &quot;</span>consume<span class="string">&quot; what matched</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h2 id="Pitfall-validate-an-IPv4-address"><a href="#Pitfall-validate-an-IPv4-address" class="headerlink" title="Pitfall: validate an IPv4 address"></a>Pitfall: validate an IPv4 address</h2><p>检查ipv4地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk -F <span class="string">&#x27;[.]&#x27;</span> <span class="string">&#x27;function ok(n)&#123;return (n&gt;=0 &amp;&amp; n&lt;=255)&#125; &#123;exit (ok($1) &amp;&amp; ok($2) &amp;&amp; ok($3) &amp;&amp; ok($4))&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的没有对字母进行验证。像传入这样的 ‘123b.44.22c.3’ 也能验证通过。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">&#x27;[.]&#x27;</span> <span class="string">&#x27;function ok(n) &#123;</span></span><br><span class="line"><span class="string">  return (n ~ /^([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$/)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123;exit (ok($1) &amp;&amp; ok($2) &amp;&amp; ok($3) &amp;&amp; ok($4))&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Check-whether-two-files-contain-the-same-data"><a href="#Check-whether-two-files-contain-the-same-data" class="headerlink" title="Check whether two files contain the same data"></a>Check whether two files contain the same data</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;!($0 in a) &#123;c++;a[$0]&#125; END &#123;exit(c==NR/2?0:1)&#125;&#x27;</span> file1 file2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Pitfall-contexts-and-variable-types-in-awk"><a href="#Pitfall-contexts-and-variable-types-in-awk" class="headerlink" title="Pitfall: contexts and variable types in awk"></a>Pitfall: contexts and variable types in awk</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1,2,3,,5,foo</span><br><span class="line">1,2,3,0,5,bar</span><br><span class="line">1,2,3,4,5,baz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk -F <span class="string">&#x27;,&#x27;</span> -v OFS=<span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;&#123;if ($4) $6=&quot;X&quot;&#125;1&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个我们是想把某行第四个字段不是空的情况的行里面的第6个字段复制为X。但是这3行只有最后一行被赋值了。<br>倒数第二行没有赋值。这是怎么回事呢？难道0是个空字符吗？</p>
<p>在awk中，只有数字和字符串2中类型的数据。awk会把看起来像数字的当成数字，其他的当成字符串。<br>这个”if ($4)”没有给出确定的上下文，它可以测试任何类型的数据。<br>在第一行 $4是一个空字符串，所以这里if里面是false。<br>在第二行 $4 是 ”0“，这个看起来是个数字，所以awk把它当成数字0 了。而不是字符串”0”，所以if也是false。  </p>
<p>幸运的是我们有方法来告诉awk数据是上面类型。</p>
<ul>
<li>我们可以在$4后面跟上一个空的双引号来告诉awk我们想让这个当成字符串来使用。后面追加个空字符串原来是值是不变的。</li>
<li>我们还有可以在$4上加上0来告诉awk我们要把它作为数字来使用，加个0原来的数值是不变的。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">&#x27;,&#x27;</span> -v OFS=<span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;&#123;if ($4&quot;&quot;) $6=&quot;X&quot;&#125;1&#x27;</span>   <span class="comment"># the &quot;&quot; forces awk to evaluate the variable as a string</span></span><br></pre></td></tr></table></figure>

<p>另外一个典型的问题就是下面这个：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">awk <span class="string">&#x27;/foo/&#123;tot++&#125; END&#123;print tot&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个是计算包含&#x2F;foo&#x2F;行的个数的，但是如果没有一行匹配，最后是会打印个空字符串的。而不是打印个0.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;/foo/&#123;tot++&#125; END&#123;print tot+0&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>和上面说的一样。我们可以给一个变量加上一个0，让awk把它作为数字来使用。</p>
<h2 id="Pulling-out-things"><a href="#Pulling-out-things" class="headerlink" title="Pulling out things"></a>Pulling out things</h2><p>假设有这样一段文本。我们像提取出&#x3D;something&#x3D;之间的内容的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Yesterday I was walking <span class="keyword">in</span> =the street=, when I saw =a</span><br><span class="line">black dog=. There was also =a <span class="built_in">cat</span>= hidden around there. =The sun= was shining, and =the sky= was blue.</span><br><span class="line">I entered =the</span><br><span class="line">music</span><br><span class="line">shop= and I bought two CDs. Then I went to =the cinema= and watched =a very <span class="built_in">nice</span> movie=.</span><br><span class="line">End of the story.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk -v RS=<span class="string">&#x27;=&#x27;</span> <span class="string">&#x27;!(NR%2)&#x27;</span></span><br><span class="line"><span class="comment"># awk -v RS=&#x27;=&#x27; &#x27;!(NR%2)&#123;gsub(/\n/,&quot; &quot;);print&#125;&#x27;    # if you want to reformat embedded newlines</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里我们设置了RS为‘&#x3D;’,这样我们可以打印偶数的。</p>
<p>对于这样的<tag>something</tag>.格式的数据。使用gnu awk可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gawk -v RS=<span class="string">&#x27;&lt;/?tag&gt;&#x27;</span> <span class="string">&#x27;RT==&quot;&lt;/tag&gt;&quot;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gawk -v RS=<span class="string">&#x27;&lt;/?tag&gt;&#x27;</span> <span class="string">&#x27;!(NR%2)&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RS          The input record separator, by default a newline.</p>
<p>RT          The record terminator.  Gawk sets RT to the input text that matched the character or regular expression specified by RS.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gawk -v RS=<span class="string">&#x27;[0-9]+&#x27;</span> <span class="string">&#x27;RT&#123;print RT&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>改进版，检查RT是否是null。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gawk -v RS=<span class="string">&#x27;--[0-9]+--&#x27;</span> <span class="string">&#x27;RT&#123;gsub(/--/,&quot;&quot;,RT);print RT&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





































<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#==</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#==</span></span><br></pre></td></tr></table></figure>


</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://magesfc.github.io">mage</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://magesfc.github.io/mage/fbdc2108c9ff66cef6915dd7b0ca474e0f1bfcab/">https://magesfc.github.io/mage/fbdc2108c9ff66cef6915dd7b0ca474e0f1bfcab/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://magesfc.github.io" target="_blank">马哥私房菜</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/awk/">awk</a><a class="post-meta__tags" href="/tags/cookbook/">cookbook</a></div><div class="post_share"><div class="social-share" data-image="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/null" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/mage/b59a1b875d0ca22cb99053da9465b5cd63ed7be0/"><img class="prev-cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">struts学习笔记struts1的另一个简单例子--添加学生信息到数据库</div></div></a></div><div class="next-post pull-right"><a href="/mage/723b02719957f4b62c9c9e1a1e596e0386bbca91/"><img class="next-cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis学习笔记总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/mage/16b8c6357057536aa45c505f7c99cb9d22c87038/" title="Linux学习之awk学习之Linux-awk-command系列"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之awk学习之Linux-awk-command系列</div></div></a></div><div><a href="/mage/a718e01bee375dd72d94fd15211e2e4f41c0a52c/" title="Linux学习之bash学习之cookbook技巧"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之bash学习之cookbook技巧</div></div></a></div><div><a href="/mage/6a323979d022165779db1cbb3367540e235cec9e/" title="Linux学习之sed学习之cookbook技巧"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之sed学习之cookbook技巧</div></div></a></div><div><a href="/mage/04947dc3d5b90a6c19672409e839d803a0aef01a/" title="Linux学习之perl学习之cookbook技巧"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-10</div><div class="title">Linux学习之perl学习之cookbook技巧</div></div></a></div><div><a href="/mage/bead5c222ebd755a0ea0b8165ff0663545d6c700/" title="Linux学习之10个有用的链式操作符及其实例"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之10个有用的链式操作符及其实例</div></div></a></div><div><a href="/mage/29b1dee9b6336ea01be4716d95ecfbad663018d6/" title="Linux学习之bash学习之几个特殊变量"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Linux学习之bash学习之几个特殊变量</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mage</div><div class="author-info__description"> 这里是 马哥 的个人博客 </div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">173</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">194</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mamh2021"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mamh2021" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-1-File-Spacing-Numbering-and-Calculations"><span class="toc-number">1.</span> <span class="toc-text">Part 1: File Spacing, Numbering and Calculations</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-2-Text-Conversion-and-Substitution"><span class="toc-number">2.</span> <span class="toc-text">Part 2: Text Conversion and Substitution</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-3-Selective-Printing-and-Deleting-of-Certain-Lines"><span class="toc-number">3.</span> <span class="toc-text">Part 3: Selective Printing and Deleting of Certain Lines</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-4-String-and-Array-Creation"><span class="toc-number">4.</span> <span class="toc-text">Part 4: String and Array Creation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String-Creation"><span class="toc-number">4.1.</span> <span class="toc-text">String Creation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-Creation"><span class="toc-number">4.2.</span> <span class="toc-text">Array Creation</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Awk-Tips-Tricks-and-Pitfalls"><span class="toc-number">5.</span> <span class="toc-text">10 Awk Tips, Tricks and Pitfalls</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Be-idiomatic"><span class="toc-number">5.1.</span> <span class="toc-text">Be idiomatic!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pitfall-shorten-pipelines"><span class="toc-number">5.2.</span> <span class="toc-text">Pitfall: shorten pipelines</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Print-lines-using-ranges"><span class="toc-number">5.3.</span> <span class="toc-text">Print lines using ranges</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Split-file-on-patterns"><span class="toc-number">5.4.</span> <span class="toc-text">Split file on patterns</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Locale-based-pitfalls"><span class="toc-number">5.5.</span> <span class="toc-text">Locale-based pitfalls</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parse-CSV"><span class="toc-number">5.6.</span> <span class="toc-text">Parse CSV</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pitfall-validate-an-IPv4-address"><span class="toc-number">5.7.</span> <span class="toc-text">Pitfall: validate an IPv4 address</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Check-whether-two-files-contain-the-same-data"><span class="toc-number">5.8.</span> <span class="toc-text">Check whether two files contain the same data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pitfall-contexts-and-variable-types-in-awk"><span class="toc-number">5.9.</span> <span class="toc-text">Pitfall: contexts and variable types in awk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pulling-out-things"><span class="toc-number">5.10.</span> <span class="toc-text">Pulling out things</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/mage/f9fb8533b7fcbaa282e1c4322261c95286f87d4b/" title="Vue学习总结"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue学习总结"/></a><div class="content"><a class="title" href="/mage/f9fb8533b7fcbaa282e1c4322261c95286f87d4b/" title="Vue学习总结">Vue学习总结</a><time datetime="2023-05-17T12:57:40.000Z" title="更新于 2023-05-17 20:57:40">2023-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/5fdea0e0afeb79b51d1f69e4243be1023c59912b/" title="Android下的配置管理之道之repo的使用"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android下的配置管理之道之repo的使用"/></a><div class="content"><a class="title" href="/mage/5fdea0e0afeb79b51d1f69e4243be1023c59912b/" title="Android下的配置管理之道之repo的使用">Android下的配置管理之道之repo的使用</a><time datetime="2023-05-16T13:38:38.000Z" title="更新于 2023-05-16 21:38:38">2023-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/eb822dde30a05b68de146f64ccf79add56764b2e/" title="jenkins学习之plugin安装"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jenkins学习之plugin安装"/></a><div class="content"><a class="title" href="/mage/eb822dde30a05b68de146f64ccf79add56764b2e/" title="jenkins学习之plugin安装">jenkins学习之plugin安装</a><time datetime="2023-05-16T11:38:15.000Z" title="更新于 2023-05-16 19:38:15">2023-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/298144bf31bdad623369d39b38ebddb64dde1abd/" title="jenkins学习之Jenkins开发调试于jenkins插件开发调试"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jenkins学习之Jenkins开发调试于jenkins插件开发调试"/></a><div class="content"><a class="title" href="/mage/298144bf31bdad623369d39b38ebddb64dde1abd/" title="jenkins学习之Jenkins开发调试于jenkins插件开发调试">jenkins学习之Jenkins开发调试于jenkins插件开发调试</a><time datetime="2023-05-16T11:37:56.000Z" title="更新于 2023-05-16 19:37:56">2023-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mage/3364d844f59ae687146c5a61dd446be8a95af7ab/" title="Drone学习之drone-runner-exec源码学习"><img src= "/img/loading.gif" data-lazy-src="https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Drone学习之drone-runner-exec源码学习"/></a><div class="content"><a class="title" href="/mage/3364d844f59ae687146c5a61dd446be8a95af7ab/" title="Drone学习之drone-runner-exec源码学习">Drone学习之drone-runner-exec源码学习</a><time datetime="2023-04-22T03:07:54.000Z" title="更新于 2023-04-22 11:07:54">2023-04-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://office-1256119282.file.myqcloud.com/2022/official-web/cdn/20220301/pc_bg_05.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By mage</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>